<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rank Transform of an Array</title>
    <url>/2020/06/09/Rank-Transform-of-an-Array/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given an array of integers <code>arr</code>, replace each element with its rank.</p>
<p>The rank represents how large the element is. The rank has the following rules:</p>
<ul>
<li>Rank is an integer starting from 1.</li>
<li>The larger the element, the larger the rank. If two elements are equal, their rank must be the same.</li>
<li><p>Rank should be as small as possible.</p>
<a id="more"></a>
</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr = [40,10,20,30]</span><br><span class="line">Output: [4,1,2,3]</span><br><span class="line">Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr = [100,100,100]</span><br><span class="line">Output: [1,1,1]</span><br><span class="line">Explanation: Same elements share the same rank.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr = [37,12,28,9,100,56,80,5,12]</span><br><span class="line">Output: [5,3,4,2,8,6,7,1,3]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= arr.length &lt;= 105</code></li>
<li><code>-109 &lt;= arr[i] &lt;= 109</code></li>
</ul>
<hr>
<p>给你一个整数数组 <code>arr</code> ，请你将数组中的每个元素替换为它们排序后的序号。</p>
<p>序号代表了一个元素有多大。序号编号的规则如下：</p>
<ul>
<li>序号从 1 开始编号。</li>
<li>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。</li>
<li>每个数字的序号都应该尽可能地小。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [40,10,20,30]</span><br><span class="line">输出：[4,1,2,3]</span><br><span class="line">解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [100,100,100]</span><br><span class="line">输出：[1,1,1]</span><br><span class="line">解释：所有元素有相同的序号。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [37,12,28,9,100,56,80,5,12]</span><br><span class="line">输出：[5,3,4,2,8,6,7,1,3]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= arr.length &lt;= 105</code></li>
<li><code>-109 &lt;= arr[i] &lt;= 109</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>利用集合得到独特的数字, 利用字典对排序后的数字进行记录. 然后将原数组的数字根据字典进行转换即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrayRankTransform</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        set_ = set(arr)</span><br><span class="line">        sort_list = sorted(set_)</span><br><span class="line">        sort_dict = dict(zip(sort_list, range(<span class="number">1</span>, len(set_) + <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> [sort_dict[x] <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-06-09</li>
<li>击败比例: 48.24%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Number of Students Doing Homework at a Given Time</title>
    <url>/2020/06/07/LeetCode/Number-of-Students-Doing-Homework-at-a-Given-Time/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given two integer arrays <code>startTime</code> and <code>endTime</code> and given an integer <code>queryTime</code>.</p>
<p>The <code>ith</code> student started doing their homework at the time <code>startTime[i]</code> and finished it at time <code>endTime[i]</code>.</p>
<p>Return <em>the number of students</em> doing their homework at time <code>queryTime</code>. More formally, return the number of students where <code>queryTime</code> lays in the interval <code>[startTime[i], endTime[i]]</code> inclusive.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We have 3 students where:</span><br><span class="line">The first student started doing homework at time 1 and finished at time 3 and wasn&apos;t doing anything at time 4.</span><br><span class="line">The second student started doing homework at time 2 and finished at time 2 and also wasn&apos;t doing anything at time 4.</span><br><span class="line">The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: startTime = [4], endTime = [4], queryTime = 4</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The only student was doing their homework at the queryTime.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: startTime = [4], endTime = [4], queryTime = 5</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>startTime.length == endTime.length</code></li>
<li><code>1 &lt;= startTime.length &lt;= 100</code></li>
<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>
<li><code>1 &lt;= queryTime &lt;= 1000</code></li>
</ul>
<hr>
<p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>
<p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>
<p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4</span><br><span class="line">输出：1</span><br><span class="line">解释：一共有 3 名学生。</span><br><span class="line">第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。</span><br><span class="line">第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。</span><br><span class="line">第二名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime = [4], endTime = [4], queryTime = 4</span><br><span class="line">输出：1</span><br><span class="line">解释：在查询时间只有一名学生在做作业。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime = [4], endTime = [4], queryTime = 5</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>startTime.length == endTime.length</code></li>
<li><code>1 &lt;= startTime.length &lt;= 100</code></li>
<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>
<li><code>1 &lt;= queryTime &lt;= 1000</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>遍历数据进行比较即可, 非常简单.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, startTime, endTime, queryTime)</span>:</span></span><br><span class="line">        n = len(startTime)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> startTime[i] &lt;= queryTime &lt;= endTime[i]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-06-07</li>
<li>击败比例: 82.99%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>数据建模-模型评估</title>
    <url>/2020/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<p>利用机器学习算法得到模型, 对模型的评估是必不可少的关键一步.</p>
<p>因为首先, 通过模型评估, 可以知道模型到底效果好不好, 有多好.</p>
<p>其次如果模型不好, 大不了咱们不使用就行了嘛ヾ(´∀`o)+</p>
<p>再者, 通过模型评估过程, 可以发现一些问题, 进而可以尝试进行针对性的改动.</p>
<a id="more"></a>
<h1 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h1><p>在不同的场景, 不同的任务下, 评估模型的指标是不一样的.</p>
<p>在众多的指标中, 我认为总体说来可以分为两大类:</p>
<ul>
<li><p>适合训练模型的指标.</p>
<p>啥是适合训练模型的指标, 比如在二分类问题中, 训练模型时大部分默认的损失函数是logloss. 但是如果直接给我们展示一个logloss, 我们会对它有什么感受吗, 是大还是小呢? 这需要比较才能知道.</p>
</li>
<li><p>方便人们比较的指标.</p>
<p>一些方便人们直观感受的指标, 比如准确率accuracy, 曲线下面积AUC. 就拿accuracy来说, 我们知道其范围是0-1, 越大越好.</p>
</li>
</ul>
<p>除此之外, 同样的任务下, 根据样本的分布, 可以采取不同的评估指标. </p>
<p>仍然以二分类为例, 若正负样本均衡, 接近1:1的比例, 那这个时候用accuracy就可以. 但是若正负样本不均衡, 比如1:10的比例, 这时候再使用accuracy可能就不合适了. 可以考虑其它一些指标如F1, AUC. 而通常来说AUC更好一些, 因为相比F1, AUC指标更关注模型本身的区分度, 倘若样本中正负样本的比例发生变化(分层抽样), 那么F1会跟着变化, 而AUC会几乎保持不变.</p>
<p>常用的一些评估指标如下:</p>
<ul>
<li>分类.<ul>
<li>accuracy</li>
<li>AUC</li>
<li>F1</li>
<li>precision</li>
<li>recall</li>
<li>logloss</li>
</ul>
</li>
<li>回归.<ul>
<li>MSE</li>
<li>RMSE</li>
<li>MAE</li>
<li>R-squared</li>
</ul>
</li>
</ul>
<h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p>过拟合是一个老生常谈的话题了, 几乎每一个学习机器学习的同学, 在一开始就会被灌输这样的知识. 相比欠拟合, 过拟合更容易出现, 带来的后果也可能更严重.</p>
<p>而在这里, 不会严谨地去说明过拟合的概念呀神马的, 而是从我个人的经验上来进行一些思考, 不一定正确, 建议用批判性的方式阅读（○｀ 3′○）</p>
<ul>
<li><p>什么是过拟合.</p>
<p>过拟合通俗来讲, 指的是模型在训练集或者与训练集完全同分布的数据集上表现很好, 但是泛化性太差, 可能样本分布稍微变一点, 模型表现就大打折扣.</p>
</li>
<li><p>怎么判断过拟合.</p>
<p>判断是否过拟合, 有多种方法, 这里说一下我自己常用的方法. 一般来说, 我们建模的时候会有训练集, 验证集以及测试集. 通过观察对比模型在三份数据集, 或者仅仅观察训练集与验证集的表现, 来定性地进行是否过拟合判断.</p>
<p>举个栗子, 在二分类问题中, 以AUC为评估指标. 一个过拟合的模型, 可能在训练集上AUC为0.9, 验证集上0.7, 测试集上0.6. 而另一个模型, 在训练集上AUC为0.75, 验证集0.7, 测试集0.68. 对比之下, 肯定是后者更好.</p>
<p>也就是说, 通过对比不同数据集之间评估指标的差异, 可以对是否过拟合做出一定的判断.</p>
<p>同时, 在一些时候, 很难”刚刚好”做到所谓的不过拟合, 一定程度的轻微过拟合也是可以接受的. 或许尝试各种办法, 把训练集和验证集的评估指标变得几乎一致, 不过拟合了, 但此时可能处于欠拟合状态.</p>
</li>
<li><p>为什么会造成过拟合.</p>
<p>有很多原因可能会造成过拟合, 这里以GBDT模型为例, 来列举一些会让训练集/验证集/测试集之间评估指标差距变大的原因:</p>
<ul>
<li><p>树模型正则参数设置不合理. 在树模型中, 对结果影响较大的参数, 比如最大树深度, 当取值比较大时(例如5层), 会发生什么情况呢? 树模型会尽其所能去寻找特征与特征之间的交互, 以求优化目标函数. 但这样存在的问题是, 越深的层数, 越复杂的特征之间的交互, 其有效性可能只存在于训练集, 部分存在于验证集, 不存在于测试集. 简而言之, 模型复杂度较高, 学到了一些”假知识”.</p>
</li>
<li><p>提前停止参数设置过大. 除了最大树深度, 对于GBDT而言, 树的棵树也是很重要的参数. 而提前停止这一方法, 可以较好的寻找最佳树的棵树. 但是, 当此参数设置过大时, 也会造成过拟合的情况. </p>
<p>比如原本学到某个树的棵树时, 已经比较合适了. 而由于提前停止设置过大, 只要验证集在某一刻变好一点, 就会继续增加树木棵树, 训练集上评估指标会一直变好, 验证集上评估指标会发生波动. 训练集与验证集上的评估指标差距拉大, 造成过拟合.</p>
</li>
<li><p>有一些”噪音”特征也会造成过拟合. 比如GBDT在训练的时候, 有一些原本对问题没有真正贡献, 但在”偶然”的情况下, 参与了学习. 其带来的效果是会抬高模型在训练集的评估指标, 但通常在验证集与测试集上都会降低评估指标.</p>
<p>若结合验证集使用提前停止方法, 那模型可能学一些冗余的规则, 来抵消掉”噪音”特征带来的降低的效果. 最终结果, 相比没有”噪音”特征造成过拟合的情况, 可能是训练集上评估指标很高, 验证集差距不大, 测试集评估指标较低Σ(っ °Д °;)っ 因为除了”噪音”特征, 那些冗余的规则对于测试集来说可能也会带来反效果.</p>
</li>
</ul>
</li>
<li><p>如何应对过拟合.</p>
<p>针对不同的场景不同的模型, 有不同的应对过拟合的方法, 这里针对上面提到的一些可能造成过拟合原因, 列出一些方法.</p>
<ul>
<li>尽可能尝试相对简单的模型结构φ(≧ω≦*)♪, 本着能简单绝不复杂的态度. 比如在超参数选择的时候, 两组超参数对应的验证集上评估指标差距很小, 那优先选择更简单(如最大深度更小)的那一组超参数.</li>
<li>同样, 在不影响验证集评估指标的情况下, 适当调低提前停止参数.</li>
<li>对于”噪音”特征, 在之前的篇章&lt;特征选择&gt;中, 有一些方法可以一定程度上进行处理(๑•̀ㅂ•́)و✧</li>
</ul>
</li>
</ul>
<h1 id="模型解释性"><a href="#模型解释性" class="headerlink" title="模型解释性"></a>模型解释性</h1><p>在一些场景下, 我们需要尽可能地确保模型的解释性.</p>
<p>那什么是模型的解释性呢? </p>
<p>首先是入模特征的解释性, 即对某个特征, 是否了解其含义, 其分布是否符合经验认知. 举个栗子, 有个特征是”性别”, 含义是很清晰的(&gt;▽&lt;) 假设标签是”是否爱玩游戏”, 经过分析发现, 性别为女的爱玩游戏的概率更大(=′ー`) 这时候好像和我们的认知有那么点冲突, 可以进一步分析, 这里的”游戏”是&lt;英雄联盟&gt;, 还是&lt;奇迹暖暖&gt; ヽ(✿ﾟ▽ﾟ)ノ</p>
<p>然后是模型学成啥样了. 要想知道模型学成啥样了, 最直观的模型莫过于线性模型. 对于线性模型来说, 我们可以知道它各个特征系数的大小, 是正还是负, 很好理解. 然后是决策树一类的模型, 虽然层数多了以后比较复杂, 但是仍然有明了的结构. 而更复杂的模型, 如GBDT, 神经网络等, 想像线性模型一样, 直接观察其参数去估计模型学成啥样了, 是不现实的.</p>
<p>那有没有方法对复杂的模型, 也能够从模型解释性的角度对其进行分析呢? 当然是可以的, 其实模型解释性是一个专门的方向, 一直以来人们提出了很多的方法. 这里着重介绍两种方法.</p>
<ul>
<li><p>PDP(Partial Dependence Plot).</p>
<p>具体的做法, 就是对于训练好的模型, 对某一个特征, 每次只取一个值, 将该特征的全部样本都赋予这个值, 然后利用模型进行预测, 对预测得到的分数取平均, 得到一个(特征值, 平均分数). 多次操作后, 可以得到多组这样的值, 将他们画到一幅图上, 可以观察到随着该特征的变化, 会对模型产生怎样的影响.</p>
<p>仍然以上文中的”性别”为例, 假设0代表女, 1代表男, 并且性别男在统计上更爱玩游戏. 那么通过PDP得到的结果, 可能也是性别为1时, 模型分均值更高(表示更爱玩游戏). </p>
<p>但是也有可能PDP给出相反的情况, 此时不要惊慌φ(≧ω≦*)♪ 造成这中情况的原因有多种. 比如过拟合; 有其它特征与”性别”强相关; 或者在树模型中, 经过一些分割后的样本中, 就是呈现这种模式. 而要应对这种情况, 也有不同的方法, 一般来说, 如果这样的特征重要性靠后, 可以考虑不管; 如果特征重要性靠前, 同时有着强烈的先验知识作为支撑, 在GBDT中可以用”单调性限制”进行强行扭转; 实在看不惯, 且对模型整体没啥影响的话, 也可以删除该特征(。・∀・)ノ</p>
</li>
<li><p>Shap.</p>
<p>这里有个GitHub的仓库<a href="https://github.com/slundberg/shap" target="_blank" rel="noopener">Shap</a>, 快一万收藏了. 关于Shap的原理以及应用实例, 以后应该会单独进行介绍, 这里进行简单说明.</p>
<p>相比PDP, Shap可以进行更加细粒度的分析. 比如对于某个样本, 模型最后给到了一个比较高的预测值, 那么各个特征对其起到了怎样的作用呢? Shap可以将每个特征, 用线性加权的方式连接起来, 得到最后的模型预测值, 类似线性模型那样(每个样本对应一个线性模型), 通过观察每个特征的系数, 可以知道每个特征在每个样本中,起到了怎样的作用, 是大还是小, 是正向还是负向.</p>
</li>
</ul>
<p>总之, 模型解释性可以让我们增加对模型的认识和理解, 若模型效果不错, 也在解释性上没有明细不足, 那这样将给予我们信心把模型应用到生产实践中.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据建模-特征选择</title>
    <url>/2020/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<blockquote>
<p>有时候, 选择比努力更加重要.</p>
</blockquote>
<p>如果在前一篇中, 我还扯”特征工程不那么重要”, 那这里我会说”特征选择一直很重要”（○｀ 3′○）</p>
<p>这里我会根据自己有限的经验, 介绍一些特征选择的方法.</p>
<a id="more"></a>
<h1 id="为什么要进行特征选择"><a href="#为什么要进行特征选择" class="headerlink" title="为什么要进行特征选择"></a>为什么要进行特征选择</h1><p>特征选择有不少的好处, 主要来说有以下几点:</p>
<ul>
<li>减少特征数量, 让模型更加简单. 同样的模型效果, 一个模型用了1000个特征, 一个模型用了100个特征, 在使用的时候会选择哪个模型呢? 我想大多数人应该都会选择第二个相对简单的模型.</li>
<li>提升模型稳定性, 模型的稳定很大程度上依赖于特征的稳定, 在一个随时间变化的环境中, 模型的稳定性有时候是最重要的.</li>
<li>提升模型表现. 并不是所有特征对模型都是正向提升的, 零提升, 甚至负提升的特征也经常存在. 正因如此, 特征选择才会如此重要. 想像一下, 耗费了大量精力衍生出上千个特征, 自信满满地跑一个模型, 结果发现测试集评估指标没啥变化, 隐约…还下降了(っ*´Д`)っ这时候的心态是有点崩的, 因为衍生的特征中, 有大量零提升与少量负提升的特征.</li>
</ul>
<h1 id="特征选择的两个方面"><a href="#特征选择的两个方面" class="headerlink" title="特征选择的两个方面"></a>特征选择的两个方面</h1><p>在进一步讨论特征选择之前, 先来讨论一下数据集的划分. 在训练模型时, 一个比较科学地做法, 是首先按照OOT(out of time)的方式, 划分出测试集. 之所以这样, 是因为在实际生产环境中, 多数时候是用当前数据训练模型, 去预测未来的事情, 而为了模拟这一情况, 测试集的划分通常选择整体样本中时间段靠后的一匹样本. 然后在训练集中分离出验证集, 或者在训练集中做交叉验证, 在样本量大的时候两种方式基本等价, 这里假设是采用验证集的方式.</p>
<p>那么问题就来了, 由于时间跨度的不同, 样本数据特征的分布就很可能不同. 举个栗子, 某个在训练集上的强特征(与标签有较高的相关性), 到了测试集上变弱了. 如果不考虑这一情况, 仍旧照常训练, 后果就是模型也许在验证集上表现不错, 但是到了测试集就明显拉胯了o(TヘTo)</p>
<p>基于此, 我认为特征选择主要可以分为两个方面:</p>
<ul>
<li>特征稳定性.</li>
<li>特征有效性.</li>
</ul>
<p>下面进行具体地说明.</p>
<h1 id="特征稳定性"><a href="#特征稳定性" class="headerlink" title="特征稳定性"></a>特征稳定性</h1><p>先说稳定性, 是因为我认为应该先做特征稳定性的检验, 只有特征是相对稳定的情况下, 再评估特征的对模型的提升才有意义.</p>
<p>那么怎么评估特征的稳定性呢? 主要的思路是观察对比特征在不同的时间段上的表现是否一致. 如果看到了特征随时间的分布发生了一些变化, 有时候并不是特征本身不稳定, 而是样本本身发生了偏移. 但有些特征, 即使在样本发生偏移时, 仍能够保持较好的稳定性, 这样的特征能够确保我们的模型在未来变化的环境中, 能够长期保持较为稳定的性能.</p>
<p>具体的的做法, 有以下一些, 并不代表全部可行的做法, 也不代表一定好使(≧∇≦)ﾉ:</p>
<ul>
<li><p>PSI.</p>
<p>如果不了解PSI的同学, 可以谷歌一下, 原理很简单这里就不多说了, 计算公式如下:</p>
<script type="math/tex; mode=display">
PSI=\sum_i(A_i-E_i)\times {\rm ln}(A_i/E_i)</script><p>在多个时间段的样本上, 计算特征的PSI, 如果特征的PSI较大, 超过某阈值(一般超过0.1), 则可以考虑舍弃该特征.</p>
<p>不过我个人认为PSI指标更多说明的是样本本身的变化, 可以用来辅助判断特征的稳定性, 但如果过于依赖PSI的话可能会有问题.</p>
</li>
<li><p>基于模型验证稳定性.</p>
<p>可以在训练集上, 按时间将其分成两份数据集, 在其中一份数据集(通常选时间靠前的一份)上, 对每个特征单独进行建模, 得到交叉验证的评估, 然后在另一份数据集上进行预测评估, 对比前后评估结果是否差距过大.</p>
<p>比如在二分类问题中, 采用AUC作为评估指标, 在第一份数据集上的交叉验证结果为0.6, 第二份数据集上为0.58, 那么认为特征稳定性还不错. 而如果第一份上0.6, 第二份上0.5, 那么很明显该特征是不稳定的.</p>
</li>
<li><p>基于分箱验证稳定性.</p>
<p>这里与上面基于模型验证稳定性是比较类似的. </p>
<p>举个栗子, 在二分类问题中, 对某个特征采用等频分箱, 分成10箱. 然后按时间前后分成两部分, 在两份数据上, 分别计算出各分箱的标签均值(比如标签为是否逾期, 则表示逾期率). 然后可以将两份数据上各箱的逾期率, 以折线图的形式, 画到图上, 比较前后两份数据集上该特征的表现是否一致. 若一致则可认为稳定, 否则不稳定. 除了画图人为观察判断以外, 还可以用一些其它方法, 比如对两个分箱后的标签均值列表, 计算其相关性(皮尔森相关性较好), 通过相关性来判断特征前后表现是否一致.</p>
<p>此外, 比如当分成10箱时发现特征前后表现不一致, 可以尝试减少分箱数, 如5箱, 虽然损失了信息, 但有可能可以提高特征稳定性.</p>
</li>
<li><p>对抗验证.</p>
<p>这个方法的原理是这样的, 有时候测试集与训练集之间, 存在分布上的差异, 这个差异导致在验证集上获得的模型表现, 在测试集不成立.</p>
<p>为了定量衡量这种分布差异, 可以给训练集标签为0, 测试集标签为1, 进行二分类建模.</p>
<p>建模后, 可以观察模型的AUC, 如果训练集与测试集同分布, 且模型训练得当, 则AUC一定在0.5附近. 若AUC比较大比如0.6, 则说明两者的分布是不一致的.</p>
<p>若AUC较大时, 原本对抗验证的处理方法, 是将训练集中, 模型预测值最低(与测试集分布差异最大)的一批样本删除. 而在一些时候样本是比较珍贵的, 可以先根据模型得到的特征重要性, 找到模型认为对分布差异贡献最大的一些特征, 可以考虑删除这些特征, 来使训练集与测试集分布趋于一致.</p>
</li>
</ul>
<p>以上提到的一些方法, 在进行特征选择时, 可以结合起来使用, 这样能够从多个不同的维度去筛选出稳定的特征, 为后续进一步筛选特征做准备.</p>
<h1 id="特征有效性"><a href="#特征有效性" class="headerlink" title="特征有效性"></a>特征有效性</h1><p>现在假设特征的稳定性已经较好了, 此时一般来说有一个现象, 就是在验证集上获得的模型表现, 在测试集上也能用于近似的结果.</p>
<p>那么进一步, 要在这些特征的中挑选出能够让模型学习得最好的那一组特征. 举个栗子, 就好比一个学生要考试了, 摆在他面前的有一大堆学习资料, 如果其中掺杂了一些不好的资料, 那么不但会耽误学生学习其它优秀的资料, 而且可能还会形成误导.</p>
<p>筛选特征的方法有很多, 我这里列举一些比较常用的做法.</p>
<h2 id="基于简单统计信息"><a href="#基于简单统计信息" class="headerlink" title="基于简单统计信息"></a>基于简单统计信息</h2><p>比如基于特征的缺失率, 当一个特征的缺失率高达95%时, 也许对当前模型表现还有那么一丢丢贡献, 但是实际生产环境中这样的特征更倾向于舍弃.</p>
<p>同理, 特征中的某个数值, 占据了绝大部分比例, 比如0占了98%, 那么这样的特征在一些情况下也是可以考虑直接删除的.</p>
<h2 id="基于相关性"><a href="#基于相关性" class="headerlink" title="基于相关性"></a>基于相关性</h2><p>在一般的分类, 回归问题中, 可以进行特征与标签的相关性评估.</p>
<p>常用的相关性有以下一些:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">相关性指标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">连续 &amp; 连续</td>
<td style="text-align:center">皮尔森, 斯皮尔曼</td>
</tr>
<tr>
<td style="text-align:center">连续 &amp; 离散</td>
<td style="text-align:center">方差分析</td>
</tr>
<tr>
<td style="text-align:center">离散 &amp; 离散</td>
<td style="text-align:center">互信息</td>
</tr>
</tbody>
</table>
</div>
<p>基于统计相关性来进行评估特征, 优点是很快, 在一些场景下需要用到线性模型, 或者特征里有很多强特征时, 是个还不错的方法. 但缺点是有时候不能较好地评估非线性相关的特征, 比如皮尔森相关性.</p>
<p>因此, 在使用相关性来评估特征时, 要结合具体场景进行谨慎考虑.</p>
<h2 id="L1正则"><a href="#L1正则" class="headerlink" title="L1正则"></a>L1正则</h2><p>利用含有L1正则的线性模型来挑选特征, 根据不同的正则系数, 会将不同数量的特征的系数变成0.</p>
<p>选择合适的正则系数, 可以较快地在大量特征中选择出一组较好的特征.</p>
<p>不过由于是基于线性模型进行选择, 所以如果原本特征中, 存在一些与标签关系为非线性的特征, 可能也会被当做无用特征, 系数变为0.</p>
<h2 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h2><p>此方法的核心思想是, 先利用一些方法, 对特征的重要性进行排序, 然后根据排序保留靠前的特征, 舍弃靠后的特征.</p>
<p>常用的衡量特征重要性的方法有以下一些:</p>
<ul>
<li>直接基于树模型衡量特征重要性. 比如在GBDT模型中, 可以根据某特征被分割次数, 或者提供的信息增益衡量其重要性.</li>
<li>基于随机排列衡量特征重要性. 这一类方法的主要思想是, 一个特征原本有一个重要性, 而在另外一种情况下(比如将该特征随机排列), 又得到一个重要性, 通过对比前后两个重要性, 来判断该特征是否有效.<ul>
<li>Null Importance: 此方法是保持特征不变, 随机排列标签, 来对比前后特征重要性的变化. 若前后特征重要性变化大, 则说明该特征是真实有效的; 若特征重要性前后几乎差不多, 甚至还提高了o(*≧▽≦)ツ┏━┓那这个特征极大可能是噪音.</li>
<li>Eli5: 这里叫做这个名称, 是因为在一个叫<code>eli5</code>的包中有实现这种方法~此方法是在训练集上正常训练, 然后在验证集上预测时计算评估指标(如AUC), 不过考虑两种情况, 一种是真实的特征, 一种是对某个特征进行随机排列, 对比前后评估指标的变化. 同样若前后差距较大, 则说明该特征是重要的.</li>
<li>Boruta: 此方法是通过在训练时, 把原本的所有特征复制一份, 比如原本的10个特征变成20个特征. 然后对复制的所有特征进行随机排列. 接下来多次训练模型, 在每次训练模型后, 整体考虑真实特征与影子(随机排列)特征的重要性, 将不合格的特征逐一去除, 保留最后较好的一组特征.</li>
</ul>
</li>
<li>Shap. 此方法原本是用于模型解释性的, 但是其同样可以输出特征重要性的评估. 这里不细讲, 以后应该会单独介绍.</li>
</ul>
<p>而在获得了各个特征的重要性后, 一般来说, 有两种处理方式:</p>
<ul>
<li><p>直接按某阈值切分, 按比例保留一部分高重要性特征, 舍弃其余低重要性特征. 在考虑切分阈值时, 可以画出按重要性排序后, 重要性的累计图, 找到累计重要性变化较小的地方(即剩下特征对整体贡献很小), 作为阈值.</p>
</li>
<li><p>RFE(recursive feature elimination), 即不使用重要性进行一刀切, 而是逐步地剔除重要性较小的特征. 比如原本100个特征, 每次训练模型后, 剔除当前重要性最小的5个特征, 同时记录当前模型在验证集或者交叉验证上的表现.</p>
<p>在最后停止时, 会得到在不同数量特征组合下, 模型的表现, 此时可以选择其中表现最好的特征组合. 也可以缩小范围, 比如发现在30~40特征数量上表现不错, 那在这个区间每次只剔除重要性最小的特征, 进行细致地搜索.</p>
</li>
</ul>
<p>一般来说, RFE效果不错, 且耗费计算资源在可接受范围内, 是一种较好的方法.</p>
<h2 id="逐步法"><a href="#逐步法" class="headerlink" title="逐步法"></a>逐步法</h2><p>逐步法的核心思想是, 从一组初始特征开始, 逐渐加入或者逐渐舍弃特征. 在每次加入或者舍弃时, 一般需要所有可能进行建模比较效果, 选择最优的情况.</p>
<ul>
<li><p>前向法.</p>
<p>从指定特征或者0特征开始, 每次对原特征加上其它某一个特征进行建模, 遍历一遍后, 将表现最好的特征加入, 再进行下一轮循环. 直到达到停止条件, 如指定最大特征数量, 或者评估指标不再上升.</p>
</li>
<li><p>后向法.</p>
<p>与前向法相反, 从全部特征开始, 每次考虑剔除一个特征, 遍历后剔除那个剔除后让模型效果提升最大的特征. 直到达到最小特征数量, 或者评估指标不再上升.</p>
</li>
<li><p>前向后向法.</p>
<p>结合前向法与后向法, 比如先用前向法, 当评估指标不再上升后, 再使用后向法, 如此循环.</p>
</li>
</ul>
<p>逐步法的好处是也许可能找到一组非常好的特征, 但是缺点也很明显, 算法时间复杂度很高, 当特征很多, 且模型较为需要较多训练时间(如GBDT)时, 会显得很慢. 可以在特征不是很多, 且使用线性模型这样训练速度较快的模型时使用.</p>
<h2 id="搜索法"><a href="#搜索法" class="headerlink" title="搜索法"></a>搜索法</h2><p>考虑到特征选择其实是一件玄学的事情, 所以为什么不用玄学对抗玄学呢(≧∇≦)ﾉ</p>
<ul>
<li><p>暴力搜索法.</p>
<p>遍历所有可能的特征组合. 如果算力够的话, 也不失为一种办法…</p>
</li>
<li><p>随机搜索法.</p>
<p>每次随机抽取一部分特征, 相比暴力搜索法, 更加可控一些, 可以指定搜索次数, 防止程序一直跑下去.</p>
</li>
<li><p>启发式搜索法.</p>
<p>使用一些启发式算法来优化搜索过程. 比如基因算法, 每个特征是否在当前组合中出现, 可以看出是一组基因序列, 1即出现, 0即不出现.</p>
<p>在某一代的组群中, 表现较好的特征组合用于更多的机会进行交叉组合与变异.</p>
<p>通过这样的方式, 既可以避免暴力搜索的超高复杂度, 也可以尽量避免随机搜索进行的无效搜索.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据建模-特征工程</title>
    <url>/2020/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>也许有一些刚开始接触传统机器学习相关算法, 在学习建模的时候, 会觉得除了算法本身外, <strong>特征工程</strong>是最重要的, 能够化腐朽为神奇, 能够让自己打比赛拿第一ヾ(≧▽≦*)o</p>
<p>比赛能不能拿好成绩我不知道, 也许通过一些特征工程手法, 在最后提升了几个千分点从而击败其他选手. 但是, 特征工程并没有那么重要, 且不说深度学习, 在传统机器学习里, <strong>数据本身的质量决定了模型的性能</strong>.</p>
<blockquote>
<p>数据决定了上限, 我们做的其他事情只是在逼近这个上限而已.</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是特征工程"><a href="#什么是特征工程" class="headerlink" title="什么是特征工程"></a>什么是特征工程</h1><p>特征工程没有太过明确的定义, 在结构化数据的范畴中, 如下一些操作可以算进特征工程</p>
<ul>
<li><p>特征预处理.</p>
<p>一般来说, 采取不同的模型, 根据模型的特点, 对特征做一些适当的操作, 可以明显提升模型效果.</p>
</li>
<li><p>特征提取/衍生.</p>
<p>原本的一些特征可能无法很好地表达信息, 而在经过一些如特征提取, 特征组合(两两相乘)得到新特征后, 可以让模型学得更好.</p>
</li>
</ul>
<p>在后续的内容中, 会进行更加详细的叙述.</p>
<h1 id="不那么重要的特征工程"><a href="#不那么重要的特征工程" class="headerlink" title="不那么重要的特征工程"></a>不那么重要的特征工程</h1><p>如一开始所说, 特征工程不那么重要, 这里就来说明为啥不那么重要.</p>
<ul>
<li><p>现在的一些”高级”模型, 可以更好地捕获数据信息</p>
<p>同样一份数据, 同样基于决策树的模型, 单棵决策树, 随机森林, GBDT系列(如XGB, LGB), 建模得到的效果经常是有明显差异的, 通常是GBDT系列的模型效果最好.</p>
<p>因为GBDT模型有更高的复杂度, 同时学习到了更多有效的信息(不过拟合的情况下).</p>
</li>
<li><p>在有些时候, 特征工程前后提升较小.</p>
<p>特征工程的效果, 有时候还得数据”配合”. 更通俗一点, 数据越原始, 特征工程的空间也就越大, 提升空间也越大.</p>
<p>比如手里的数据是一些日志记录, 需要先经过清洗整理为结构化信息, 然后发掘其中更有效的特征, 提升模型效果, 这时候往往相比刚清洗好的特征, 经过进一步处理的特征会更好地提升模型效果.</p>
<p>还有一些时候, 拿到的数据是已经经过别人精心设计处理过后的, 此时再做更多的尝试, 收效甚微.</p>
</li>
<li><p>过于复杂的特征工程, 不利于实际生产环境部署.</p>
<p>举个栗子, 一个原本只有一百个特征的数据集, 经过一顿操作, 衍生出了各种各样的特征, 变成了几千个特征, 但是带来的收益呢, 经常是不成正比的.</p>
<p>而在实际生产环境中, 有些时候甚至不会那么在意那一点点模型效果的差距, 一个简单的模型的优先级会高于一个过于复杂的模型.</p>
</li>
</ul>
<h1 id="重要的特征工程"><a href="#重要的特征工程" class="headerlink" title="重要的特征工程"></a>重要的特征工程</h1><p>喂前面才说特征工程不重要, 为什么这里又要说它重要呢(＠￣ー￣＠)</p>
<p>啊…这…因为确实重要呀ヾ(≧▽≦*)o</p>
<ul>
<li><p>即使是”高级模型”, 特征工程也能够带来显著提升.</p>
<p>诚然”高级模型”一些时候更加能够捕获数据信息, 但是一些实际的经验显示, 有时候也许就是那么一个衍生特征的差别(如两个特征相除), 前后模型评估指标就有显著差距(如AUC相差2个百分点).</p>
</li>
<li><p>对一些”不太友好”的数据, 合适的特征工程非常重要.</p>
<p>比如原始数据是一些短文本, 需要将其转换成结构化数据; 如原始数据非常稀疏, 能不能变得稠密一些? 原始数据中有大量高基数的类别特征, 怎么处理好一些?</p>
<p>此时好的特征工程方法, 确实可以带来不一样的表现.</p>
</li>
<li><p>对不同模型, 采取不同的方法.</p>
<p>如果是一些基于决策树的模型, 那其实可以省事很多, 有时候甚至可以不做啥处理.</p>
<p>而另外一些模型, 比如线性模型, 神经网络, KNN等, 需要了解模型特性, 进而选择对应合适的方法处理数据. 正确的处理方法相比不正确的处理方法, 差异很大.</p>
</li>
</ul>
<h1 id="一些常见的特征工程方法"><a href="#一些常见的特征工程方法" class="headerlink" title="一些常见的特征工程方法"></a>一些常见的特征工程方法</h1><p>在进行特征工程前, 做好EDA是很有好处了, 通过在数据分析时获得的信息, 再加上我们的脑洞, 也许可以创造出所谓的”魔法特征”哟~</p>
<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p>常见的标准化方式, 是将特征转变到以0为均值, 1为标准差的分布上. 或者可以更进一步实施BOXCOX, 将分布尽量转化为正态分布.</p>
<p>一般来说, 哪些模型需要做标准化呢? 总体说来有两类:</p>
<ul>
<li>基于点与点(样本与样本)之间的距离. 比如KNN, SVM等.</li>
<li>依赖类似梯度下降法训练的模型. 比如线性回归, 神经网络等.</li>
</ul>
<p>在合适的时候标准化, 可以加速模型训练, 同时获得更好的模型效果.</p>
<h2 id="缺失值填充"><a href="#缺失值填充" class="headerlink" title="缺失值填充"></a>缺失值填充</h2><p>通常, 一些模型如线性回归, 必须要进行缺失值填充. 基于决策树的模型可以不进行缺失值填充, 但是同样可以进行尝试, 因为也许在一些情况下可以让模型学习得更好.</p>
<p>一般在缺失值填充时, 还可以考虑是否生成额外的缺失值指示列, 即用于表明原本某个特征是否缺失(如1表示缺失, 0表示未缺失).</p>
<p>常用的缺失值填充方式有以下一些:</p>
<ul>
<li><p>固定值填充.</p>
<p>这个比较无脑, 比如用0这样的值来对缺失值进行填充. 但这种方法在多数情况下不是很好.</p>
</li>
<li><p>统计值填充.</p>
<p>对于连续型特征, 可以考虑用均值, 中位数进行填充; 对于离散型特征, 可以考虑用中位数, 众数进行填充.</p>
</li>
<li><p>结合标签信息填充.</p>
<p>比如在二分类问题中, 标签为某个样本是否发生逾期, 那么对某一个特征, 可以计算其缺失部分的逾期率.</p>
<p>对非缺失部分, 进行分箱(通常等频分箱更好), 计算每箱的逾期率.</p>
<p>用缺失部分的逾期率与非缺失部分的每箱进行对比, 选择逾期率最接近的那一箱的特征统计值(如均值)来填充缺失值.</p>
<p>这个方法个人觉得在一些特征为强特征时可以使用, 所谓强特征, 即特征与标签高相关. 而在一些时候, 可能会有一定的过拟合风险.</p>
</li>
<li><p>利用其它特征.</p>
<p>如果处理过经典的泰坦尼克数据集的同学, 应该看到过用每个人的称谓来估计他们缺失年龄的做法, 这就是一个非常典型的利用其它特征来进行缺失值填充的例子.</p>
<p>如果利用模型来进行填充, 总体思路是使用半监督学习的做法. 即对于某个特征, 将其非缺失部分作为标签, 结合其它对应的特征来训练模型, 然后对其缺失部分数据进行预测.</p>
<p>比较简单的做法, 是一个特征构建一个模型, 比如使用KNN(需要做一些额外操作来应对其它特征的缺失值).</p>
<p>复杂一些的方法, 是循环构建模型:</p>
<ol>
<li>确定所选模型(如随机森林), 对特征按一定顺序进行排序.</li>
<li>按顺序对每个特征进行学习. 把目标特征外的特征, 按统计值(如均值)进行填充, 对于已经学习过的特征使用模型预测值填充. 以目标特征为标签, 训练模型.</li>
<li>可以多次循环第2步. 比如总共有10个特征, 遍历3轮, 则最终可以得到30个模型(每个特征对应3个模型).</li>
<li>在<code>transform</code>时, 会按照和<code>fit</code>时同样的方法和顺序进行填充.</li>
</ol>
<p>这个方法的优点是填充值充分利用到了其它特征的信息, 缺点是无论是训练还是预测填充的过程, 都比较慢, 在一些需要快响应的场景中不适合.</p>
</li>
</ul>
<h2 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h2><p>对于异常值, 这里暂时只考虑单个特征分布上的异常, 不考虑其它一些例如”异常检测”中所指的异常. 具体说来就是某个特征上, 少数样本的值严重偏离整体分布的异常值.</p>
<p>在处理异常值之前, 先要找出异常值, 连续数值型特征以及回归问题中的标签都可能存在这样的异常值. 可以利用箱线图的原理来确定异常值; 也可以设定一个边界占比阈值如1%, 将最大的1%与最小的1%样本当做异常值.</p>
<p>确定异常值后, 一般来说有两种比较简单的处理方式:</p>
<ul>
<li>若异常值样本较少, 则可以考虑直接删除.</li>
<li>可以设定一个最大最小数值, 将超出该阈值的异常值变成该数值.</li>
</ul>
<p>异常值处理的意义, 是可以让模型学习得更好, 同时预测的结果更加客观真实.</p>
<p>举个栗子, 有一个线性回归模型, 有5个特征. 当某个样本中, 第1个特征中出现了一个特别大的值, 此时最终的预测值将会几乎完全被第1个特征决定, 这样的预测结果的可信度就会降低.</p>
<h2 id="类别特征编码"><a href="#类别特征编码" class="headerlink" title="类别特征编码"></a>类别特征编码</h2><p>对于几乎所有的机器学习算法来说, 只能接受数值型特征, 所以一些字符型的特征, 需要先进行数值编码才行. 并且, 即便是数值型的特征, 但是本质上仍然是类别特征(如月份), 那么仍然可以尝试不同的类别特征编码方法, 来提高模型的表现.</p>
<p>常见的类别特征编码方法有以下一些:</p>
<ul>
<li><p>直接编码.</p>
<p>这个方法简单粗暴, 就是将每个类别对应到一个整数上, 对应的方式一般是随机的. </p>
<p>如果类别特征较少, 类别特征内的类别数量也少(如3个), 只是想随便跑一个baseline模型, 可以一试, 但若想要更好的模型表现, 这样的编码是不行的.</p>
</li>
<li><p>独热编码.</p>
<p>独热编码是非常经典的类别特征编码方法, 将特征的每个类别变成一列bool型特征, 表示是否是该类别.</p>
<p>一般说来, 独热编码能够让模型学习到不错的表现.</p>
<p>要说缺点, 那就是当类别特征较多, 且特征内类别过多时, 可能会产生大量的列, 这对于数据的保存于训练都不友好. 当然可以做一些优化, 比如将一些占比较少的类别合并为一类, 或者设定最大类别数等.</p>
</li>
<li><p>频率编码.</p>
<p>即按类别的出现频率进行编码, 让模型知道哪些类别出现几率更高, 是否与标签相关.</p>
<p>这个方法感觉更偏向于特征衍生, 可以在其它类别特征编码基础上, 附加此编码方法得到更多特征.</p>
</li>
<li><p>哈希编码.</p>
<p>哈希编码的方法可能更多用于文本编码上, 但也可以用在类别特征编码上. 其原理是运用哈希函数, 将原本的特征向量(行), 转变为其它的数值向量. 可以预设转换后的向量长度, 既可以扩展原本的长度, 也可以进行降维.</p>
<p>哈希编码在一些情况下有较好的效果. 不过由于其特性, 会把一些不同的特征, 编码成同样的向量. 并且编码后, 解释性变差(每一列不再清楚含义).</p>
</li>
<li><p>标签编码.</p>
<p>标签编码是我个人比较喜欢的一种编码方式. 其核心思想是, 结合标签的信息来对类别特征进行编码, 例如对于特征的每一类, 编码为该类下标签的均值.</p>
<p>但此方法由于直接利用到了标签信息, 所以相比前面的方法, 容易引起过拟合. 为了防止或者减轻过拟合, 有不少改良版本. 比如其中一种改良方法为, 编码值为先验值与标签均值的加权平均:</p>
<script type="math/tex; mode=display">
编码值_{类别i}=\alpha_{类别i} \times 全样本标签均值+(1-\alpha_{类别i})\times 标签均值_{类别i} \\
\alpha_{类别i}=1-{\rm exp}\lgroup\beta\times\frac{样本量_{类别i}}{全体样本量}\rgroup</script><p>当某个类别占据的样本量较多时, 给予较多的信任, 主要由标签均值进行编码; 而当某类别占据样本量较少时, 其编码值更多由先验值决定.</p>
<p>除了上面的方法, 还有一些方法, 比如使用交叉验证的方式, 把原数据集分成$N$份, 每次在$N-1$份上得到编码值, 将其赋予到剩下的那一份上.</p>
<p>之所以比较喜欢标签编码, 是因为一来只要注意一下过拟合的问题, 多数情况下能够让模型有不错的表现. 同时相比独热编码, 不会出现特征维度爆炸的情况.</p>
</li>
</ul>
<h2 id="连续特征分箱"><a href="#连续特征分箱" class="headerlink" title="连续特征分箱"></a>连续特征分箱</h2><p>为啥要对连续特征进行分箱呢? 对于类别特征的编码是必要的, 而连续特征的分箱在一些时候也是有用的.</p>
<p>首先列举一些常用的分箱方法:</p>
<ul>
<li><p>等距/等频分箱.</p>
<p>对于等距一般不太推荐. 等频分箱根据实际情况, 设置合适的分箱数.</p>
</li>
<li><p>决策树分箱.</p>
<p>借助决策树的叶子节点的划分, 来进行分箱.</p>
</li>
<li><p>WOE.</p>
<p>WOE这一套分箱与编码的方法, 算是分箱中的佼佼者了. 在线性模型中用得比较多.</p>
</li>
</ul>
<p>然后说一下连续特征分箱的一些用途:</p>
<ul>
<li><p>提升特征稳定性.</p>
<p>分箱某种程度上, 会损失特征的一些信息, 但是却可以提高稳定性, 让模型现在学到的规则, 将来也一样适用.</p>
</li>
<li><p>将非线性转变为线性.</p>
<p>比如在使用线性模型时, 如果特征与标签之间不是线性相关的, 而是比如U型的关系, 那么经过分箱编码(如WOE)后, 可以与标签拥有线性相关性, 可以很好地学习.</p>
</li>
<li><p>免除异常值影响.</p>
<p>经过分箱, 异常值同样也会被分到某一箱中, 与该箱中其它样本无异, 相当于顺便做了异常值处理.</p>
</li>
</ul>
<h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p>由于重点是讲结构化数据的范畴, 所以这里不做过多讲解. 其核心思想是把原本的非结构化数据, 或者稀疏的数据转换成相对稠密的结构化数据.</p>
<p>比如对于文本, 图片音频等数据, 可以利用深度学习的方法, 采用有监督或者无监督的方式, 将原始数据表示为结构化的向量数据. 对于稀疏的数据, 同样使用一些方法如PCA, 或者自编码器等进行降维.</p>
<p>这里再说一下为啥稀疏数据要特殊对待. 因为一般来说稀疏数据, 往往伴随着高纬度特征(如上万维), 此时无论是一些模型, 还是对计算资源来说, 都是一项困难的事情. 此时要么考虑将其降维后再用模型进行学习, 要么直接使用一些能够应对稀疏数据的模型, 如线性模型.</p>
<h2 id="特征衍生"><a href="#特征衍生" class="headerlink" title="特征衍生"></a>特征衍生</h2><p>说实话, 特征衍生是玄学(≧∇≦)ﾉ</p>
<p>为啥说是玄学呢? 因为你不知道你衍生的特征, 对于模型是否有提升…</p>
<p>甚至有时候, 可能还有神奇的负提升o(TヘTo)</p>
<p>所以应该怎么办呢? 我认为一个比较好的做法是, 先尽量地进行特征衍生, 然后再依赖各种特征选择的方法, 来去其糟泊, 留其精华.</p>
<p>总体来说, 特征衍生可以分为两种方法:</p>
<ul>
<li><p>按业务理解进行衍生.</p>
<p>即首先了解各个字段的含义, 然后根据自己的理解与猜想, 去构建新的特征. 具体说来有如下:</p>
<ul>
<li>特征直接相互组合(如两两相乘, 两两相除等), 这样得到的特征有时候可以与目标变量之前存在更强的相关性.</li>
<li>构建统计量特征. 比如一些时候, 一条样本对应多条历史数据, 那么根据这些历史数据, 就可以设定不同的时间窗口, 使用不同的统计量得到不同的特征.</li>
</ul>
</li>
<li><p>暴力衍生特征.</p>
<p>暴力衍生特征的思想是, 既然我不知道什么样的衍生特征可能对模型有提升, 那我把所有情况下的衍生特征都构建出来不就行了吗(&gt;▽&lt;)</p>
<p>此外, 在一些特殊情况下, 不知道原始特征的字段含义, 或者即使知道含义但没有领域知识时, 暴力衍生是一个不错的办法.</p>
<p>比如构建基于两两相乘的衍生特征, 若原始特征为10个, 则对应的衍生特征为45个. 当特征很多的时候, 需要谨慎使用, 不然可能会内存不够(≧∇≦)ﾉ</p>
<p>在原始特征比较多, 例如上千个的时候, 一种折中的暴力衍生策略, 是先利用一些方式进行评估(如树模型的特征重要性), 然后根据评估结果, 将重要的部分特征进行衍生.</p>
<p>除了上面按业务理解进行衍生的形式, 还可以对类别特征进行组合/拆分; 基于某特征做分组, 计算其它特征在分组上的统计值(如均值)等.</p>
</li>
</ul>
<p>此外, 还有根据决策树, 符号学习等方法来寻找高阶(两个以上)组合特征的方法, 也可以进行尝试.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们不能迷信特征工程, 企图利用各种花里胡哨的操作, 在一份辣鸡数据集上玩出花.</p>
<p>但我们要重视特征工程, 掌握一些基本的处理方式, 应对各种情况.</p>
<p>哦还有一点, 特征工程有时候是需要想象力的, 需要一些脑洞, 一些天马行空.</p>
<p>尝试, 验证, 尝试, 验证…正所谓实践出真知. 而在不停的实践中, 也要注意经验的积累, 使得在以后的实践中, 能够尽量减少不必要的尝试, 能用更少的时间, 做出更好的模型.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据建模-数据清洗</title>
    <url>/2020/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/</url>
    <content><![CDATA[<p>关于数据清洗, 若拿到手的是已经整理好的结构化数据, 是非常轻松且简单的; 而若是拿到了比较原始的, 杂乱的数据, 那可能要在这一步耗费不少时间. 总体来说, 数据清洗是简单的, 可能繁琐的, 但也是很重要的一步.</p>
<a id="more"></a>
<h1 id="整理数据"><a href="#整理数据" class="headerlink" title="整理数据"></a>整理数据</h1><p>这里主要以平时用到的最多的表格型数据来说, 使用<code>Pytohn</code>的<code>pandas</code>包, 可以进行有效地处理.</p>
<p>若原文件时<code>excel</code>或者<code>csv</code>等格式, 则直接读取即可; 若原文件是<code>json</code>这样的格式或类似的格式, 一般是先将其转变为标准的形式, 然后利用如<code>pd.read_json(string)</code>的方式进行读取.</p>
<p>我们要明确, 一份数据中, 哪些是<strong>ID相关特征</strong>, 这些特征可用于多份数据之间的关联, 但对于分析以及建模来说, 就没有额外帮助了. 同时, 还有一些<strong>基础信息特征</strong>, 如日期等, 这些可以用来分析数据, 也可以考虑参与建模. 这两大类的特征, 一般来说有一个特点, 即100%的覆盖率, 没有缺失.</p>
<p>除开以上两类特征, 总体来说还剩下<strong>标签列</strong>和<strong>建模特征</strong>. 标签列不必多说, 对于监督学习来说是必要的. 对于建模特征, 如果按数据类型来进行一些细分的话, 大致可以包含以下一些形式:</p>
<ul>
<li>无序类别特征.</li>
<li>有序类别特征.</li>
<li>离散数值特征.</li>
<li>连续数值特征.</li>
<li>日期时间特征.</li>
</ul>
<p>对于类别特征, 原始数据大概率是<code>object</code>或者<code>string</code>形式, 考虑到后续入模需要数值型特征, 一种简单的方式, 就是将类别型特征直接进行数值编码, 从字符串映射到整数. 但是这种方式, 除非该类别特征属性的数量很少(比如5个以下), 否则不太适合直接入模. 关于类别特征编码, 我准备在<strong>特征工程</strong>篇章详细叙述.</p>
<p>对于日期时间类的特征, 在整理数据时, 将其整理成统一的格式即可(如<code>%Y-%m-%D %H:%M:%S</code>), 可用于后续分析之用. 若要作为入模特征, 需要考虑<code>特征抽取</code>的方式, 同样也会在<strong>特征工程</strong>篇章说明.</p>
<p>此外, 对于<strong>缺失值</strong>的处理也是非常重要的. 不同的原始数据, 对缺失值的表示是不一样的. 常见的缺失值表示方式可能有:</p>
<ul>
<li>空值.</li>
<li>null, NaN等字符串.</li>
<li>-9999999等特殊数值.</li>
</ul>
<p>同时有些时候一份数据是由多份数据拼接而成, 其中可能有多种缺失值的表示, 要留意一下. 处理的方式, 一般来说统一转化成<code>pandas</code>默认的缺失形式就行.</p>
<h1 id="了解数据"><a href="#了解数据" class="headerlink" title="了解数据"></a>了解数据</h1><p>虽然有别于专门的数据分析, 最终目的是为了建模, 但是早期的对数据尽可能地了解, 是对后续的一些工作有帮助的, 并且可能指导后续的一些尝试和方向, 这个过程一般也可以被称为<strong>EDA</strong>(Exploratory Data Analysis).</p>
<p>我们可以查看以及了解的东西有哪些呢?</p>
<ul>
<li><p>数据集有多少样本, 多少列.</p>
</li>
<li><p>样本集随时间的分布, 即各个时间段的样本数量.</p>
</li>
<li><p>特征中有多少类别特征, 数值特征, 日期…</p>
</li>
<li><p>特征是否具有可解释性(知道特征含义), 是刻画什么维度的数据.</p>
</li>
<li><p>各特征的覆盖率.</p>
<script type="math/tex; mode=display">
覆盖率=1-缺失率</script></li>
<li><p>标签列的分布(如均值).</p>
</li>
<li><p>标签列在各个组群(如类别特征)上的分布.</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>这里推荐一个可以辅助进行EDA的包<code>Pandas Profiling</code>, 其GitHub地址<a href="https://github.com/pandas-profiling/pandas-profiling" target="_blank" rel="noopener">在这里</a>. 这个包可以用一两行命令, 展示出数据集中各个特征的多种统计信息, 也包括特征之间的相关性, 使用后会生成一个html文档. 建议没有使用过的同学尝试一下~</p>
<p>通过对数据进行EDA, 可以了解手里这份数据整体的内容, 可以据此来制定一些尝试. </p>
<p>比如发现数据随时间分布有较长的跨度, 可以样本按时间切分, 查看前后样本的一些差异. </p>
<p>比如发现部分特征覆盖率极低(低于10%), 可以考虑在建模前, 直接先删除这部分特征. </p>
<p>比如根据业务理解, 认为某些特征的组合(如两两相除)可以表示更强的信息, 则可据此衍生特征. </p>
<p>比如发现标签列分布不均匀(如1多0少), 此时可以考虑对0进行上采样, 或者增加样本权重等方式</p>
<p>……</p>
<p>总之, 数据清洗这一步, 慢慢做就好了, 将原始数据进行统一化的整理, 并进行查看与分析, 为后续建模做一个良好的开端.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据建模-样本设计</title>
    <url>/2020/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E6%A0%B7%E6%9C%AC%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>一般在一些数据挖掘比赛中, 比赛的样本, 样本的特征, 标签啥的, 都是比赛方提供的. 作为参赛者, 大部分时候不需要准备额外的数据, 充分利用给定的数据就行.</p>
<p>但是在实际生产环境中, 通常是由自己, 或者一个小团体, 针对某个问题来做样本设计. 那么什么是<strong>样本设计</strong>呢, 其实就是反过来, <strong>设计样本</strong>o(*≧▽≦)ツ</p>
<a id="more"></a>
<p>咳…认真点, 比如我们想通过数据, 针对某个问题进行建模, 来实现对业务的优化, 大致会有以下几种情况:</p>
<ul>
<li><p>对于每个样本(比如人), 在这个问题上, 采集哪些维度的信息(特征), 可能是有帮助的?</p>
</li>
<li><p>可以采集大量的数据进行建模, 但是每一份样本的采集是有成本的.</p>
</li>
<li><p>样本集(比如用户客群), 包含了一些群组, 但是这些群组并不均衡, 也不稳定, 应该怎么做?</p>
</li>
<li>若采用有监督算法, 标签如何定义, 可以更好地解决问题呢?</li>
</ul>
<p>针对以上一些问题, 下面逐一进行阐述.</p>
<h1 id="特征维度"><a href="#特征维度" class="headerlink" title="特征维度"></a>特征维度</h1><p>这里先举一个比较扯栗子吧, 比如我想建模预测股市大盘的涨跌, 然后通过观察历史数据, 我发现股市的涨跌尽然和小明的考试成绩呈现很高的正相关, 皮尔森相关系数高达0.6. 这好像是一个不错的特征, 可以帮助模型预测股市的变化.</p>
<p>但是真的是这样吗? 明显不是呀ヽ(✿ﾟ▽ﾟ)ノ</p>
<p>第一, 股市大盘长期来看, 是持续性增长的, 小明也许以前比较贪玩, 后来慢慢好好学习, 考试分数也上去了. 第二, 小明下次考试缺考, 股市是不是得熔断? 小明毕业了, 没有考试了, 股市是不是得关门?</p>
<p>对没错, 就是<strong>相关性 VS 因果性</strong>. 通常我们希望用于建模的特征, 是与问题本身有一定的因果性的, 这样才能够具有一定的<strong>解释性</strong>, 以及更好的<strong>稳定性</strong>.</p>
<p>通常, 一个特征和我们的问题(或者说标签y), 相关性是很好计算的, 几行代码, 皮尔森, 斯皮尔曼, 肯德尔, 互信息, 方差检验…线性与非线性的相关性都能计算.</p>
<p>因果性怎么计算呢? 无法计算, 只能靠人的一些经验进行判断. 一个特征与问题标签有因果性, 也应该有相关性; 但若发现有相关性, 能说明有因果性吗?</p>
<p>所以, 我们想优先找有<strong>因果性</strong>的特征, 但由于因果性难以判断, 退而求其次, 寻找有<strong>相关性</strong>的特征. 而最终判断是否保留某个特征, 可以结合<strong>特征选择</strong>的手段, <strong>模型表现</strong>等来决策.</p>
<h1 id="样本维度"><a href="#样本维度" class="headerlink" title="样本维度"></a>样本维度</h1><p>很多时候, 数据并不是免费资源, 有很多依靠卖数据而存在的公司. 当作为甲方, 向数据公司(乙方)索求数据(特征)时, 是要考虑成本的.</p>
<p>即要保证足量的样本, 来使模型学习得更好, 又要缩减成本. 对此, 我们需要考虑我们全部可以用于建模的样本有哪些, 然后在这些样本中进行<strong>选择</strong>, 使用其中部分样本来购买数据进行建模.</p>
<p>那么, 如何进行选择呢?</p>
<p>首先, 可以考虑<strong>时间维度</strong>. 在一个随时间会发生变化的场景中, 如果我们想观察一些事物随时间的变化, 最好的办法就是把时间线拉长. 同时, 我们是在<strong>未来</strong>使用我们的模型, <strong>近期</strong>的样本理论上和未来可能有更相似, 因此要尽可能使用近期的样本.</p>
<p>时间维度上, 就成了<strong>长期 VS 近期</strong>, 我们要找到一种平衡, 使得我们的样本同时满足以下两点:</p>
<ul>
<li>较长的时间跨度.</li>
<li>包含大量近期的样本.</li>
</ul>
<p>然后, 如果还想进一步对样本进行缩减, 可以对样本进行<strong>随机抽样</strong>. 随机抽样的方式, 通常有两种:</p>
<ul>
<li>完全随机抽样.</li>
<li>分层随机抽样.</li>
</ul>
<p>对于<strong>完全随机抽样</strong>, 不必多说. 对于<strong>分层随机抽样</strong>, 比如我们要做的是二分类模型, 已有0, 1标签, 并且假设正负样本比例不均衡, 正样本远少于负样本. 那么采用分层随机抽样时, 即可以使正负样本在抽样后仍维持原有比例, 也可以分别对正负样本进行不同程度的抽样. 如保留所有正样本, 仅仅对负样本下采样.</p>
<h1 id="组群平衡"><a href="#组群平衡" class="headerlink" title="组群平衡"></a>组群平衡</h1><p>这里仍然举个栗子╰(<em>°▽°</em>)╯</p>
<p>假如我们有一帮用户, 他们组成了我们的样本集. 而用户中存在一些我们人为划分的组群, 如用户是从哪看到我们的广告, 而进行注册的, 可以称之为注册渠道.</p>
<p>可能的注册渠道有很多, 不同注册渠道的用户可能有不同的性质和表现, 一般会进行对应的分析. 那我们能够使用<code>注册渠道</code>这个特征参与建模吗?</p>
<p>如果使用<code>注册渠道</code>参与建模, 可能会出现如下两个问题:</p>
<ul>
<li>高基数的类别特征, 容易导致过拟合.</li>
<li>这样的特征随时间可能并不稳定.</li>
</ul>
<p>首先说第一点, 对于高基数的类别特征, 如果不进行比较细致的人工处理, 直接使用一些类别特征的编码方法, 相对其它特征类型, 是容易出现过拟合的. 即这个特征可能在训练集上是一个强特征, 但实际上特征本身并没有这么强.</p>
<p>然后是第二点, 这是更关键的一点, 即特征随时间变化太大. 比如有的渠道现在有, 未来也许就关闭了, 有的渠道现在没有, 未来加入了. 对于这种情况模型基于这个特征学到的东西, 就没用了(。・・)ノ</p>
<p>那么不把这样的特征参与建模, 就完全没用了吗? 是有用的嗷ヾ(´･ω･｀)ﾉ</p>
<p>如前所述, 组群若随时间发生变化, 那么我用现在已有的样本, 去预测未来的样本, 就需要考虑组群之间的<strong>平衡</strong>问题. 比如<code>组群A</code>, 在现有的全部样本中, 占比超过50%, 而<code>组群B</code>现在占比较少, 仅有10%. 同时通过业务了解到, 未来<code>组群A</code>占比会减少, <code>组群B</code>占比会增加. </p>
<p>问: 此时因该怎么做?</p>
<p>答: 将现有样本中的<code>组群A</code>进行下采样, 如减少一半的样本, 使模型在学习过程中, 不会过度倾向<code>组群A</code>的特点.</p>
<h1 id="标签设计"><a href="#标签设计" class="headerlink" title="标签设计"></a>标签设计</h1><p>尽管有不少无监督学习算法, 但不少情况下, 还是有监督学习算法更好用一些. 而对于有监督学习算法, 用于预测的<strong>标签</strong>是必不可少的.</p>
<p>一些场景下, 标签的获取, 以及定义都比较简单和直接; 而另一些场景下, 标签的获取可能是一件<strong>高成本</strong>的事情, 同时需要一定的<strong>表现期</strong>, 没有现成的<strong>定义方式</strong>.</p>
<p>对于标签成本, 表现期长短, 一般来说是不太好控制的. 而对于标签的定义, 是可控并直接影响模型表现的关键因素.</p>
<p>首先, 要明确应该以什么指标来作为标签, 能够使得模型进行学习后, 预测的结果更好地解决我们的问题. 一些时候问题比较直接, 可能就是想预测用户的年龄, 收入, 性别; 而一些时候问题相对模糊, 比如想衡量一个用户的信用, 对某件商品的兴趣. 对于后者, 一般可以通过用户的一些<strong>行为表现</strong>, 来进行表征, 如利用是否按期还款来作为信用的标签, 按是否购买某商品来作为兴趣的标签.</p>
<p>然后, 进一步, 对于某个问题, 我们是把标签保持为原有的连续值, 形成一个回归问题; 还是将其按某阈值划分0, 1标签, 形成一个二分类排序问题等. 这要根据实际的情况进行决定, 如果原始标签是是连续值, 并且其值是相对稳定, 与观察时间窗口无关, 比如某个用户对电影的评分, 是固定值, 此时可直接采用连续标签. 而一些情况下, 标签值是会随着观察窗口变化的, 比如信用卡还款中的逾期时间, <code>用户A</code>今天累计逾期了30天, 到明天可能就31天了, <code>用户B</code>今天累计逾期20天, 是否说明<code>用户B</code>比<code>用户A</code>信用好呢, 其实是因为<code>用户B</code>的<code>最后还款日期</code>相比<code>用户A</code>迟10天, 而且这都算严重逾期, 因此可以设定一个阈值如10天, 将逾期超10天的都定义为正样本.</p>
<p>此外, 在进行标签设计时, 按某阈值划分正负样本, 可能处于阈值附近的样本, 会使得模型学起来较为困难, 从而降低模型效果. 这时候可以尝试将处于阈值附近的样本过滤掉, 不参与建模. 当然, 这都是要看实际表现来进行决策的, 有时候增加模型学习的难度, 模型或许可以获得更好的表现(๑•̀ㅂ•́)و✧</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据建模-解决问题流程</title>
    <url>/2020/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>生活中, 工作中我们会遇到很多问题, 其中大部分问题是我们以前遇到过的, 我们可以凭借经验进行解决. 然而当我们遇到一个之前没有遇到过的问题时, 我们应该怎么做呢?</p>
<p>作为一个菜鸟小白, 其实自知没有水平写关于这个讨论的文章, 毕竟现在自己遇到问题的时候几乎都是去搬别人的方法. 我个人认为这项能力, 即<code>分析问题 &amp; 转化问题</code>的能力, 是非常重要的, 这也是为什么把这个话题放到了<code>数据建模</code>的第一篇.</p>
<a id="more"></a>
<p>如果, 能够在一开始遇到问题的时候, 明确想要达到的目的, 然后用合理的思路, 将其转化为数学语言, 或者定量的描述, 或者优化目标, 后续的工作大概率是有意义的. 反之, 一开始就错误理解了问题, 或者没有很好地描述问题, 则后续很可能做无用功.</p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>一开始遇到一个问题的时候, 最好先按某种顺序进行梳理, 如从前往后, 或者从整体到局部.</p>
<p>重点在于明确我们要做什么, 可利用的资源有哪些, 难点可能在哪.</p>
<p>这里我就胡扯一个栗子吧, 真的是胡扯ヾ(´･ω･｀)ﾉ</p>
<p>比如我想财富自由, 或者目标放低点, 我想躺着赚钱, 请问有没有什么法子?</p>
<p>有的, 只要买对了股票, 就可以躺着赚钱(。・・)ノ</p>
<p>那怎么买股票呢? 这就是一个模糊的问题, 我们先把模糊的问题具体化.</p>
<p>首先我能用来买股票的钱是有限的.</p>
<p>其次股市有风险, 可能躺着赚钱, 也可能被别人躺着赚钱.</p>
<p>对于散户来说, 一般牛市的时候, 容易赚钱, 熊市的时候, 容易亏钱.</p>
<p>别把鸡蛋都放在一个篮子里.</p>
<p>收益越大, 风险越大.</p>
<p>…</p>
<p>大概这些就是我的一些经验信息, 结合这些信息, 我想做的事情就是:</p>
<blockquote>
<p>用有限的钱, 去买一种股票组合, 使得期望收益最大化.</p>
</blockquote>
<h1 id="转化问题"><a href="#转化问题" class="headerlink" title="转化问题"></a>转化问题</h1><p>有了这个明确的目标, 那下一步考虑是否可以转化成一些定量描述, 或者数学模型.</p>
<p>这一看应该是可以的, <code>最大化</code>就是一个优化问题, <code>有限的钱</code>就是限制条件.</p>
<p>假设咱们有收集数据的能力, 收集到了几种股票的历史长期表现, 再经过一些简单的算法, 可以定量得到每个股票的<code>收益</code>与<code>风险</code>.</p>
<p>现在我们要最大化如下目标函数:</p>
<script type="math/tex; mode=display">
arg\ max(\sum_i资金_i(收益_i-风险_i))\\
s.t.\ 资金_i\ge0\quad i\in I\\
\sum_i资金_i=总资金</script><p>相信聪明的同学已经发现了, 这个优化问题根本不需要所谓的优化o(〃’▽’〃)o</p>
<p>只要把钱全部拿来买<code>收益-风险</code>最大的这一个股票, 就行了.</p>
<p>啊…完美解决问题, （＾∀＾●）ﾉｼ</p>
<p>但是有些不太对劲, 咱们其实并没有完全用到上一节中咱们梳理得到的经验或者知识:</p>
<blockquote>
<p>别把鸡蛋放在一个篮子里.</p>
<p>牛市容易赚钱, 熊市容易亏钱.</p>
</blockquote>
<p>能不能把这些经验或者知识也加入到模型中呢? 试试吧(o゜▽゜)o☆</p>
<p>对于第一条经验, 其实是让我们尽量分散投资, 那我们可以在目标函数中添加一个惩罚机制, 如果越集中购买, 就惩罚越重, <code>L2</code>正则在这里可以达到这样的效果.</p>
<p>对于第二条经验, 可以通过根据当前大盘的局势判断, 来选择<code>总资金</code>的量, 牛市的时候用更多的资金投资, 熊市的时候用少量的资金投资.</p>
<p>总结起来, 现在的目标函数变成了下面这个样子:</p>
<script type="math/tex; mode=display">
arg\ max(\sum_i资金_i(收益_i-风险_i))-\lambda\sum_i资金_i^2\\
s.t.\ 资金_i\ge0\quad i\in I\\
\sum_i资金_i=总资金\times\beta</script><p>其中的$\lambda$是<code>L2</code>正则参数, 越大, 则资金越分散, 越小则越集中.</p>
<p>$\beta$是大盘局势, 牛市时值大, 熊市时值小.</p>
<p>通过调节以上两个超参数, 可以控制<code>购买总金额</code>以及<code>资金分散程度</code>.</p>
<h1 id="寻找相似问题"><a href="#寻找相似问题" class="headerlink" title="寻找相似问题"></a>寻找相似问题</h1><p>现在我们有了具体的数学优化函数, 那如合进一步去解决这个问题呢?</p>
<p>我认为最好的方法, 仍然是首先借鉴前人的智慧. 如果存在一个类似的问题, 前人已经解决过, 那这时候我们可以借鉴, 甚至直接照搬其中的做法. 这样可以达到事半功倍的效果（。＾▽＾）</p>
<p>那有的同学就要问了, 我怎么知道哪里有相似的问题呢, 别人的办法我看不懂怎么办, 看懂了也不会做怎么办</p>
<p>摸摸头 (。・・)ノ</p>
<p>确实是这样的, 所以这就涉及到一个平时积累的过程了. </p>
<p>一些问题的解法, 或许我们平时生活工作中是没有用到过的, 但是出于好奇心感兴趣, 或者就是认为以后某一天这个会派上用场, 而去学习理解, 并归纳消化.</p>
<p>如此, 有了一定的知识库作为支撑, 才能够看得更远(ง •_•)ง</p>
<p>还是以上一个小结瞎举的栗子来说, 这个问题是一个很典型的<code>带约束的优化问题</code>, 并且符合<code>KKT</code>条件, 那么就可以利用<code>拉格朗日乘子法</code>转化成<code>无约束优化问题</code>, 进而运用<code>无约束优化问题</code>的一些方法, 如<code>SGD</code>进行解决.</p>
<p>具体来做的话, 当然可以自己写代码, 也可以调用已有的轮子. 比如<code>scipy</code>中有关于<code>带约束的优化问题</code>的方法, 查阅对应API, 几行代码就可以得到问题的解♪(^∇^*)</p>
<h1 id="更多尝试-amp-优化"><a href="#更多尝试-amp-优化" class="headerlink" title="更多尝试 &amp; 优化"></a>更多尝试 &amp; 优化</h1><p>通常, 我们在处理一个没怎么做过的问题时, 优先的方法, 一般不是一些特别复杂的办法, 而是一些尽可能简单而有效的方法.</p>
<p>当我们相对简单的方法奏效后, 后续可以根据对结果的分析, 提出更多的尝试与优化方案, 进行迭代升级.</p>
<p>比如, 当我们面对一个问题, 数据很少, 甚至没有数据的时候, 就不要生搬硬套一些基于大量数据的机器学习模型. </p>
<p>结合对数据的分析, 和个人的经验以及业务理解, 提出一些定量的建议或者规则, 就是不错的.</p>
<p>再比如, 经过一定的积累, 在有了一定数据的基础上, 可以尝试用一些机器学习算法.</p>
<p>但不同机器学习模型, 对于数据的维度与量的要求是不一样的. 假如数据量少, 或者数据非常稀疏, 或许线性模型是一个很好的选择; 假如数据量大, 同时其中蕴含着很多非线性关系, 可能神经网络这一类模型更加合适.</p>
<p>总之, 在面对一个新的难题时, 应该先从简单的解决方法入手, 并将其结果表现作为基准, 然后再逐步地尝试优化, 最终得到一个更好的结果.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Decrypt String from Alphabet to Integer Mapping</title>
    <url>/2020/06/06/LeetCode/Decrypt-String-from-Alphabet-to-Integer-Mapping/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a string <code>s</code> formed by digits (<code>&#39;0&#39;</code> - <code>&#39;9&#39;</code>) and <code>&#39;#&#39;</code> . We want to map <code>s</code> to English lowercase characters as follows:</p>
<ul>
<li>Characters (<code>&#39;a&#39;</code> to <code>&#39;i&#39;)</code> are represented by (<code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>) respectively.</li>
<li>Characters (<code>&#39;j&#39;</code> to <code>&#39;z&#39;)</code> are represented by (<code>&#39;10#&#39;</code> to <code>&#39;26#&#39;</code>) respectively. </li>
</ul>
<p>Return the string formed after mapping.</p>
<p>It’s guaranteed that a unique mapping will always exist.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;10#11#12&quot;</span><br><span class="line">Output: &quot;jkab&quot;</span><br><span class="line">Explanation: &quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;1326#&quot;</span><br><span class="line">Output: &quot;acz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;25#&quot;</span><br><span class="line">Output: &quot;y&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#&quot;</span><br><span class="line">Output: &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> only contains digits letters (<code>&#39;0&#39;</code>-<code>&#39;9&#39;</code>) and <code>&#39;#&#39;</code> letter.</li>
<li><code>s</code> will be valid string such that mapping is always possible.</li>
</ul>
<hr>
<p>给你一个字符串 <code>s</code>，它由数字（<code>&#39;0&#39;</code> - <code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 组成。我们希望按下述规则将 <code>s</code> 映射为一些小写英文字符：</p>
<ul>
<li>字符（<code>&#39;a&#39;</code> - <code>&#39;i&#39;</code>）分别用（<code>&#39;1&#39;</code> - <code>&#39;9&#39;</code>）表示。</li>
<li>字符（<code>&#39;j&#39;</code> - <code>&#39;z&#39;</code>）分别用（<code>&#39;10#&#39;</code> - <code>&#39;26#&#39;</code>）表示。 </li>
</ul>
<p>返回映射之后形成的新字符串。</p>
<p>题目数据保证映射始终唯一。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;10#11#12&quot;</span><br><span class="line">输出：&quot;jkab&quot;</span><br><span class="line">解释：&quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1326#&quot;</span><br><span class="line">输出：&quot;acz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;25#&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#&quot;</span><br><span class="line">输出：&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 只包含数字（<code>&#39;0&#39;</code>-<code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 字符。</li>
<li><code>s</code> 是映射始终存在的有效字符串。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>得到数字与字母的映射字典. 然后利用<code>.split(&#39;#&#39;)</code>对字符串进行分割.</p>
<p>每个小字符串的最后两位对应一个字母.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        alpha_list = [chr(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(ord(<span class="string">'a'</span>), ord(<span class="string">'z'</span>) + <span class="number">1</span>)]</span><br><span class="line">        num_list = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>)]</span><br><span class="line">        map_dict = dict(zip(num_list, alpha_list))</span><br><span class="line">        s_list = s.split(<span class="string">'#'</span>)</span><br><span class="line">        len_ = len(s_list)</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">            tmp_s = s_list[i]</span><br><span class="line">            <span class="keyword">if</span> i &lt; len_ - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> tmp_s[: <span class="number">-2</span>]:</span><br><span class="line">                    res += map_dict[j]</span><br><span class="line">                res += map_dict[tmp_s[<span class="number">-2</span>:]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> tmp_s:</span><br><span class="line">                    res += map_dict[j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-06-06</li>
<li>击败比例: 76.50%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Unique Number of Occurrences</title>
    <url>/2020/06/05/LeetCode/Unique-Number-of-Occurrences/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given an array of integers <code>arr</code>, write a function that returns <code>true</code> if and only if the number of occurrences of each value in the array is unique.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr = [1,2,2,1,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr = [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<hr>
<p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>很简单, 利用字典记录各个数字出现的次数, 然后比较即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueOccurrences</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        counter = Counter(arr)</span><br><span class="line">        <span class="keyword">return</span> len(counter) == len(set(counter.values()))</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-06-05</li>
<li>击败比例: 83.65%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Verifying an Alien Dictionary</title>
    <url>/2020/06/04/LeetCode/Verifying-an-Alien-Dictionary/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different <code>order</code>. The <code>order</code> of the alphabet is some permutation of lowercase letters.</p>
<p>Given a sequence of <code>words</code> written in the alien language, and the <code>order</code> of the alphabet, return <code>true</code> if and only if the given <code>words</code> are sorted lexicographicaly in this alien language.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>order.length == 26</code></li>
<li>All characters in <code>words[i]</code> and <code>order</code> are English lowercase letters.</li>
</ul>
<hr>
<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>
<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在该语言的字母表中，&apos;h&apos; 位于 &apos;l&apos; 之前，所以单词序列是按字典序排列的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：在该语言的字母表中，&apos;d&apos; 位于 &apos;l&apos; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &apos;l&apos; &gt; &apos;∅&apos;，其中 &apos;∅&apos; 是空白字符，定义为比任何其他字符都小（更多信息）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>order.length == 26</code></li>
<li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>可以用字典来记录每个字母之间的大小, 然后对列表中的每队相邻的单词进行比较即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.order_dict = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words, order)</span>:</span></span><br><span class="line">        order_dict = &#123;&#125;</span><br><span class="line">        self.order_dict = order_dict</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, k <span class="keyword">in</span> enumerate(order):</span><br><span class="line">            order_dict[k] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words) - <span class="number">1</span>):</span><br><span class="line">            w_i = words[i]</span><br><span class="line">            w_i_1 = words[i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> self.helper(w_i, w_i_1):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len(a), len(b))):</span><br><span class="line">            <span class="keyword">if</span> self.order_dict[a[i]] &lt; self.order_dict[b[i]]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> self.order_dict[a[i]] == self.order_dict[b[i]]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(a) &lt;= len(b):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-06-04</li>
<li>击败比例: 96.76%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Decompress Run-Length Encoded List</title>
    <url>/2020/06/01/LeetCode/Decompress-Run-Length-Encoded-List/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We are given a list <code>nums</code> of integers representing a list compressed with run-length encoding.</p>
<p>Consider each adjacent pair of elements <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> (with <code>i &gt;= 0</code>). For each such pair, there are <code>freq</code> elements with value <code>val</code> concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.</p>
<p>Return the decompressed list.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: [2,4,4,4]</span><br><span class="line">Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].</span><br><span class="line">The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].</span><br><span class="line">At the end the concatenation [2] + [4,4,4] is [2,4,4,4].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2,3]</span><br><span class="line">Output: [1,3,3]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 100</code></li>
<li><code>nums.length % 2 == 0</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<hr>
<p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>
<p>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i &gt;= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>
<p>请你返回解压后的列表。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[2,4,4,4]</span><br><span class="line">解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。</span><br><span class="line">第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。</span><br><span class="line">最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2,3]</span><br><span class="line">输出：[1,3,3]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 100</code></li>
<li><code>nums.length % 2 == 0</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>很简单, 照着题意写就行了.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decompressRLElist</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) // <span class="number">2</span>):</span><br><span class="line">            freq, val = nums[<span class="number">2</span> * i], nums[<span class="number">2</span> * i + <span class="number">1</span>]</span><br><span class="line">            res_list += [val] * freq</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-06-01</li>
<li>击败比例: 65.87%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Distance Between Bus Stops</title>
    <url>/2020/05/31/LeetCode/Distance-Between-Bus-Stops/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>A bus has <code>n</code> stops numbered from <code>0</code> to <code>n - 1</code> that form a circle. We know the distance between all pairs of neighboring stops where <code>distance[i]</code> is the distance between the stops number <code>i</code> and <code>(i + 1) % n</code>.</p>
<p>The bus goes along both directions i.e. clockwise and counterclockwise.</p>
<p>Return the shortest distance between the given <code>start</code> and <code>destination</code> stops.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/09/03/untitled-diagram-1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: distance = [1,2,3,4], start = 0, destination = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/09/03/untitled-diagram-1-1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: distance = [1,2,3,4], start = 0, destination = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/09/03/untitled-diagram-1-2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: distance = [1,2,3,4], start = 0, destination = 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^4</code></li>
<li><code>distance.length == n</code></li>
<li><code>0 &lt;= start, destination &lt; n</code></li>
<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>
</ul>
<hr>
<p>环形公交路线上有 <code>n</code> 个站，按次序从 <code>0</code> 到 <code>n - 1</code> 进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code> 表示编号为 <code>i</code> 的车站和编号为 <code>(i + 1) % n</code> 的车站之间的距离。</p>
<p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p>
<p>返回乘客从出发点 <code>start</code> 到目的地 <code>destination</code> 之间的最短距离。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：distance = [1,2,3,4], start = 0, destination = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：distance = [1,2,3,4], start = 0, destination = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：distance = [1,2,3,4], start = 0, destination = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^4</code></li>
<li><code>distance.length == n</code></li>
<li><code>0 &lt;= start, destination &lt; n</code></li>
<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>由于是环形的, 所以最短距离只可能有两种情况, 分别计算出两种情况的距离, 返回较小值即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceBetweenBusStops</span><span class="params">(self, distance, start, destination)</span>:</span></span><br><span class="line">        total_len = sum(distance)</span><br><span class="line">        start, destination = min(start, destination), max(start, destination)</span><br><span class="line">        len_a = sum(distance[start: destination])</span><br><span class="line">        len_b = total_len - len_a</span><br><span class="line">        <span class="keyword">return</span> min(len_a, len_b)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-31</li>
<li>击败比例: 92.10%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Counting Bits</title>
    <url>/2020/05/30/LeetCode/Counting-Bits/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<ul>
<li>It is very easy to come up with a solution with run time <strong>O(n*sizeof(integer))</strong>. But can you do it in linear time <strong>O(n)</strong> /possibly in a single pass?</li>
<li>Space complexity should be <strong>O(n)</strong>.</li>
<li>Can you do it like a boss? Do it without using any builtin function like <strong>__builtin_popcount</strong> in c++ or in any other language.</li>
</ul>
<hr>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<ul>
<li>给出时间复杂度为<strong>O(n*sizeof(integer))</strong>的解答非常容易。但你可以在线性时间<strong>O(n)</strong>内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为<strong>O(n)</strong>。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <strong>__builtin_popcount</strong>）来执行此操作。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>考虑到动态规划的思想, 充分利用之前的信息.</p>
<p>对于二进制数来说, 奇数的最后一位必定是1, 那么1的个数比上一个偶数多1.</p>
<p>二进制偶数, 除以二后, 相当于右移一位, 减少末尾的0, 1的个数不变.</p>
<p>基于以上两个条件, 就可以从0开始, 逐渐计算出所有数的二进制1的个数.</p>
<p>时间复杂度$O(N)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        res_list = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res_list.append(res_list[i // <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res_list.append(res_list[<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-30</li>
<li>击败比例: 99.38%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Bit</category>
      </categories>
  </entry>
  <entry>
    <title>Find N Unique Integers Sum up to Zero</title>
    <url>/2020/05/29/LeetCode/Find-N-Unique-Integers-Sum-up-to-Zero/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong> integers such that they add up to 0.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: [-7,-1,1,3,4]</span><br><span class="line">Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [-1,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<hr>
<p>给你一个整数 <code>n</code>，请你返回 <strong>任意</strong> 一个由 <code>n</code> 个 <strong>各不相同</strong> 的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：[-7,-1,1,3,4]</span><br><span class="line">解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[-1,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>很简单, 就不多说了.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        res_list = [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(n // <span class="number">2</span>)]</span><br><span class="line">        res_list = res_list + [-x <span class="keyword">for</span> x <span class="keyword">in</span> res_list]</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res_list</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res_list.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-29</li>
<li>击败比例: </li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Create Target Array in the Given Order</title>
    <url>/2020/05/28/LeetCode/Create-Target-Array-in-the-Given-Order/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given two arrays of integers <code>nums</code> and <code>index</code>. Your task is to create <em>target</em> array under the following rules:</p>
<ul>
<li>Initially <em>target</em> array is empty.</li>
<li>From left to right read nums[i] and index[i], insert at index <code>index[i]</code> the value <code>nums[i]</code> in <em>target</em> array.</li>
<li>Repeat the previous step until there are no elements to read in <code>nums</code> and <code>index.</code></li>
</ul>
<p>Return the <em>target</em> array.</p>
<p>It is guaranteed that the insertion operations will be valid.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]</span><br><span class="line">Output: [0,4,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]</span><br><span class="line">Output: [0,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [1], index = [0]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>
<li><code>nums.length == index.length</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
<li><code>0 &lt;= index[i] &lt;= i</code></li>
</ul>
<hr>
<p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p>
<ul>
<li>目标数组 <code>target</code> 最初为空。</li>
<li>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</li>
<li>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</li>
</ul>
<p>请你返回目标数组。</p>
<p>题目保证数字插入位置总是存在。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,0], index = [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], index = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>
<li><code>nums.length == index.length</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
<li><code>0 &lt;= index[i] &lt;= i</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>很简单, 直接写就行了.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTargetArray</span><span class="params">(self, nums, index)</span>:</span></span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            res_list.insert(index[i], nums[i])</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-28</li>
<li>击败比例: 100.00%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Prime Arrangements</title>
    <url>/2020/05/27/LeetCode/Prime-Arrangements/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Return the number of permutations of 1 to <code>n</code> so that prime numbers are at prime indices (1-indexed.)</p>
<p><em>(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)</em></p>
<p>Since the answer may be large, return the answer <strong>modulo <code>10^9 + 7</code></strong>.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 100</span><br><span class="line">Output: 682289015</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
</ul>
<hr>
<p>请你帮忙给从 <code>1</code> 到 <code>n</code> 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。</p>
<p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。</p>
<p>由于答案可能会很大，所以请你返回答案 <strong>模 mod <code>10^9 + 7</code></strong> 之后的结果即可。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：12</span><br><span class="line">解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 100</span><br><span class="line">输出：682289015</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>还是挺有意思的一道题目, 有两个关键点:</p>
<ol>
<li>对某个数取模这个运算, 等价于对其因数取模的乘积, 这样可以避免过程中出现很大的数.</li>
<li>某个数如果是质数, 那么其两倍, 三倍…这些位置上的数是合数.</li>
</ol>
<p>基于以上两点, 首先计算得到质数跟非质数数各自的数量, 然后计算全排列的乘积. 在计算全排列的过程中, 每一步都可以取模.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPrimeArrangements</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        is_prime_list = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        is_prime_list[<span class="number">0</span>], is_prime_list[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span> + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> is_prime_list[i] == <span class="number">1</span>:</span><br><span class="line">                is_prime_list[i * i: n + <span class="number">1</span>: i] = [<span class="number">0</span>] * ((n - i * i) // i + <span class="number">1</span>)</span><br><span class="line">        prime_num = sum(is_prime_list)</span><br><span class="line">        not_prime_num = n - prime_num</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= prime_num:</span><br><span class="line">            res = res * i % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= not_prime_num:</span><br><span class="line">            res = res * i % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-27</li>
<li>击败比例: 57.83%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>Reformat The String</title>
    <url>/2020/05/26/LeetCode/Reformat-The-String/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given alphanumeric string <code>s</code>. (<strong>Alphanumeric string</strong> is a string consisting of lowercase English letters and digits).</p>
<p>You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.</p>
<p>Return <em>the reformatted string</em> or return <strong>an empty string</strong> if it is impossible to reformat the string.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;a0b1c2&quot;</span><br><span class="line">Output: &quot;0a1b2c&quot;</span><br><span class="line">Explanation: No two adjacent characters have the same type in &quot;0a1b2c&quot;. &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; are also valid permutations.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: &quot;leetcode&quot; has only characters so we cannot separate them by digits.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;1229857369&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: &quot;1229857369&quot; has only digits so we cannot separate them by characters.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;covid2019&quot;</span><br><span class="line">Output: &quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;ab123&quot;</span><br><span class="line">Output: &quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> consists of only lowercase English letters and/or digits.</li>
</ul>
<hr>
<p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a0b1c2&quot;</span><br><span class="line">输出：&quot;0a1b2c&quot;</span><br><span class="line">解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1229857369&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;covid2019&quot;</span><br><span class="line">输出：&quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab123&quot;</span><br><span class="line">输出：&quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母和/或数字组成。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>首先比较字符串中字母和数字的数量, 然后根据情况进行拼接.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformat</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        letter_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> x.isalpha()]</span><br><span class="line">        digit_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> x.isdigit()]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> abs(len(letter_list) - len(digit_list)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">elif</span> len(letter_list) - len(digit_list) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(letter_list) &gt; <span class="number">0</span>:</span><br><span class="line">                res += letter_list.pop() + digit_list.pop()</span><br><span class="line">        <span class="keyword">elif</span> len(letter_list) - len(digit_list) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">while</span> len(letter_list) &gt; <span class="number">1</span>:</span><br><span class="line">                res += letter_list.pop() + digit_list.pop()</span><br><span class="line">            res += letter_list.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> len(letter_list) &gt; <span class="number">0</span>:</span><br><span class="line">                res += digit_list.pop() + letter_list.pop() </span><br><span class="line">            res += digit_list.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-26</li>
<li>击败比例: 68.33%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Lucky Numbers in a Matrix</title>
    <url>/2020/05/25/LeetCode/Lucky-Numbers-in-a-Matrix/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a <code>m * n</code> matrix of <strong>distinct</strong> numbers, return all lucky numbers in the matrix in <strong>any</strong> order.</p>
<p>A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]</span><br><span class="line">Output: [15]</span><br><span class="line">Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]</span><br><span class="line">Output: [12]</span><br><span class="line">Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[7,8],[1,2]]</span><br><span class="line">Output: [7]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 50</code></li>
<li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code>.</li>
<li>All elements in the matrix are distinct.</li>
</ul>
<hr>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p>
<p>幸运数是指矩阵中满足同时下列两个条件的元素：</p>
<ul>
<li>在同一行的所有元素中最小</li>
<li>在同一列的所有元素中最大</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]</span><br><span class="line">输出：[15]</span><br><span class="line">解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]</span><br><span class="line">输出：[12]</span><br><span class="line">解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[7,8],[1,2]]</span><br><span class="line">输出：[7]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 50</code></li>
<li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li>
<li>矩阵中的所有元素都是不同的</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>题目很简单, 可以先把每一行中, 最小的数对应的列进行记录.</p>
<p>然后再找出每一列中最大的数的位置, 进行对比即可.</p>
<p>这里有个小问题, 即对于列表组成的数组, 不方便直接比较列.</p>
<p>一种解决方式是运用numpy, 但是加载numpy的时间会让你代码的速度排名下降很大[手动狗头].</p>
<p>还有一个技巧是利用zip函数, 将原矩阵的行列进行转置, 这样就可以在行中处理列.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        n_row = len(matrix)</span><br><span class="line">        n_col = len(matrix[<span class="number">0</span>])</span><br><span class="line">        info_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n_row):</span><br><span class="line">            info_dict[row] = matrix[row].index(min(matrix[row]))</span><br><span class="line">        matrix = list(zip(*matrix))</span><br><span class="line">        matrix = [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> matrix]</span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n_col):</span><br><span class="line">            max_row_idx = matrix[col].index(max(matrix[col]))</span><br><span class="line">            <span class="keyword">if</span> col == info_dict[max_row_idx]:</span><br><span class="line">                res_list.append(matrix[col][max_row_idx])</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-25</li>
<li>击败比例: 99.92%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>node2vec</title>
    <url>/2020/05/24/%E5%9B%BE%E7%AE%97%E6%B3%95/node2vec/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>二分网络的部分方法与应用</title>
    <url>/2020/05/24/%E5%9B%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E7%BD%91%E7%BB%9C%E7%9A%84%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>除了社交网络这一常见的网络类型外, 二分网络也是一种经常出现的网络. 所谓二分网络, 即节点被分为了两大类, 其中的边总是存在于一类节点到另一类节点之间. 例如用户与商品的二分网络, 投资者与股票的二分网络等.</p>
<p>特别是用户与商品构成的商品偏好网络, 有着很大的研究价值, 对于构建推荐系统来说必不可少的. 推荐系统一般考虑的是, 想什么样的用户推荐什么样的商品, 会使得用户喜欢, 点击率更高一些. 比如豆瓣电影, 每部电影下, 有用户对该电影的评分, 评分的由高到低, 表示了用户对其的喜欢与不喜欢.</p>
<a id="more"></a>
<p>这样, 用户对产品的评分, 或者是否购买某产品, 构成了一个二分网络. 仍然以豆瓣电影为例, 一个简单的二分网络如下图:</p>
<p><img src="fig_0.png" alt="fig_0"></p>
<p>对于该网络, 以矩阵来表示为:</p>
<p><img src="fig_1.png" alt="fig_1"></p>
<p>其中每个格点的值, 表示该用户对该电影的评分. 接下来, 就以推荐这一应用为目的, 来介绍与二分网络相关的一些方法.</p>
<h1 id="基于内容"><a href="#基于内容" class="headerlink" title="基于内容"></a>基于内容</h1><p>其实基于内容进行推荐的方法, 并没有充分利用到二分网络的特点, 在这里进行简要介绍.</p>
<p>基于内容的推荐, 核心的步骤为3个:</p>
<ul>
<li>构建商品的特征向量.</li>
<li>构建用户的特征向量.</li>
<li>计算商品-用户的相似性.</li>
</ul>
<p>对于特征向量的构造, 没有固定的方法, 根据实际情况可以很简单, 也可以很复杂.</p>
<p>对于相似性评估指标, 一般来说余弦相似度就是不错的相似度评估指标(遇事不决选余弦).</p>
<p>基于内容进行推荐有着如下的优缺点:</p>
<ul>
<li>优点:<ul>
<li>可以应用到一个新商品上.</li>
<li>不会倾向于流行商品.</li>
<li>如果特征向量构建解释性强, 则最终推荐结果解释性强.</li>
</ul>
</li>
<li>缺点:<ul>
<li>有时候构建有效特征比较困难.</li>
<li>推荐范围可能比较狭窄.</li>
<li>对新用户无效.</li>
<li>没有充分利用到二分网络的整体结构信息.</li>
</ul>
</li>
</ul>
<h1 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h1><p>在推荐领域, 协同过滤是一种有效的方法, 分为基于用户与基于物品的协同过滤. 之所以叫做协同过滤, 指的是利用其他的用户或者商品一起, 过滤出值得推荐的商品.</p>
<ul>
<li><p>基于用户的协同过滤.</p>
<p>基于用户进行协同过滤, 基本思想是首先根据二分网络, 找到与目标用户相似的那些用户, 然后再根据相似的用户会喜欢哪些商品, 推荐给目标用户.</p>
<p><img src="fig_2.png" alt="fig_2"></p>
</li>
<li><p>基于物品的协同过滤.</p>
<p>基于物品进行协同过滤, 击败思想是首先根据二分网络, 找到与目标用户所喜欢的商品相似的商品, 然后将这些商品推荐给用户.</p>
<p><img src="fig_3.png" alt="fig_3"></p>
</li>
<li><p>相似性计算.</p>
<p>用户与物品的相似性计算是类似的, 将每个用户对每个物品的打分(没有记录则为空)整理为一个矩阵. 每个用户的向量可以使用对物品的打分构成; 每个物品的向量可以用各个用户对它的打分构成. 向量中的空值可以用0来填充.</p>
<p>得到向量后, 相似性就可以利用余弦相似度进行计算了.</p>
<script type="math/tex; mode=display">
Cosine\_Similarity=\frac{AB}{|A||B|}</script></li>
</ul>
<p>  然而这里存在的一个问题是, 对于用户没有评分的物品, 其实有两种可能:</p>
<ol>
<li>用户还没接触过.</li>
<li><p>用户提前知道自己不喜欢该物品, 不参与打分.</p>
<p>因此直接使用0来进行填充, 是不太好的. 一种更好的方法是, 是计算出用户对每个物品打分的平均值, 再将用户对物品的打分基础上减去这个平均值.</p>
<p><img src="fig_4.png" alt="fig_4"></p>
<p>进行这样的处理后, 0可以视作用户对物品的一个平均评分, 比之前的情形要好一些.</p>
<p>使用协同过滤, 有如下优缺点:</p>
</li>
</ol>
<ul>
<li><p>优点:</p>
<ul>
<li>不需要去精心设计物品与用户的特征向量, 只要有二分网络即可.</li>
<li>在有一定数据积累的情况下, 效果一般比基于内容的方法好.</li>
</ul>
</li>
<li><p>缺点:</p>
<ul>
<li>冷启动问题, 无论是对新用户, 还是新物品都难以进行推荐.</li>
<li>倾向推荐比较流行的商品.</li>
<li>如果二分网络对应的矩阵非常稀疏, 那么效果将会不好.</li>
</ul>
</li>
</ul>
<h1 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h1><p>我们知道对称方阵$A$, 可以用下式的特征分解表示:</p>
<script type="math/tex; mode=display">
A=W\Sigma W^{-1}</script><p>其中$W$为酉矩阵, $\Sigma$为对角矩阵, 对角值为特征值.</p>
<p>那么对于任意的距阵$A_{m\times n}$, 可以进行类似的分解吗? 也是可以的:</p>
<script type="math/tex; mode=display">
A=U\Sigma V^{T}</script><p>这样的分解称为奇异值分解(SVD), 其中, $U$是$m\times m$的酉矩阵, $V$是$n\times n$的酉矩阵, $\Sigma$是$m\times n$的矩阵, 除了主对角线外的元素都是0, 主对角线上的每个元素称为奇异值.</p>
<p>这里暂且不细说矩阵分解的具体过程, 可以采用解析的方式, 也可以采用迭代的方式.</p>
<p>当使用奇异值分解后, 在奇异值矩阵中也是按照从大到小排列, 而且奇异值的减小特别快, 在很多情况下, 前10%甚至1%的奇异值就占了全部奇异值之和的99%以上的比例. 也就是说, 可以用最大的$k$个奇异值和对应的左右奇异向量来近似描述矩阵:</p>
<script type="math/tex; mode=display">
A_{m\times n}\thickapprox U_{m\times k}\Sigma_{k\times k}V^T_{k\times n}</script><p>如果在原矩阵中, 一些格点上存在缺失, 经过改动的矩阵分解方法, 可以在进行分解时只考虑非缺失部分. 当得到分解后的矩阵后, 可以对原本缺失的格点进行预测.</p>
<p>将其运用到二分网络, 商品推荐中, 如下图:</p>
<p><img src="fig_5.png" alt="fig_5"></p>
<p>可以对每个物品, 每个用户, 得到他们对应的$k$维特征向量, 要计算某个用户对某个物品的打分或者评价, 最简单的方法就是将两者的特征向量点乘.</p>
<p>对于SVD, 以及改进的方法SVD++, 在推荐系统中的效果是很好的, 相比协同过滤, 在面对稀疏数据的时候, 可以有更好的表现.</p>
<h1 id="信息推测"><a href="#信息推测" class="headerlink" title="信息推测"></a>信息推测</h1><p>在上面协同过滤的方法中, 可以知道某个用户与哪些用户更加相似, 那么利用这个相似度, 可以做更多的事情, 比如可以用于推测用户的信息.</p>
<p><img src="fig_6.png" alt="fig_6"></p>
<p>同样, 由矩阵分解得到的特征, 也能够用来做类似的事情, 例如利用特征与某用户信息的标签(如年龄), 构建模型进行预测, 通常会取得不错的效果.</p>
<h1 id="Surprise"><a href="#Surprise" class="headerlink" title="Surprise"></a>Surprise</h1><p><a href="https://github.com/NicolasHug/Surprise" target="_blank" rel="noopener">Surprise</a>是Python下一个推荐系统库.</p>
<p>使用方式与scikit包相似.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> SVD</span><br><span class="line"><span class="keyword">from</span> surprise <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> surprise.model_selection <span class="keyword">import</span> cross_validate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the movielens-100k dataset (download it if needed).</span></span><br><span class="line">data = Dataset.load_builtin(<span class="string">'ml-100k'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the famous SVD algorithm.</span></span><br><span class="line">algo = SVD()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run 5-fold cross-validation and print results.</span></span><br><span class="line">cross_validate(algo, data, measures=[<span class="string">'RMSE'</span>, <span class="string">'MAE'</span>], cv=<span class="number">5</span>, verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Evaluating RMSE, MAE of algorithm SVD on 5 split(s).</span><br><span class="line"></span><br><span class="line">            Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std</span><br><span class="line">RMSE        0.9311  0.9370  0.9320  0.9317  0.9391  0.9342  0.0032</span><br><span class="line">MAE         0.7350  0.7375  0.7341  0.7342  0.7375  0.7357  0.0015</span><br><span class="line">Fit time    6.53    7.11    7.23    7.15    3.99    6.40    1.23</span><br><span class="line">Test time   0.26    0.26    0.25    0.15    0.13    0.21    0.06</span><br></pre></td></tr></table></figure>
<p>其中包含了一些主流的应用于二分网络的推荐算法, 包括协同过滤, SVD等.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><a href="http://grouplens.org/datasets/movielens/100k" target="_blank" rel="noopener">Movielens 100k</a></th>
<th>RMSE</th>
<th>MAE</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/matrix_factorization.html#surprise.prediction_algorithms.matrix_factorization.SVD" target="_blank" rel="noopener">SVD</a></td>
<td>0.934</td>
<td>0.737</td>
<td>0:00:11</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/matrix_factorization.html#surprise.prediction_algorithms.matrix_factorization.SVDpp" target="_blank" rel="noopener">SVD++</a></td>
<td>0.92</td>
<td>0.722</td>
<td>0:09:03</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/matrix_factorization.html#surprise.prediction_algorithms.matrix_factorization.NMF" target="_blank" rel="noopener">NMF</a></td>
<td>0.963</td>
<td>0.758</td>
<td>0:00:15</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/slope_one.html#surprise.prediction_algorithms.slope_one.SlopeOne" target="_blank" rel="noopener">Slope One</a></td>
<td>0.946</td>
<td>0.743</td>
<td>0:00:08</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/knn_inspired.html#surprise.prediction_algorithms.knns.KNNBasic" target="_blank" rel="noopener">k-NN</a></td>
<td>0.98</td>
<td>0.774</td>
<td>0:00:10</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/knn_inspired.html#surprise.prediction_algorithms.knns.KNNWithMeans" target="_blank" rel="noopener">Centered k-NN</a></td>
<td>0.951</td>
<td>0.749</td>
<td>0:00:10</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/knn_inspired.html#surprise.prediction_algorithms.knns.KNNBaseline" target="_blank" rel="noopener">k-NN Baseline</a></td>
<td>0.931</td>
<td>0.733</td>
<td>0:00:12</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/co_clustering.html#surprise.prediction_algorithms.co_clustering.CoClustering" target="_blank" rel="noopener">Co-Clustering</a></td>
<td>0.963</td>
<td>0.753</td>
<td>0:00:03</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/basic_algorithms.html#surprise.prediction_algorithms.baseline_only.BaselineOnly" target="_blank" rel="noopener">Baseline</a></td>
<td>0.944</td>
<td>0.748</td>
<td>0:00:01</td>
</tr>
<tr>
<td><a href="http://surprise.readthedocs.io/en/stable/basic_algorithms.html#surprise.prediction_algorithms.random_pred.NormalPredictor" target="_blank" rel="noopener">Random</a></td>
<td>1.514</td>
<td>1.215</td>
<td>0:00:01</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>Find Positive Integer Solution for a Given Equation</title>
    <url>/2020/05/24/LeetCode/Find-Positive-Integer-Solution-for-a-Given-Equation/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a function <code>f(x, y)</code> and a value <code>z</code>, return all positive integer pairs <code>x</code> and <code>y</code> where <code>f(x,y) == z</code>.</p>
<p>The function is constantly increasing, i.e.:</p>
<ul>
<li><code>f(x, y) &lt; f(x + 1, y)</code></li>
<li><code>f(x, y) &lt; f(x, y + 1)</code></li>
</ul>
<a id="more"></a>
<p>The function interface is defined like this: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CustomFunction &#123;</span><br><span class="line">public:</span><br><span class="line">  // Returns positive integer f(x, y) for any given positive integer x and y.</span><br><span class="line">  int f(int x, int y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For custom testing purposes you’re given an integer <code>function_id</code> and a target <code>z</code> as input, where <code>function_id</code> represent one function from an secret internal list, on the examples you’ll know only two functions from the list.  </p>
<p>You may return the solutions in any order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: function_id = 1, z = 5</span><br><span class="line">Output: [[1,4],[2,3],[3,2],[4,1]]</span><br><span class="line">Explanation: function_id = 1 means that f(x, y) = x + y</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: function_id = 2, z = 5</span><br><span class="line">Output: [[1,5],[5,1]]</span><br><span class="line">Explanation: function_id = 2 means that f(x, y) = x * y</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= function_id &lt;= 9</code></li>
<li><code>1 &lt;= z &lt;= 100</code></li>
<li>It’s guaranteed that the solutions of <code>f(x, y) == z</code> will be on the range <code>1 &lt;= x, y &lt;= 1000</code></li>
<li>It’s also guaranteed that <code>f(x, y)</code> will fit in 32 bit signed integer if <code>1 &lt;= x, y &lt;= 1000</code></li>
</ul>
<hr>
<p>给出一个函数 <code>f(x, y)</code> 和一个目标结果 <code>z</code>，请你计算方程 <code>f(x,y) == z</code> 所有可能的正整数 <strong>数对</strong> <code>x</code> 和 <code>y</code>。</p>
<p>给定函数是严格单调的，也就是说：</p>
<ul>
<li><code>f(x, y) &lt; f(x + 1, y)</code></li>
<li><code>f(x, y) &lt; f(x, y + 1)</code></li>
</ul>
<p>函数接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CustomFunction &#123;</span><br><span class="line">public:</span><br><span class="line">  // Returns positive integer f(x, y) for any given positive integer x and y.</span><br><span class="line">  int f(int x, int y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你想自定义测试，你可以输入整数 <code>function_id</code> 和一个目标结果 <code>z</code> 作为输入，其中 <code>function_id</code> 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 <code>2</code> 个函数。  </p>
<p>你可以将满足条件的 <strong>结果数对</strong> 按任意顺序返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：function_id = 1, z = 5</span><br><span class="line">输出：[[1,4],[2,3],[3,2],[4,1]]</span><br><span class="line">解释：function_id = 1 表示 f(x, y) = x + y</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：function_id = 2, z = 5</span><br><span class="line">输出：[[1,5],[5,1]]</span><br><span class="line">解释：function_id = 2 表示 f(x, y) = x * y</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= function_id &lt;= 9</code></li>
<li><code>1 &lt;= z &lt;= 100</code></li>
<li>题目保证 <code>f(x, y) == z</code> 的解处于 <code>1 &lt;= x, y &lt;= 1000</code> 的范围内。</li>
<li>在 <code>1 &lt;= x, y &lt;= 1000</code> 的前提下，题目保证 <code>f(x, y)</code> 是一个 32 位有符号整数。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><ul>
<li><p>暴力法: </p>
<p>遍历所有可能的情况, 时间复杂度$O(N^2)$.</p>
</li>
<li><p>二分法:</p>
<p>遍历其中一个变量如<code>x</code>, 同时在每个<code>x</code>的值下二分查找<code>y</code>, 时间复杂度$O(N{\rm log}N)$.</p>
</li>
<li><p>二指针法:</p>
<p>两个指针分别代表<code>x</code>, <code>y</code>从两端开始, 根据当前结果, 进行改变:</p>
<ul>
<li><code>f(x,y) == z</code>: 记录结果, <code>x</code>加一, <code>y</code>减一.</li>
<li><code>f(x,y) &gt; z</code>: <code>y</code>减一.</li>
<li><code>f(x,y) &lt; z</code>: <code>x</code>加一.</li>
</ul>
<p>时间复杂度$O(N)$.</p>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSolution</span><span class="params">(self, customfunction, z)</span>:</span></span><br><span class="line">        res_list, x, y = [], <span class="number">1</span>, <span class="number">1000</span></span><br><span class="line">        <span class="keyword">while</span> x &lt;= <span class="number">1000</span> <span class="keyword">and</span> y &gt;= <span class="number">1</span>:</span><br><span class="line">            cur_z = customfunction.f(x, y)</span><br><span class="line">            <span class="keyword">if</span> cur_z == z:</span><br><span class="line">                res_list.append([x, y])</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur_z &gt; z:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-24</li>
<li>击败比例: 69.97%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Binary</category>
      </categories>
  </entry>
  <entry>
    <title>社交网络-组群发现</title>
    <url>/2020/05/23/%E5%9B%BE%E7%AE%97%E6%B3%95/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C-%E7%BB%84%E7%BE%A4%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>对于社交网络, 主要的研究与应用包括以下三个方面:</p>
<ul>
<li>信息推测.</li>
<li>组群发现.</li>
<li>消息传播.</li>
</ul>
<p>这里着重介绍一些组群发现的理论, 以及使用真实的数据进行试验.</p>
<a id="more"></a>
<h1 id="组群分类"><a href="#组群分类" class="headerlink" title="组群分类"></a>组群分类</h1><h2 id="显式组群-amp-隐式组群"><a href="#显式组群-amp-隐式组群" class="headerlink" title="显式组群 &amp; 隐式组群"></a>显式组群 &amp; 隐式组群</h2><p>在一般的社交网络中, 组群有显式与隐式之分.</p>
<p>比如在豆瓣网上的各种小组就属于<strong>显式群组</strong>.</p>
<p>而<strong>隐式群组</strong>, 是通过观察和分析节点之间的交互特征发现的群组. 比如通过一些人平时的通话记录, 来推断哪些人是朋友, 一起工作等.</p>
<p>这里所说的组群发现, 一般默认指的是隐式组群发现.</p>
<h2 id="可重叠组群-amp-不可重叠组群"><a href="#可重叠组群-amp-不可重叠组群" class="headerlink" title="可重叠组群 &amp; 不可重叠组群"></a>可重叠组群 &amp; 不可重叠组群</h2><p><img src="fig_0.png" alt="fig_0"></p>
<p>网络中的节点可以同时属于多个组群, 这样的组群称为<strong>可重叠组群</strong>.</p>
<p><img src="fig_1.png" alt="fig_1"></p>
<p>网络中的每个节点只属于一个组群, 组群之间没有共同节点, 则称为<strong>不可重叠组群</strong>.</p>
<h1 id="组群发现的意义"><a href="#组群发现的意义" class="headerlink" title="组群发现的意义"></a>组群发现的意义</h1><ul>
<li><p>单个节点.</p>
<p>通过组群发现, 将节点划分到了不同的团体, 可以通过整个团体的信息, 来对单个节点进行推测, 更好地理解单个节点.</p>
</li>
<li><p>群体.</p>
<p>有时候, 一些事实很难甚至无法通过单个节点看出来, 但是却能够从整体的行为中挖掘得到. 对于划分得到的组群, 它们之间的区别与联系可以通过划分结果进行分析.</p>
</li>
</ul>
<h1 id="组群发现算法"><a href="#组群发现算法" class="headerlink" title="组群发现算法"></a>组群发现算法</h1><ul>
<li><p>核心思想.</p>
<ol>
<li>高内聚: 组群内部节点之间交互密集.</li>
<li>低耦合: 组群之间的交互稀疏.</li>
</ol>
</li>
<li><p>组群发现 vs 聚类.</p>
<ul>
<li>聚类: 各数据点之间没有交互(连边), 根据节点的属性(如人的性别, 年龄, 学历等)来进行划分.</li>
<li>组群发现: 节点之间有交互(连边), 根据其交互行为来进行划分.</li>
</ul>
</li>
<li><p>经典算法Louvain.</p>
<ul>
<li><p>模块度(Modularity).</p>
<p>用以衡量组分划分的好坏的一个非常重要的指标, 越大说明划分效果越好. 计算公式为:</p>
<script type="math/tex; mode=display">
Q=\sum_i(组群_i内部的连边之和比例-组群_i连边之和比例的平方)</script><p>对于无向图, 一般看做有向图处理, 即一条无向连边, 等价于两条有向连边.</p>
<p><img src="fig_2.png" alt="fig_2"></p>
<p>|      |  C1  |  C2  |  C3  |<br>| :—: | :—: | :—: | :—: |<br>|  C1  |  6   |  0   |  1   |<br>|  C2  |  0   |  6   |  1   |<br>|  C3  |  1   |  1   |  8   |</p>
<script type="math/tex; mode=display">
Q=\frac{6+6+8}{2\times 12}-(\frac{6+1}{2\times 12})^2-(\frac{6+1}{2\times 12})^2-(\frac{8+1+1}{2\times 12})^2=0.49</script><p>一般Q值在0.3~0.7.</p>
</li>
<li><p>算法流程.</p>
<ol>
<li>将每个节点作为一个组群.</li>
<li>尝试将某个节点向邻近节点的组群合并, 计算合并后的模块度增量, 选择增加最大的组群进行移动. 若增量为负数, 则不移动. 遍历所有节点, 并循环处理, 当稳定时停止本次划分.</li>
<li>将现阶段组群看做一个节点, 组群内的边作为”新节点”的自环边, 同时边的权重为之前边的权重和. 再进行第二步.</li>
</ol>
<p>从算法可以看出, Louvain算法是一种层次型的组群发现, 可以得到一系列不同层次的组群以及对应的Q值. 最终可以选择最大的Q值划分, 最为最优划分.</p>
</li>
</ul>
<h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><p>对于Louvain算法, 在Github上有开源的包<a href="https://github.com/taynaud/python-louvain" target="_blank" rel="noopener">python-louvain</a>, 利用这个包来对网络进行组群划分.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> community  <span class="comment"># python-louvain 在调用时的名称为community</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edge_list_df = pd.read_csv(<span class="string">'network_links.csv'</span>)</span><br><span class="line">G = nx.from_pandas_edgelist(edge_list_df)</span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用best_partition将会得到最佳组群划分的一个字典, 其中key为节点, value为组群编号.</span></span><br><span class="line">node_group = community.best_partition(G)</span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到不同节点的组群编号列表.</span></span><br><span class="line">values = [node_group.get(node) <span class="keyword">for</span> node <span class="keyword">in</span> G.nodes()]</span><br><span class="line"><span class="comment">#对不同组群的节点进行不同着色.</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">nx.draw(G, cmap=plt.cm.RdYlBu, node_color=values, with_labels=<span class="literal">True</span>, edge_color=<span class="string">'gray'</span>, node_size=<span class="number">200</span>, pos=nx.spring_layout(G, k=<span class="number">0.2</span>, iterations=<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<p>  <img src="fig_3.png" alt="fig_3"></p>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>使用NetworkX分析网络</title>
    <url>/2020/05/23/%E5%9B%BE%E7%AE%97%E6%B3%95/%E4%BD%BF%E7%94%A8NetworkX%E5%88%86%E6%9E%90%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>NetworkX是一个Python包, 其中包含了丰富的与网络分析相关的方法, 对于中小型的网络来说, 用来进行分析是非常合适的.</p>
<p>这里将使用NetworkX包对一份网络数据进行构建, 绘图, 统计等, 以展示其基本功能.</p>
<a id="more"></a>
<h1 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">edge_list_df = pd.read_csv(<span class="string">'network_links.csv'</span>)</span><br><span class="line">edge_list_df.head()</span><br></pre></td></tr></table></figure>
<p><img src="fig_0.png" alt="fig_0"></p>
<p>这是以边表形式保存的数据, 其中<code>source</code>和<code>target</code>表示节点对, <code>value</code>表示边权重, 这里暂不考虑.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建网络对象.</span></span><br><span class="line">G = nx.from_pandas_edgelist(edge_list_df)</span><br></pre></td></tr></table></figure>
<h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p>对于NetworkX, 提供静态的可视化网络, 对于节点不是特别多的情况下, 使用可视化能够非常直观地了解网络.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">nx.draw(G, with_labels=<span class="literal">True</span>,</span><br><span class="line">        edge_color=<span class="string">'grey'</span>,</span><br><span class="line">        node_color=<span class="string">'blue'</span>,</span><br><span class="line">        node_size=<span class="number">10</span>,</span><br><span class="line">        pos=nx.spring_layout(G,k=<span class="number">0.2</span>,iterations=<span class="number">50</span>))</span><br></pre></td></tr></table></figure>
<p><img src="fig_1.png" alt="fig_1"></p>
<h1 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h1><ul>
<li><p>各节点度数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nx.degree(G)</span><br></pre></td></tr></table></figure>
<p><img src="fig_2.png" alt="fig_2"></p>
</li>
<li><p>节点中心性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 度数占比.</span></span><br><span class="line">nx.degree_centrality(G)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中介中心性.</span></span><br><span class="line">nx.betweenness_centrality(G)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接近中心性.</span></span><br><span class="line">nx.closeness_centrality(G)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征向量中心性.</span></span><br><span class="line">nx.eigenvector_centrality(G)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最大连通子图.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取出网络的最大子图</span></span><br><span class="line">Sub_G=G.subgraph(list(nx.connected_components(G))[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络平均聚类系数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算网络的聚类系数</span></span><br><span class="line">nx.average_clustering(G)</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络平均路径长度.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算网络的平均路径</span></span><br><span class="line">nx.average_shortest_path_length(G)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>Compare Strings by Frequency of the Smallest Character</title>
    <url>/2020/05/23/LeetCode/Compare-Strings-by-Frequency-of-the-Smallest-Character/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Let’s define a function <code>f(s)</code> over a non-empty string <code>s</code>, which calculates the frequency of the smallest character in <code>s</code>. For example, if <code>s = &quot;dcce&quot;</code> then <code>f(s) = 2</code> because the smallest character is <code>&quot;c&quot;</code> and its frequency is 2.</p>
<p>Now, given string arrays <code>queries</code> and <code>words</code>, return an integer array <code>answer</code>, where each <code>answer[i]</code> is the number of words such that <code>f(queries[i])</code> &lt; <code>f(W)</code>, where <code>W</code> is a word in <code>words</code>.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: On the first query we have f(&quot;cbd&quot;) = 1, f(&quot;zaaaz&quot;) = 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;).</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= queries.length &lt;= 2000</code></li>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= queries[i].length, words[i].length &lt;= 10</code></li>
<li><code>queries[i][j]</code>, <code>words[i][j]</code> are English lowercase letters.</li>
</ul>
<hr>
<p>我们来定义一个函数 <code>f(s)</code>，其中传入参数 <code>s</code> 是一个非空字符串；该函数的功能是统计 <code>s</code> 中（按字典序比较）最小字母的出现频次。</p>
<p>例如，若 <code>s = &quot;dcce&quot;</code>，那么 <code>f(s) = 2</code>，因为最小的字母是 <code>&quot;c&quot;</code>，它出现了 2 次。</p>
<p>现在，给你两个字符串数组待查表 <code>queries</code> 和词汇表 <code>words</code>，请你返回一个整数数组 <code>answer</code> 作为答案，其中每个 <code>answer[i]</code> 是满足 <code>f(queries[i])</code> &lt; <code>f(W)</code> 的词的数目，<code>W</code> 是词汇表 <code>words</code> 中的词。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]</span><br><span class="line">输出：[1]</span><br><span class="line">解释：查询 f(&quot;cbd&quot;) = 1，而 f(&quot;zaaaz&quot;) = 3 所以 f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;)。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：第一个查询 f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;)，第二个查询 f(&quot;aaa&quot;) 和 f(&quot;aaaa&quot;) 都 &gt; f(&quot;cc&quot;)。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= queries.length &lt;= 2000</code></li>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= queries[i].length, words[i].length &lt;= 10</code></li>
<li><code>queries[i][j]</code>, <code>words[i][j]</code> 都是小写英文字母</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>很简单, 就硬码就行了.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSmallerByFrequency</span><span class="params">(self, queries, words)</span>:</span></span><br><span class="line">        queries = [x.count(min(x)) <span class="keyword">for</span> x <span class="keyword">in</span> queries]</span><br><span class="line">        words = [x.count(min(x)) <span class="keyword">for</span> x <span class="keyword">in</span> words]</span><br><span class="line">        <span class="keyword">return</span> [sum([y &gt; x <span class="keyword">for</span> y <span class="keyword">in</span> words]) <span class="keyword">for</span> x <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-23</li>
<li>击败比例: 31.51%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Find Words That Can Be Formed by Characters</title>
    <url>/2020/05/22/LeetCode/Find-Words-That-Can-Be-Formed-by-Characters/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>You are given an array of strings <code>words</code> and a string <code>chars</code>.</p>
<p>A string is <em>good</em> if it can be formed by characters from <code>chars</code> (each character can only be used once).</p>
<p>Return the sum of lengths of all good strings in <code>words</code>.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">The strings that can be formed are &quot;cat&quot; and &quot;hat&quot; so the answer is 3 + 3 = 6.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: </span><br><span class="line">The strings that can be formed are &quot;hello&quot; and &quot;world&quot; so the answer is 5 + 5 = 10.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
<li>All strings contain lowercase English letters only.</li>
</ol>
<hr>
<p>给你一份『词汇表』（字符串数组） <code>words</code> 和一张『字母表』（字符串） <code>chars</code>。</p>
<p>假如你可以用 <code>chars</code> 中的『字母』（字符）拼写出 <code>words</code> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写（指拼写词汇表中的一个单词）时，<code>chars</code> 中的每个字母都只能用一次。</p>
<p>返回词汇表 <code>words</code> 中你掌握的所有单词的 <strong>长度之和</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
<li>所有字符串中都仅包含小写英文字母</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>利用<code>Counter</code>进行统计字符个数, 然后进行比较即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCharacters</span><span class="params">(self, words, chars)</span>:</span></span><br><span class="line">        counter = Counter(chars)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            res += len(word)</span><br><span class="line">            tmp_counter = Counter(word)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> tmp_counter:</span><br><span class="line">                <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> counter <span class="keyword">or</span> tmp_counter[k] &gt; counter[k]:</span><br><span class="line">                    res -= len(word)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-22</li>
<li>击败比例: 50.27%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>网络生成模型</title>
    <url>/2020/05/21/%E5%9B%BE%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>大多数时候, 我们可以去采集获取现实中真实的图结构的数据, 对其进行分析和研究.</p>
<p>而如果想通过一些方法, 来生成类似的数据, 可以怎么做呢? 如果一个相对简单的过程, 就能够生成与现实世界中非常相似的网络, 那么有如下好处:</p>
<ol>
<li>可以用生成的网络, 代替真实网络进行研究和实验.</li>
<li>可以更加清楚地了解真实世界网络的生成方式.</li>
</ol>
<a id="more"></a>
<h1 id="网络相似度衡量指标"><a href="#网络相似度衡量指标" class="headerlink" title="网络相似度衡量指标"></a>网络相似度衡量指标</h1><p>那么, 怎么知道生成的网络与真实世界网络之间是否相似呢? 需要一些衡量指标.</p>
<h2 id="节点度数分布"><a href="#节点度数分布" class="headerlink" title="节点度数分布"></a>节点度数分布</h2><p>首先是节点的度分布, 在现实世界中, 节点的度数分布通常服从幂律分布:</p>
<script type="math/tex; mode=display">
P_d=\alpha d^{-\beta}</script><p>其中$\alpha,\beta$均为参数, $d$为度数.</p>
<p>大多数节点的度数较小, 小部分节点的度数很大.</p>
<h2 id="聚类系数"><a href="#聚类系数" class="headerlink" title="聚类系数"></a>聚类系数</h2><p>以社交网络为例, A有两个朋友B和朋友C, 那么B和C本身可能也是朋友.</p>
<p>也就是说, 真实世界的网络一般具有不低的聚类系数.</p>
<h2 id="平均路径长度"><a href="#平均路径长度" class="headerlink" title="平均路径长度"></a>平均路径长度</h2><p>有一个著名的理论可能大家都听过, 叫做<strong>六度分隔</strong>理论, 或者也叫<strong>小世界</strong>理论. 大致就是说, 原本互不相识的人, 平均下来经过6个两两相识的人, 就能连接到一起.</p>
<p>而在真实的网络中, 平均路径长度可能比6还要小, 例如以前统计过, Facebook中用户的平均路径长度为4.7, YouTube为5.1.</p>
<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="随机网络"><a href="#随机网络" class="headerlink" title="随机网络"></a>随机网络</h2><p>随机网络模型, 指的是固定节点数, 对于所有可能存在的边, 以概率p决定是否出现.</p>
<p>在10个节点, 不同的p参数下, 随机网络的表现如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">概率p</th>
<th style="text-align:center">平均度数</th>
<th style="text-align:center">直径(最长距离)</th>
<th style="text-align:center">最大连通子图</th>
<th style="text-align:center">平均距离</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0.055</td>
<td style="text-align:center">0.8</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">0.11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">2.66</td>
</tr>
<tr>
<td style="text-align:center">1.0</td>
<td style="text-align:center">9</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p><img src="fig_0.png" alt="fig_0"></p>
<p>随着p的增加, 平均度数到达1附近时, 网络会发生”相变”. 其最大连通子图的大小, 会突然变大, 几乎囊括所有节点; 同时, 网络的直径也会达到最大, 但后续又会降低.</p>
<p>可以总结下随机网络的性质:</p>
<ul>
<li>平均度数小于1.<ul>
<li>分散的簇.</li>
<li>直径小.</li>
<li>平均路径长度小.</li>
</ul>
</li>
<li>平均度数约等于1.<ul>
<li>最大连通子图的大小会迅速增大.</li>
<li>直径最大.</li>
<li>平均路径长度大.</li>
</ul>
</li>
<li>平均度数大于1.<ul>
<li>几乎所有节点都被连接.</li>
<li>直径减小.</li>
<li>平均路径长度减小.</li>
</ul>
</li>
</ul>
<p>最后随机网络与真实的网络有哪些差别呢?</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">真实网络</th>
<th style="text-align:center">随机网络</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">度分布</td>
<td style="text-align:center">幂率分布</td>
<td style="text-align:center">泊松分布</td>
</tr>
<tr>
<td style="text-align:center">平均路径长度</td>
<td style="text-align:center">较短</td>
<td style="text-align:center">较短</td>
</tr>
<tr>
<td style="text-align:center">聚类系数</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说, 如果用随机网络来模拟真实网络, 那么除了平均路径长度, 在度分布以及聚类系数上都不符合.</p>
<h2 id="小世界网络"><a href="#小世界网络" class="headerlink" title="小世界网络"></a>小世界网络</h2><p>小世界网络也被称为WS(Watts-Strogatz)网络, 是一种进阶的随机模型.</p>
<p>生成小世界网络的过程如下:</p>
<ol>
<li><p>生成一个符合期望度数的规则网络.</p>
<p><img src="fig_1.png" alt="fig_1"></p>
</li>
<li><p>以概率p重连其中的某些边.</p>
<p><img src="fig_2.png" alt="fig_2"></p>
</li>
</ol>
<p>在不同的概率p下, 平均距离与聚类系数的变化如下图:</p>
<p><img src="fig_3.png" alt="fig_3"></p>
<p>可以看到, 随着p的增大, 在中间的一段区域, 聚类系数减小缓慢, 而平均距离减小很快, 选择合适的p, 可以获得高聚类系数与低平均距离的网络.</p>
<p>小世界网络与真实的网络对比:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">真实网络</th>
<th style="text-align:center">小世界网络</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">度分布</td>
<td style="text-align:center">幂率分布</td>
<td style="text-align:center">集中在期望度数附近</td>
</tr>
<tr>
<td style="text-align:center">平均路径长度</td>
<td style="text-align:center">较短</td>
<td style="text-align:center">较短</td>
</tr>
<tr>
<td style="text-align:center">聚类系数</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较大</td>
</tr>
</tbody>
</table>
</div>
<p>除了度分布, 小世界网络在平均路径长度与聚类系数上, 都可以较好地模拟真实网络.</p>
<h2 id="优先连接网络"><a href="#优先连接网络" class="headerlink" title="优先连接网络"></a>优先连接网络</h2><p>如何让生成的网络度分布符合幂率分布呢? 遵循富者更富的原则, 可以在生成网络时, 一个一个地加入节点, 对于新加入的节点, 更倾向于连接网络中度数较大的节点, 连接到节点$i$相对概率为:</p>
<script type="math/tex; mode=display">
p(v_i)=\frac{d_i}{\sum_j d_j}</script><p>优先连接网络与真实网络比较:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">真实网络</th>
<th style="text-align:center">优先连接网络</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">度分布</td>
<td style="text-align:center">幂率分布</td>
<td style="text-align:center">集中在期望度数附近</td>
</tr>
<tr>
<td style="text-align:center">平均路径长度</td>
<td style="text-align:center">较短</td>
<td style="text-align:center">较短</td>
</tr>
<tr>
<td style="text-align:center">聚类系数</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
</tr>
</tbody>
</table>
</div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上介绍了三种经典并简单的生成网络的方法, 它们相比真实网络, 都有一些不一样, 但同样有其价值.</p>
<p>与真实网络对比, 做一个总结:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">随机网络</th>
<th style="text-align:center">小世界网络</th>
<th style="text-align:center">优先连接网络</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">构造方式</td>
<td style="text-align:center">以概率随机连边</td>
<td style="text-align:center">以概率在规则网络随机重连边</td>
<td style="text-align:center">新加入节点优先连接高度数节点</td>
</tr>
<tr>
<td style="text-align:center">度分布</td>
<td style="text-align:center">不符合</td>
<td style="text-align:center">不符合</td>
<td style="text-align:center">符合</td>
</tr>
<tr>
<td style="text-align:center">聚类系数</td>
<td style="text-align:center">不符合</td>
<td style="text-align:center">符合</td>
<td style="text-align:center">不符合</td>
</tr>
<tr>
<td style="text-align:center">平均距离</td>
<td style="text-align:center">符合</td>
<td style="text-align:center">符合</td>
<td style="text-align:center">符合</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>节点的相似性</title>
    <url>/2020/05/21/%E5%9B%BE%E7%AE%97%E6%B3%95/%E8%8A%82%E7%82%B9%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7/</url>
    <content><![CDATA[<p>如何判断一个网络中, 某两个节点的相似性呢? 一般来说有两种方法:</p>
<ul>
<li>如果节点带有属性, 那么可以根据属性是否相似来衡量.</li>
<li>根据节点在网络中所处的位置.</li>
</ul>
<p>这里主要讲第二种方法.</p>
<a id="more"></a>
<h1 id="结构等价性-Structural-Equivalence"><a href="#结构等价性-Structural-Equivalence" class="headerlink" title="结构等价性(Structural Equivalence)"></a>结构等价性(Structural Equivalence)</h1><p>这种方法非常简单, 两个节点的共有邻居节点的数目定义了两个节点之间的相似程度.</p>
<p>公式为:</p>
<script type="math/tex; mode=display">
相似度(v_i, v_j)=v_i与v_j的共同邻居数量</script><p>此公式的一个问题是, 没有考虑到各个节点本身的度数, 比如同样都是10个共同的节点, 但一些节点的度数很高, 一些节点度数很低, 那么这种情况下是不能一概而论的.</p>
<p>因此需要做一些调整, 有两种进阶的计算方法:</p>
<ul>
<li><p>Jaccard Similarity</p>
<script type="math/tex; mode=display">
相似度(v_i, v_j)=\frac{v_i与v_j的共同邻居数量}{v_i与v_j的所有邻居数量}</script></li>
<li><p>Cosine Similarity</p>
<script type="math/tex; mode=display">
相似度(v_i, v_j)=\frac{v_i与v_j的共同邻居数量}{\sqrt{v_i邻居数量\times v_j邻居数量}}</script></li>
</ul>
<h1 id="规则等价性-Regular-Equivalence"><a href="#规则等价性-Regular-Equivalence" class="headerlink" title="规则等价性(Regular Equivalence)"></a>规则等价性(Regular Equivalence)</h1><p>在衡量等价性时, 不仅仅看相同的邻居, 对于不同的邻居也要看它们是否相似.</p>
<p>计算公式为:</p>
<script type="math/tex; mode=display">
\sigma(v_i, v_j)=\alpha\sum_{k.l}A_{i,k}A_{j,l}\sigma(v_k,v_l)</script><p><img src="fig_0.png" alt="fig_0"></p>
<p>显然这个计算方式相比结构等价性要复杂很多, 并且是利用迭代的方式进行计算的.</p>
<p>一种相对简单的近似算法如下:</p>
<script type="math/tex; mode=display">
\sigma(v_i, v_j)=\alpha\sum_{k}A_{i,k}\sigma(v_k,v_j)</script><p><img src="fig_1.png" alt="fig_1"></p>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>网络的传递性</title>
    <url>/2020/05/21/%E5%9B%BE%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%A0%E9%80%92%E6%80%A7/</url>
    <content><![CDATA[<h1 id="传递性-Transitivity"><a href="#传递性-Transitivity" class="headerlink" title="传递性(Transitivity)"></a>传递性(Transitivity)</h1><p>网络的传递性, 可以用于衡量一个网络中, 各个节点之间相互连通的程度. 在一些网络中, 节点倾向于相互孤立, 那么传递性就较差; 在一些网络中, 节点之间倾向于相互连接, 那么传递性一般就会高一些.</p>
<p>传递性的思想用一句通俗的话来说, 就是: 我朋友的朋友也是我的朋友.</p>
<a id="more"></a>
<p><img src="fig_0.png" alt="fig_0"></p>
<h1 id="聚集系数"><a href="#聚集系数" class="headerlink" title="聚集系数"></a>聚集系数</h1><p>那么, 如何定量地去刻画一个网络的传递性呢? 可以用到聚集系数, 其计算方法非常简单:</p>
<script type="math/tex; mode=display">
聚集系数=\frac{构成三角形的三元节点数量 \times 3}{连通的三元节点数量}</script><p>也就是说, 节点之间两两相互连接, 尽量构成更多的三角形, 那么就拥有更大的聚集系数, 也就拥有更高的传递性.</p>
<h1 id="结构平衡理论"><a href="#结构平衡理论" class="headerlink" title="结构平衡理论"></a>结构平衡理论</h1><p>这里再说一下与传递性相关的理论, 结构平衡理论, 同样用通俗的话来说就是:</p>
<ul>
<li>我朋友的朋友就是我朋友.</li>
<li>我朋友的敌人就是我敌人.</li>
<li>我敌人的敌人就是我朋友.</li>
<li>我敌人的朋友就是我敌人.</li>
</ul>
<p>在这样的理论下, 就会出现符合这种描述的网络结构, 称为平衡网络; 以及不符合这种描述的网络, 称为不平衡网络.</p>
<p><img src="fig_1.png" alt="fig_1"></p>
<p><img src="fig_2.png" alt="fig_2"></p>
<p>使用计算的方式判断网络是否平衡的方法:</p>
<p><img src="fig_3.png" alt="fig_3"></p>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>Maximum Number of Balloons</title>
    <url>/2020/05/21/LeetCode/Maximum-Number-of-Balloons/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a string <code>text</code>, you want to use the characters of <code>text</code> to form as many instances of the word <strong>“balloon”</strong> as possible.</p>
<p>You can use each character in <code>text</code> <strong>at most once</strong>. Return the maximum number of instances that can be formed.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/09/05/1536_ex1_upd.JPG" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;nlaebolko&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/09/05/1536_ex2_upd.JPG" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;loonbalxballpoon&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^4</code></li>
<li><code>text</code> consists of lower case English letters only.</li>
</ul>
<hr>
<p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。</p>
<p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 <strong>“balloon”</strong>。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex1_upd.jpeg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;nlaebolko&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex2_upd.jpeg" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;loonbalxballpoon&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;leetcode&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^4</code></li>
<li><code>text</code> 全部由小写英文字母组成</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>首先利用<code>Counter</code>统计各字母数量.</p>
<p>对于构成<code>balloon</code>的数量, 是由最少的字母的数量决定的.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfBalloons</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        counter = Counter(text)</span><br><span class="line">        b = counter[<span class="string">'b'</span>]</span><br><span class="line">        a = counter[<span class="string">'a'</span>]</span><br><span class="line">        l = counter[<span class="string">'l'</span>] // <span class="number">2</span></span><br><span class="line">        o = counter[<span class="string">'o'</span>] // <span class="number">2</span></span><br><span class="line">        n = counter[<span class="string">'n'</span>]</span><br><span class="line">        <span class="keyword">return</span> min(b, a, l, o, n)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-21</li>
<li>击败比例: 100.00%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>节点的中心性</title>
    <url>/2020/05/20/%E5%9B%BE%E7%AE%97%E6%B3%95/%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AD%E5%BF%83%E6%80%A7/</url>
    <content><![CDATA[<p>在一个由节点和边组成的网络中, 很多时候想知道哪些节点是相对重要的, 或者进一步对所有节点的重要性进行排序.</p>
<p>根据不同的场景需求, 可以选择不同的方式来度量节点的中心性(重要性).</p>
<a id="more"></a>
<h1 id="基于度数"><a href="#基于度数" class="headerlink" title="基于度数"></a>基于度数</h1><p>基于度数是非常自然的想法, 一个节点的度数越大, 通常是越重要的节点.</p>
<h2 id="点度中心性-Degree-Centrality"><a href="#点度中心性-Degree-Centrality" class="headerlink" title="点度中心性(Degree Centrality)"></a>点度中心性(Degree Centrality)</h2><p>直接利用度数的大小对节点中心性进行排序, 简单, 应用广泛, 可解释性强.</p>
<p><img src="fig_0.png" alt="fig_0"></p>
<p>但该方法显然存在明显的缺点, 邻居节点的重要性没有考虑. 因为在一些场景下, 可以通过非常规方式增加度数, 如一些社交平台上买假粉.</p>
<h2 id="特征向量中心性-Eigenvector-Centrality"><a href="#特征向量中心性-Eigenvector-Centrality" class="headerlink" title="特征向量中心性(Eigenvector Centrality)"></a>特征向量中心性(Eigenvector Centrality)</h2><p>于是, 在考虑某个节点中心性时, 也同时考虑其邻居节点的中心性. 不仅需要邻居节点多, 还需要邻居节点是重要的.</p>
<p>给定一个网络, 对应一个邻接矩阵$A$, 以及一个各节点度数向量$X$.</p>
<p>利用$AX$会得到什么呢? 得到一个新的向量$X$, 其中的每个值代表原本每个节点的邻居节点的度数(重要性)和.</p>
<p>经过反复迭代, 最终向量$X$会收敛稳定, 对于这种情况, 正是线性代数中的特征向量:</p>
<script type="math/tex; mode=display">
AX=\lambda X</script><p>其中$\lambda$是邻接矩阵$A$的特征根, $X$是对应的特征向量, 其各个值也就是各节点的中心性.</p>
<h2 id="PageRank-Centrality"><a href="#PageRank-Centrality" class="headerlink" title="PageRank Centrality"></a>PageRank Centrality</h2><p>特征向量中心性对于无向网络中心性的度量效果是较好的, 但是对于有向网络却并不适用.</p>
<p>下面介绍大名鼎鼎的PageRank算法.</p>
<p>PageRank的基本思想非常简单:</p>
<ol>
<li><p>预设一个阻尼系数$\beta$, 表示在一个页面上跳转到下一个页面的概率.</p>
</li>
<li><p>首先初始化所有节点的重要性为$(1-\beta)$.</p>
</li>
<li><p>每一次迭代时, 某个节点的重要性等于:</p>
<script type="math/tex; mode=display">
PR_i=(1-\beta)+\beta(\sum_{j\in I}PR_j/C_j)</script><p>其中, $PR_i$表示节点$i$在某一次迭代中的重要性, $I$表示连接向节点$i$的邻居节点, $C_j$表示节点$j$的出度.</p>
</li>
<li><p>当迭代后, 各节点前后重要性变化很小时, 停止迭代, 得到结果.</p>
</li>
</ol>
<p>以上就是PageRank的简单版流程, 同时考虑到了邻居节点的数量和重要性, 可以很好地对节点中心性进行排序.</p>
<h1 id="中介中心性-Betweenness-Centrality"><a href="#中介中心性-Betweenness-Centrality" class="headerlink" title="中介中心性(Betweenness Centrality)"></a>中介中心性(Betweenness Centrality)</h1><p>除了可以基于节点度数来进行衡量节点中心性外, 使用betweenness在一些场景下, 也是一种很好的方法.</p>
<p>中介中心性, 强调了某个节点作为”交通枢纽”的作用, 即如果该节点堵塞, 在网络流通将会受到较大影响.</p>
<p>假设要求某个节点$i$的中心性, 计算方式如下:</p>
<ol>
<li><p>计算网络中, 除了节点$i$外, 任意两两节点之间的最短路径.</p>
</li>
<li><p>统计有多少条最短路径经过节点$i$.</p>
</li>
<li><p>节点$i$中心性为:</p>
<script type="math/tex; mode=display">
中心性_i=\frac{经过节点i的最短路径数量}{除节点i的最短路径数量}</script></li>
</ol>
<h1 id="接近中心性-Closeness-Centrality"><a href="#接近中心性-Closeness-Centrality" class="headerlink" title="接近中心性(Closeness Centrality)"></a>接近中心性(Closeness Centrality)</h1><p>想象一种场景下, 需要找到一个节点作为初始点, 想周围扩散一些事物(如观点), 那应该怎样评价各节点的中心性呢?</p>
<p>很自然地想到, 利用平均最短距离进行衡量.</p>
<p>计算方式非常简单:</p>
<script type="math/tex; mode=display">
中心性_i=\frac{1}{平均最短距离_i} \\
平均最短距离_i=\frac{1}{n-1}\sum_{j\ne i}最短路径_{i,j}</script>]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>N-th Tribonacci Number</title>
    <url>/2020/05/20/LeetCode/N-th-Tribonacci-Number/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>The Tribonacci sequence Tn is defined as follows: </p>
<p>T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0.</p>
<p>Given <code>n</code>, return the value of Tn.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">T_3 = 0 + 1 + 1 = 2</span><br><span class="line">T_4 = 1 + 1 + 2 = 4</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 25</span><br><span class="line">Output: 1389537</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 37</code></li>
<li>The answer is guaranteed to fit within a 32-bit integer, ie. <code>answer &lt;= 2^31 - 1</code>.</li>
</ul>
<hr>
<p>泰波那契序列 Tn 定义如下： </p>
<p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p>
<p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">T_3 = 0 + 1 + 1 = 2</span><br><span class="line">T_4 = 1 + 1 + 2 = 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 25</span><br><span class="line">输出：1389537</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 37</code></li>
<li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题给到的类别是递归, 可以利用递归来做, 但没必要.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        fst, scd, trd = <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            fst, scd, trd = scd, trd, fst + scd + trd</span><br><span class="line">        <span class="keyword">return</span> trd</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>2020-05-20</li>
<li>击败比例: 99.82%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Recursion</category>
      </categories>
  </entry>
  <entry>
    <title>Defanging an IP Address</title>
    <url>/2020/05/19/LeetCode/Defanging-an-IP-Address/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>
<p>A <em>defanged IP address</em> replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: address = &quot;1.1.1.1&quot;</span><br><span class="line">Output: &quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: address = &quot;255.100.50.0&quot;</span><br><span class="line">Output: &quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>The given <code>address</code> is a valid IPv4 address.</li>
</ul>
<hr>
<p>给你一个有效的 <a href="https://baike.baidu.com/item/IPv4" target="_blank" rel="noopener">IPv4</a> 地址 <code>address</code>，返回这个 IP 地址的无效化版本。</p>
<p>所谓无效化 IP 地址，其实就是用 <code>&quot;[.]&quot;</code> 代替了每个 <code>&quot;.&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address = &quot;1.1.1.1&quot;</span><br><span class="line">输出：&quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address = &quot;255.100.50.0&quot;</span><br><span class="line">输出：&quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给出的 <code>address</code> 是一个有效的 IPv4 地址</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这……</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">'.'</span>, <span class="string">'[.]'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-19</li>
<li>击败比例: 14.91%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Relative Sort Array</title>
    <url>/2020/05/18/LeetCode/Relative-Sort-Array/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given two arrays <code>arr1</code> and <code>arr2</code>, the elements of <code>arr2</code> are distinct, and all elements in <code>arr2</code> are also in <code>arr1</code>.</p>
<p>Sort the elements of <code>arr1</code> such that the relative ordering of items in <code>arr1</code> are the same as in <code>arr2</code>. Elements that don’t appear in <code>arr2</code> should be placed at the end of <code>arr1</code> in <strong>ascending</strong> order.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</span><br><span class="line">Output: [2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>
<li>Each <code>arr2[i]</code> is distinct.</li>
<li>Each <code>arr2[i]</code> is in <code>arr1</code>.</li>
</ul>
<hr>
<p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p>
<ul>
<li><code>arr2</code> 中的元素各不相同</li>
<li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li>
</ul>
<p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>
<li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li>
<li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>使用<code>Counter</code>统计各数字的数量, 遍历<code>arr2</code>进行排序, 并每次查询后<code>pop</code>掉.</p>
<p>对于剩余的<code>key</code>, 利用<code>sorted</code>排序后拼接返回.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relativeSortArray</span><span class="params">(self, arr1, arr2)</span>:</span></span><br><span class="line">        counter = Counter(arr1)</span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr2:</span><br><span class="line">            res_list += [i] * counter[i]</span><br><span class="line">            counter.pop(i)</span><br><span class="line">        other_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> counter:</span><br><span class="line">            other_list += [i] * counter[i]</span><br><span class="line">        <span class="keyword">return</span> res_list + sorted(other_list)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-18</li>
<li>击败比例: 88.00%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>图基本概念</title>
    <url>/2020/05/17/%E5%9B%BE%E7%AE%97%E6%B3%95/%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个还只会一点皮毛的初学者, 在这里把自己的所学记录下来, 有问题的地方希望大家可以指点(暂时没开评论, 不过有邮箱~). 以后随着学习的深入, 可能还会对现在的文章进行编辑.</p>
<p>在我们的生活中, 各种学科中, 一些事物可以被抽象成的节点与连边的结构. 比如:</p>
<ul>
<li>人与人之间的社交, 每个人可以被看成一个节点, 两个人是否认识决定他们之间是否拥有连边, 这样可以构成一个网络, 称为社交网络.</li>
<li>互联网中, 网站可以作为节点, 超链接作为边.</li>
<li>在电商中, 用户与商品都可以作为节点, 用户是否购买商品可以作为边.</li>
</ul>
<a id="more"></a>
<p>节点与边组成的抽象网络, 学术上可以被称为<strong>复杂网络</strong>, 属于系统科学的一个重要部分. 围绕复杂网络展开的研究, 可以包括网络本身的一些静态性质, 如节点重要性等; 也可以包括网络的一些动态演变, 比如疾病传播等.</p>
<p>同时, 更进一步, 节点可以有自己的类别和属性, 边可以有方向, 也可以有属性, 这样就可以构成更加丰富的网络. 而基于这样一些丰富的网络, 可以用来做更多的分析与创造. 比如基于图结构的数据, 构建模型, 来进行预测或表示; 结合自然语言处理技术, 构建<strong>知识图谱</strong>, 也是可以大有作为的.</p>
<p>若想在一些现实问题中, 运用图算法相关的理论和工具, 有两个关键要点:</p>
<ol>
<li>如何将现实场景中的对象转化为网络结构.</li>
<li>选择合适的方法处理网络结构数据, 以获得期望的结果.</li>
</ol>
<p>谈到图, 或者图论, 都会提及<strong>柯尼斯堡七桥问题</strong>.</p>
<p><img src="fig_0.png" alt="fig_0"></p>
<p>问题是能否每座桥只经过一次, 遍历所有桥? 经过大神欧拉的一顿操作, 证明这是不可能的, 同时还对这一类问题做了总结和抽象: 对于连通有限图, 度数为奇数的节点, 数量只能为0或者2, 只有这样才能所有边都经过且只经过一次.</p>
<p>这里的度数, 就是节点的连边数量. 通俗地理解, 就是一个节点, 由一条边到达, 必然需要另一条边离开, 所以需要偶数的度数. 除非这个节点作为起点或者终点.</p>
<h1 id="图的基本结构"><a href="#图的基本结构" class="headerlink" title="图的基本结构"></a>图的基本结构</h1><h2 id="节点-amp-边"><a href="#节点-amp-边" class="headerlink" title="节点 &amp; 边"></a>节点 &amp; 边</h2><p>节点与边是组成图的基本单元.</p>
<p><img src="fig_1.png" alt="fig_1"></p>
<h2 id="有向图-amp-无向图"><a href="#有向图-amp-无向图" class="headerlink" title="有向图 &amp; 无向图"></a>有向图 &amp; 无向图</h2><p>根据边是否带有方向(指向性), 可以把图划分为有向图和无向图.</p>
<p><img src="fig_2.png" alt="fig_2"></p>
<h2 id="度数"><a href="#度数" class="headerlink" title="度数"></a>度数</h2><p>节点的度数指的是其周围边的数量, 如果是有向图, 那么还可以细分为<strong>出度</strong>和<strong>入度</strong>.</p>
<p><img src="fig_3.png" alt="fig_3"></p>
<p><img src="fig_4.png" alt="fig_4"></p>
<h2 id="度数分布"><a href="#度数分布" class="headerlink" title="度数分布"></a>度数分布</h2><p>度数的分布指的是具有不同度数的节点, 其数量在整体节点中的占比.</p>
<p><img src="fig_5.png" alt="fig_5"></p>
<p>与其它一些场景下, 经常出现正态分布不一样, 在显示中的不少网络, 其度数分布服从幂律分布, 即绝大部分节点的度数较小, 极少部分节点度数很大.</p>
<h1 id="计算机储存图的方法"><a href="#计算机储存图的方法" class="headerlink" title="计算机储存图的方法"></a>计算机储存图的方法</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><img src="fig_6.png" alt="fig_6"></p>
<p>在一个正方矩阵中, 行列数目等于节点数目, 格点数值1表示对应两个节点相连, 或者其中一个节点连向另外一个节点.</p>
<p>如果是无向图, 那么是对称矩阵.</p>
<p>用邻接矩阵, 有一些问题:</p>
<ul>
<li><p>通常非常稀疏, 即大量格点为0.</p>
</li>
<li><p>若节点较多, 则会耗费大量储存空间.</p>
</li>
</ul>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>只记录相互连接的节点与边的信息, 相比邻接矩阵, 可以节省很多空间.</p>
<p><img src="fig_7.png" alt="fig_7"></p>
<p><img src="fig_8.png" alt="fig_8"></p>
<p>并且具体的储存方式可以根据有向图, 还是无向图进行调整.</p>
<p>其优点是便于查询每个节点的连接情况, 缺点是数据仍然存在冗余.</p>
<h2 id="边表"><a href="#边表" class="headerlink" title="边表"></a>边表</h2><p>只储存边, 其占用空间最小, 是当前比较常用的储存方式.</p>
<p>边表中一条数据, 代表一条边. 在有向图中, 代表一个节点指向另一个节点.</p>
<p><img src="fig_9.png" alt="fig_9"></p>
<p><img src="fig_10.png" alt="fig_10"></p>
]]></content>
      <categories>
        <category>图算法</category>
      </categories>
  </entry>
  <entry>
    <title>Count Negative Numbers in a Sorted Matrix</title>
    <url>/2020/05/17/LeetCode/Count-Negative-Numbers-in-a-Sorted-Matrix/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a <code>m * n</code> matrix <code>grid</code> which is sorted in non-increasing order both row-wise and column-wise. </p>
<p>Return the number of <strong>negative</strong> numbers in <code>grid</code>.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: There are 8 negatives number in the matrix.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid = [[3,2],[1,0]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid = [[1,-1],[-1,-1]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid = [[-1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<hr>
<p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 </p>
<p>请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]</span><br><span class="line">输出：8</span><br><span class="line">解释：矩阵中共有 8 个负数。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[3,2],[1,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,-1],[-1,-1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[-1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>根据题意, 矩阵左上角的值应该是整个矩阵中最大的值, 右下角是整个矩阵中最小的值.</p>
<p>要想统计有多少负数, 若遍历统计, 则时间复杂度为$O(m\times n)$.</p>
<p>一种优化的方法是找到正负数的”分割线”, 即左上部分存在非负数板块, 右下部分存在负数板块. 可以从左下角开始, 横纵交替地寻找”分割线”. 时间复杂度为$O(m+n)$.</p>
<p>用到的技巧是, 从<code>[n_row - 1, -1]</code>位置开始, 若右边为非负数, 则右移; 否则上移. 保证遍历所有行, 用一个字典记录每行的最大列. 字典中保存的信息即为”分割线”.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNegatives</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        n_row = len(grid)</span><br><span class="line">        n_col = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n_row * n_col</span><br><span class="line"></span><br><span class="line">        row, col = n_row - <span class="number">1</span>, <span class="number">-1</span></span><br><span class="line">        info_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; n_col:</span><br><span class="line">            info_dict[row] = col</span><br><span class="line">            <span class="keyword">if</span> col + <span class="number">1</span> &lt; n_col <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                row -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum([n_col - v - <span class="number">1</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> info_dict.items()])</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-17</li>
<li>击败比例: 80.28%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Find Numbers with Even Number of Digits</title>
    <url>/2020/05/16/LeetCode/Find-Numbers-with-Even-Number-of-Digits/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given an array <code>nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [12,345,2,6,7896]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">12 contains 2 digits (even number of digits). </span><br><span class="line">345 contains 3 digits (odd number of digits). </span><br><span class="line">2 contains 1 digit (odd number of digits). </span><br><span class="line">6 contains 1 digit (odd number of digits). </span><br><span class="line">7896 contains 4 digits (even number of digits). </span><br><span class="line">Therefore only 12 and 7896 contain an even number of digits.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [555,901,482,1771]</span><br><span class="line">Output: 1 </span><br><span class="line">Explanation: </span><br><span class="line">Only 1771 contains an even number of digits.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<hr>
<p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [12,345,2,6,7896]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">12 是 2 位数字（位数为偶数） </span><br><span class="line">345 是 3 位数字（位数为奇数）  </span><br><span class="line">2 是 1 位数字（位数为奇数） </span><br><span class="line">6 是 1 位数字 位数为奇数） </span><br><span class="line">7896 是 4 位数字（位数为偶数）  </span><br><span class="line">因此只有 12 和 7896 是位数为偶数的数字</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [555,901,482,1771]</span><br><span class="line">输出：1 </span><br><span class="line">解释： </span><br><span class="line">只有 1771 是位数为偶数的数字。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>嗯, 太简单…</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> len(str(x)) % <span class="number">2</span> == <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-16</li>
<li>击败比例: 76.46%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Number of Days Between Two Dates</title>
    <url>/2020/05/15/LeetCode/Number-of-Days-Between-Two-Dates/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Write a program to count the number of days between two dates.</p>
<p>The two dates are given as strings, their format is <code>YYYY-MM-DD</code> as shown in the examples.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;</span><br><span class="line">Output: 15</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>The given dates are valid dates between the years <code>1971</code> and <code>2100</code>.</li>
</ul>
<hr>
<p>请你编写一个程序来计算两个日期之间隔了多少天。</p>
<p>日期以字符串形式给出，格式为 <code>YYYY-MM-DD</code>，如示例所示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;</span><br><span class="line">输出：15</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定的日期是 <code>1971</code> 年到 <code>2100</code> 年之间的有效日期。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>嗯这里我懒得去想原始的解决方案了, 因为现在时间库一般是大部分编程语言的内置基本库, 所以直接使用就好~</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">daysBetweenDates</span><span class="params">(self, date1, date2)</span>:</span></span><br><span class="line">        date1 = datetime.strptime(date1, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        date2 = datetime.strptime(date2, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">        <span class="keyword">return</span> abs((date1 - date2).days)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-15</li>
<li>击败比例: 47.79%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>How Many Numbers Are Smaller Than the Current Number</title>
    <url>/2020/05/14/LeetCode/How-Many-Numbers-Are-Smaller-Than-the-Current-Number/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code>you have to count the number of valid <code>j&#39;s</code> such that <code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>
<p>Return the answer in an array.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [8,1,2,2,3]</span><br><span class="line">Output: [4,0,1,1,3]</span><br><span class="line">Explanation: </span><br><span class="line">For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). </span><br><span class="line">For nums[1]=1 does not exist any smaller number than it.</span><br><span class="line">For nums[2]=2 there exist one smaller number than it (1). </span><br><span class="line">For nums[3]=2 there exist one smaller number than it (1). </span><br><span class="line">For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [6,5,4,8]</span><br><span class="line">Output: [2,1,0,3]</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [7,7,7,7]</span><br><span class="line">Output: [0,0,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<hr>
<p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p>
<p>以数组形式返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]=1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]=2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]=2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题比较简单, 不过利用一些方法可以实现加速:</p>
<ul>
<li>利用<code>Counter</code>类来进行计数, 得到一个字典, <code>key</code>是数值, <code>value</code>是该数值的数量.</li>
<li>对<code>key</code>进行排序.</li>
<li>对排序后的<code>value</code>进行累加, 即可得到每个数值对应的返回值.</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        counter = Counter(nums)</span><br><span class="line">        k_v_list = sorted([(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> counter.items()], key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        info_dict = &#123;&#125;</span><br><span class="line">        cum_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> k_v_list:</span><br><span class="line">            info_dict[k] = cum_sum</span><br><span class="line">            cum_sum += v</span><br><span class="line">        <span class="keyword">return</span> [info_dict[x] <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-14</li>
<li>击败比例: 96.58%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/05/13/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式(regular expression)描述了一种字符串匹配的模式(pattern), 利用这种模式, 可以判断某字符串中是否包含可匹配的子字符串; 可以对匹配到的字符串进行移除, 替换等操作.</p>
<a id="more"></a>
<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>最简单最基本的匹配方式, 就是直接逐位进行匹配.</p>
<p>例如正则表达式为<code>the</code>, 则会去尝试匹配<code>the</code>.</p>
<p>同时, 基本匹配是大小写敏感的.</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>复杂一些的正则表达式, 需要<strong>元字符</strong>来参与.</p>
<p>元字符不代表他们本身的字面意思, 都有特殊的含义. 同时一些元字符写在方括号中的时候会转变用法. 以下是元字符的介绍:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">句号匹配任意单个字符, 除了换行符.</td>
</tr>
<tr>
<td style="text-align:center"><code>[]</code></td>
<td style="text-align:center">匹配方括号内的任意字符.</td>
</tr>
<tr>
<td style="text-align:center"><code>[^]</code></td>
<td style="text-align:center">匹配除了方括号内的任意字符.</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">匹配*前的字符0到多次.</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">匹配+前的字符1到多次.</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">标记?之前的字符为可选.</td>
</tr>
<tr>
<td style="text-align:center"><code>{m, n}</code></td>
<td style="text-align:center">匹配<code>num</code>个大括号之前的字符或者字符集<code>(m &lt;= num &lt;= n)</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>(xyz)</code></td>
<td style="text-align:center">字符集, 匹配与<code>xyz</code>完全相同的字符串.</td>
</tr>
<tr>
<td style="text-align:center"><code>竖线</code></td>
<td style="text-align:center">或运算符, 匹配符合前或后的字符(由于显示问题, 以中文示意).</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:center">转义字符, 将字符特殊用法消除或者赋予特殊用法.</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">从开始进行匹配.</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">从末端进行匹配.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式提供一些常用的字符集简写, 如下表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">除换行符外的所有字符.</td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">匹配所有字母数字, 等价于<code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\W</code></td>
<td style="text-align:center">匹配所有非字母数字, 即符号, 等价于<code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">匹配数字, 等价于<code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\D</code></td>
<td style="text-align:center">匹配非数字, 等价于<code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">匹配所有空格字符, 等价于<code>[\t\n\f\r]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">匹配一个换页符.</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">匹配一个换行符.</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">匹配一个回车符</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">匹配一个制表符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="前后预查"><a href="#前后预查" class="headerlink" title="前后预查"></a>前后预查</h2><p>在进行匹配的时候, 还要检查匹配字符串前或后的字符串是否满足指定的模式.</p>
<p>一般配合<code>()</code>使用.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>?=</code></td>
<td style="text-align:center">后面存在</td>
</tr>
<tr>
<td style="text-align:center"><code>?!</code></td>
<td style="text-align:center">后面不存在</td>
</tr>
<tr>
<td style="text-align:center"><code>?&lt;=</code></td>
<td style="text-align:center">前面存在</td>
</tr>
<tr>
<td style="text-align:center"><code>?&lt;!</code></td>
<td style="text-align:center">前面不存在</td>
</tr>
</tbody>
</table>
</div>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也可以称作修正符, 用以控制搜索及返回结果的模式.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center">忽略大小写.</td>
</tr>
<tr>
<td style="text-align:center"><code>g</code></td>
<td style="text-align:center">全局搜索.</td>
</tr>
<tr>
<td style="text-align:center"><code>m</code></td>
<td style="text-align:center">多行修饰符, 让<code>^</code>与<code>$</code>工作范围在每行的起始.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="贪婪匹配-amp-惰性匹配"><a href="#贪婪匹配-amp-惰性匹配" class="headerlink" title="贪婪匹配 &amp; 惰性匹配"></a>贪婪匹配 &amp; 惰性匹配</h2><p>正则表达式默认采用的贪婪匹配模式, 在该模式下会匹配尽可能长的字符串.</p>
<p>使用<code>?</code>将贪婪匹配转换为惰性匹配, 常配合<code>*</code>, <code>+</code>等元字符使用.</p>
<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>在Python中的re模块是用来专门处理正则表达式的, 下面介绍一下基础的常用方法.</p>
<h2 id="match-amp-search"><a href="#match-amp-search" class="headerlink" title="match &amp; search"></a>match &amp; search</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>match</code>可用于从一开始进行匹配, 若没有匹配到结果, 则返回<code>None</code>.</p>
<p><code>search</code>与<code>match</code>非常相似, 只是它可以从任意位置开始匹配.</p>
<p>参数说明:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>pattern</code></td>
<td style="text-align:center">正则表达式.</td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center">要匹配的字符串.</td>
</tr>
<tr>
<td style="text-align:center"><code>flag</code></td>
<td style="text-align:center">标志位, 用于控制正则表达式的匹配方式.</td>
</tr>
</tbody>
</table>
</div>
<p>可选标志位:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>re.I</code></td>
<td style="text-align:center">忽略大小写.</td>
</tr>
<tr>
<td style="text-align:center"><code>re.M</code></td>
<td style="text-align:center">多行匹配, 影响<code>^</code>和<code>$</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>re.S</code></td>
<td style="text-align:center">使<code>.</code>匹配包含换行符在内的所有字符.</td>
</tr>
<tr>
<td style="text-align:center"><code>re.L</code></td>
<td style="text-align:center">由当前环境解析字符, 影响<code>\w, \W, \B, \b</code>, 不推荐使用.</td>
</tr>
<tr>
<td style="text-align:center"><code>re.U</code></td>
<td style="text-align:center">由Unicode字符集解析字符.</td>
</tr>
<tr>
<td style="text-align:center"><code>re.X</code></td>
<td style="text-align:center">这个标记允许你编写更具可读性更友好的正则表达式.</td>
</tr>
</tbody>
</table>
</div>
<p>常用的是忽略大小写以及多行匹配.</p>
<p>返回结果为匹配对象:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">匹配对象方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>group(num=0)</code></td>
<td style="text-align:center">返回匹配到的整个字符串. 可以通过输入1及以上的单个或多个数字, 来获取对应模式的小组的字符串.</td>
</tr>
<tr>
<td style="text-align:center"><code>groups()</code></td>
<td style="text-align:center">返回一个包含所有小组字符串的元组.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>sub</code>可用于替换给定字符串中匹配项.</p>
<p>参数说明:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>pattern</code></td>
<td style="text-align:center">正则表达式.</td>
</tr>
<tr>
<td style="text-align:center"><code>repl</code></td>
<td style="text-align:center">用于替换的字符串, 也可以是函数.</td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center">要匹配的字符串.</td>
</tr>
<tr>
<td style="text-align:center"><code>count</code></td>
<td style="text-align:center">匹配替换的最大次数, 默认0表示全部替换.</td>
</tr>
<tr>
<td style="text-align:center"><code>flag</code></td>
<td style="text-align:center">标志位, 用于控制正则表达式的匹配方式.</td>
</tr>
</tbody>
</table>
</div>
<p>举个栗子来说明<code>repl</code>为函数时的情形:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将匹配的数字乘于2.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(s)</span>:</span></span><br><span class="line">    value = int(s.group())</span><br><span class="line">    <span class="keyword">return</span> str(value * <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">string_ = <span class="string">'aaa123bbb234'</span></span><br><span class="line">print(re.sub(<span class="string">'\d+'</span>, func, string_))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa246bbb468</span><br></pre></td></tr></table></figure>
<h2 id="findall-amp-finditer"><a href="#findall-amp-finditer" class="headerlink" title="findall &amp; finditer"></a>findall &amp; finditer</h2><p>利用<code>match</code>与<code>search</code>进行匹配时, 只能匹配一个结果.</p>
<p>而<code>findall</code>与<code>finditer</code>可以返回所有匹配项, 根据不同情况选择使用. 相比<code>findall</code>一次性返回所有结果, <code>finditer</code>返回一个迭代器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>其中的参数, 与前面方法相同.</p>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>与字符串的<code>split</code>方法类似, 将匹配项作为分割边界, 返回分割后的结果.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.split(pattern, string, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>其中的<code>maxsplit</code>参数表示最大分割次数, 其余参数与前面方法相同.</p>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
  </entry>
  <entry>
    <title>Distribute Candies to People</title>
    <url>/2020/05/13/LeetCode/Distribute-Candies-to-People/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We distribute some number of <code>candies</code>, to a row of <strong><code>n = num_people</code></strong> people in the following way:</p>
<p>We then give 1 candy to the first person, 2 candies to the second person, and so on until we give <code>n</code> candies to the last person.</p>
<p>Then, we go back to the start of the row, giving <code>n + 1</code> candies to the first person, <code>n + 2</code> candies to the second person, and so on until we give <code>2 * n</code> candies to the last person.</p>
<p>This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).</p>
<p>Return an array (of length <code>num_people</code> and sum <code>candies</code>) that represents the final distribution of candies.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candies = 7, num_people = 4</span><br><span class="line">Output: [1,2,3,1]</span><br><span class="line">Explanation:</span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3,0].</span><br><span class="line">On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: candies = 10, num_people = 3</span><br><span class="line">Output: [5,2,3]</span><br><span class="line">Explanation: </span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3].</span><br><span class="line">On the fourth turn, ans[0] += 4, and the final array is [5,2,3].</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>1 &lt;= candies &lt;= 10^9</li>
<li>1 &lt;= num_people &lt;= 1000</li>
</ul>
<hr>
<p>排排坐，分糖果。</p>
<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code> 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n + 1</code> 颗糖果，第二个小朋友 <code>n + 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code> 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies = 7, num_people = 4</span><br><span class="line">输出：[1,2,3,1]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] += 1，数组变为 [1,0,0,0]。</span><br><span class="line">第二次，ans[1] += 2，数组变为 [1,2,0,0]。</span><br><span class="line">第三次，ans[2] += 3，数组变为 [1,2,3,0]。</span><br><span class="line">第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies = 10, num_people = 3</span><br><span class="line">输出：[5,2,3]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] += 1，数组变为 [1,0,0]。</span><br><span class="line">第二次，ans[1] += 2，数组变为 [1,2,0]。</span><br><span class="line">第三次，ans[2] += 3，数组变为 [1,2,3]。</span><br><span class="line">第四次，ans[0] += 4，最终数组变为 [5,2,3]。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candies &lt;= 10^9</code></li>
<li><code>1 &lt;= num_people &lt;= 1000</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>如果正常按照小朋友一个一个轮流发, 直到糖果发完为止, 那么时间复杂度较大.</p>
<p>每一轮发的糖果是一个差为1的等差数列, 可以很方便地计算出和. 可以先确定出糖果到第几轮发完, 然后再模拟最后一轮的情形.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies, num_people)</span>:</span></span><br><span class="line">        sum_ = (<span class="number">1</span> + num_people) * num_people // <span class="number">2</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> candies &gt;= sum_ + (n - <span class="number">1</span>) * num_people**<span class="number">2</span>:</span><br><span class="line">            candies -= sum_ + (n - <span class="number">1</span>) * num_people**<span class="number">2</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        res_list = [<span class="number">0</span>] * num_people</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            res_list = [x[<span class="number">1</span>] + x[<span class="number">0</span>] + <span class="number">1</span> + i * num_people <span class="keyword">for</span> x <span class="keyword">in</span> enumerate(res_list)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            candy = (n - <span class="number">1</span>) * num_people + i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> candies &gt; candy:</span><br><span class="line">                res_list[i] += candy</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                candies -= candy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res_list[i] += candies</span><br><span class="line">                <span class="keyword">return</span> res_list</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-13</li>
<li>击败比例: 97.89%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>PySpark学习笔记(三)</title>
    <url>/2020/05/11/%E5%A4%A7%E6%95%B0%E6%8D%AE/PySpark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<p>这一篇中, 将在泰坦尼克数据集(可以在kaggle上下载)上, 利用PySpark进行处理与建模.</p>
<a id="more"></a>
<h1 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">                    .master(<span class="string">'local'</span>) \</span><br><span class="line">                    .appName(<span class="string">'titanic'</span>) \</span><br><span class="line">                    .getOrCreate()</span><br></pre></td></tr></table></figure>
<h1 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.read.csv(<span class="string">'./data/train.csv'</span>, header=<span class="literal">True</span>, inferSchema=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(df.count())</span><br><span class="line">print(df.printSchema())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">891</span><br><span class="line">root</span><br><span class="line"> |-- PassengerId: integer (nullable = true)</span><br><span class="line"> |-- Survived: integer (nullable = true)</span><br><span class="line"> |-- Pclass: integer (nullable = true)</span><br><span class="line"> |-- Name: string (nullable = true)</span><br><span class="line"> |-- Sex: string (nullable = true)</span><br><span class="line"> |-- Age: double (nullable = true)</span><br><span class="line"> |-- SibSp: integer (nullable = true)</span><br><span class="line"> |-- Parch: integer (nullable = true)</span><br><span class="line"> |-- Ticket: string (nullable = true)</span><br><span class="line"> |-- Fare: double (nullable = true)</span><br><span class="line"> |-- Cabin: string (nullable = true)</span><br><span class="line"> |-- Embarked: string (nullable = true)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    print(df[[col]].describe().show())</span><br></pre></td></tr></table></figure>
<h1 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">'Survived'</span>).count().show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------+-----+</span><br><span class="line">|Survived|count|</span><br><span class="line">+--------+-----+</span><br><span class="line">|       1|  342|</span><br><span class="line">|       0|  549|</span><br><span class="line">+--------+-----+</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">'Sex'</span>).avg(<span class="string">'Survived'</span>).sort(<span class="string">'avg(Survived)'</span>).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+-------------------+</span><br><span class="line">|   Sex|      avg(Survived)|</span><br><span class="line">+------+-------------------+</span><br><span class="line">|  male|0.18890814558058924|</span><br><span class="line">|female| 0.7420382165605095|</span><br><span class="line">+------+-------------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">'Pclass'</span>).avg(<span class="string">'Survived'</span>).sort(<span class="string">'avg(Survived)'</span>).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+-------------------+</span><br><span class="line">|Pclass|      avg(Survived)|</span><br><span class="line">+------+-------------------+</span><br><span class="line">|     3|0.24236252545824846|</span><br><span class="line">|     2|0.47282608695652173|</span><br><span class="line">|     1| 0.6296296296296297|</span><br><span class="line">+------+-------------------+</span><br></pre></td></tr></table></figure>
<h1 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h1><p>查看哪些列有缺失值, 缺失多少数量.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">null_value_count</span><span class="params">(df)</span>:</span></span><br><span class="line">    null_columns_counts = []</span><br><span class="line">    numRows = df.count()</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">        nullRows = df.where(df[col].isNull()).count()</span><br><span class="line">        <span class="keyword">if</span>(nullRows &gt; <span class="number">0</span>):</span><br><span class="line">            temp = col, nullRows</span><br><span class="line">            null_columns_counts.append(temp)</span><br><span class="line">    <span class="keyword">return</span> null_columns_counts</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">null_columns_count_list = null_value_count(df)</span><br><span class="line">spark.createDataFrame(null_columns_count_list, [<span class="string">'Column_With_Null_Value'</span>, <span class="string">'Null_Values_Count'</span>]).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------------+-----------------+</span><br><span class="line">|Column_With_Null_Value|Null_Values_Count|</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">|                   Age|              177|</span><br><span class="line">|                 Cabin|              687|</span><br><span class="line">|              Embarked|                2|</span><br><span class="line">+----------------------+-----------------+</span><br></pre></td></tr></table></figure>
<p>发现有3列缺失, 且缺失程度不同.</p>
<p>根据缺失程度的不同, 这里采取不同的处理方式. 对于<code>Cabin</code>, 缺失过多, 直接删除. 对于<code>Embarked</code>, 缺失很少, 可使用众数填充. 对于<code>Age</code>, 小部分缺失, 如果直接使用均值填充, 在这里不太好, 注意到有一列<code>Name</code>, 其中有一些称谓如<code>Mr</code>, 可以反映一个人的年龄, 所以可以结合其它信息进行填充.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">'Name'</span>]].show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|                Name|</span><br><span class="line">+--------------------+</span><br><span class="line">|Braund, Mr. Owen ...|</span><br><span class="line">|Cumings, Mrs. Joh...|</span><br><span class="line">|Heikkinen, Miss. ...|</span><br><span class="line">|Futrelle, Mrs. Ja...|</span><br><span class="line">|Allen, Mr. Willia...|</span><br><span class="line">|    Moran, Mr. James|</span><br><span class="line">|McCarthy, Mr. Tim...|</span><br><span class="line">|Palsson, Master. ...|</span><br><span class="line">|Johnson, Mrs. Osc...|</span><br><span class="line">|Nasser, Mrs. Nich...|</span><br><span class="line">|Sandstrom, Miss. ...|</span><br><span class="line">|Bonnell, Miss. El...|</span><br><span class="line">|Saundercock, Mr. ...|</span><br><span class="line">|Andersson, Mr. An...|</span><br><span class="line">|Vestrom, Miss. Hu...|</span><br><span class="line">|Hewlett, Mrs. (Ma...|</span><br><span class="line">|Rice, Master. Eugene|</span><br><span class="line">|Williams, Mr. Cha...|</span><br><span class="line">|Vander Planke, Mr...|</span><br><span class="line">|Masselmani, Mrs. ...|</span><br><span class="line">+--------------------+</span><br><span class="line">only showing top 20 rows</span><br></pre></td></tr></table></figure>
<p>使用正则表达式, 将<code>Name</code>中的称谓提取出来.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> regexp_extract</span><br><span class="line">df = df.withColumn(<span class="string">"Initial"</span>,regexp_extract(df[<span class="string">"Name"</span>], <span class="string">"([A-Za-z]+)\."</span>, <span class="number">1</span>))</span><br><span class="line">df[[<span class="string">'Initial'</span>]].distinct().show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| Initial|</span><br><span class="line">+--------+</span><br><span class="line">|     Don|</span><br><span class="line">|    Miss|</span><br><span class="line">|Countess|</span><br><span class="line">|     Col|</span><br><span class="line">|     Rev|</span><br><span class="line">|    Lady|</span><br><span class="line">|  Master|</span><br><span class="line">|     Mme|</span><br><span class="line">|    Capt|</span><br><span class="line">|      Mr|</span><br><span class="line">|      Dr|</span><br><span class="line">|     Mrs|</span><br><span class="line">|     Sir|</span><br><span class="line">|Jonkheer|</span><br><span class="line">|    Mlle|</span><br><span class="line">|   Major|</span><br><span class="line">|      Ms|</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>
<p>有一些不同的称谓, 其实表达的是同一个意思, 因此这里进行整合.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.replace([<span class="string">'Mlle'</span>,<span class="string">'Mme'</span>, <span class="string">'Ms'</span>, <span class="string">'Dr'</span>,<span class="string">'Major'</span>,<span class="string">'Lady'</span>,<span class="string">'Countess'</span>,<span class="string">'Jonkheer'</span>,<span class="string">'Col'</span>,<span class="string">'Rev'</span>,<span class="string">'Capt'</span>,<span class="string">'Sir'</span>,<span class="string">'Don'</span>],</span><br><span class="line">            [<span class="string">'Miss'</span>,<span class="string">'Miss'</span>,<span class="string">'Miss'</span>,<span class="string">'Mr'</span>,<span class="string">'Mr'</span>,  <span class="string">'Mrs'</span>,  <span class="string">'Mrs'</span>,  <span class="string">'Other'</span>,  <span class="string">'Other'</span>,<span class="string">'Other'</span>,<span class="string">'Mr'</span>,<span class="string">'Mr'</span>,<span class="string">'Mr'</span>])</span><br><span class="line">df[[<span class="string">'Initial'</span>]].distinct().show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+</span><br><span class="line">|Initial|</span><br><span class="line">+-------+</span><br><span class="line">|   Miss|</span><br><span class="line">|  Other|</span><br><span class="line">| Master|</span><br><span class="line">|     Mr|</span><br><span class="line">|    Mrs|</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>
<p>看一下各个称谓的平均年龄.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">'Initial'</span>).avg(<span class="string">'Age'</span>).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+------------------+</span><br><span class="line">|Initial|          avg(Age)|</span><br><span class="line">+-------+------------------+</span><br><span class="line">|   Miss|             21.86|</span><br><span class="line">|  Other|45.888888888888886|</span><br><span class="line">| Master| 4.574166666666667|</span><br><span class="line">|     Mr| 32.73960880195599|</span><br><span class="line">|    Mrs|35.981818181818184|</span><br><span class="line">+-------+------------------+</span><br></pre></td></tr></table></figure>
<p>利用以上结果, 对缺失部分的年龄进行填充.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> when</span><br><span class="line">df = df.withColumn(</span><br><span class="line">    <span class="string">"Age"</span>,</span><br><span class="line">    when((df[<span class="string">"Initial"</span>] == <span class="string">"Miss"</span>) &amp; (df[<span class="string">"Age"</span>].isNull()),</span><br><span class="line">         <span class="number">22</span>).otherwise(df[<span class="string">"Age"</span>]))</span><br><span class="line">df = df.withColumn(</span><br><span class="line">    <span class="string">"Age"</span>,</span><br><span class="line">    when((df[<span class="string">"Initial"</span>] == <span class="string">"Other"</span>) &amp; (df[<span class="string">"Age"</span>].isNull()),</span><br><span class="line">         <span class="number">46</span>).otherwise(df[<span class="string">"Age"</span>]))</span><br><span class="line">df = df.withColumn(</span><br><span class="line">    <span class="string">"Age"</span>,</span><br><span class="line">    when((df[<span class="string">"Initial"</span>] == <span class="string">"Master"</span>) &amp; (df[<span class="string">"Age"</span>].isNull()),</span><br><span class="line">         <span class="number">5</span>).otherwise(df[<span class="string">"Age"</span>]))</span><br><span class="line">df = df.withColumn(</span><br><span class="line">    <span class="string">"Age"</span>,</span><br><span class="line">    when((df[<span class="string">"Initial"</span>] == <span class="string">"Mr"</span>) &amp; (df[<span class="string">"Age"</span>].isNull()),</span><br><span class="line">         <span class="number">33</span>).otherwise(df[<span class="string">"Age"</span>]))</span><br><span class="line">df = df.withColumn(</span><br><span class="line">    <span class="string">"Age"</span>,</span><br><span class="line">    when((df[<span class="string">"Initial"</span>] == <span class="string">"Mrs"</span>) &amp; (df[<span class="string">"Age"</span>].isNull()),</span><br><span class="line">         <span class="number">36</span>).otherwise(df[<span class="string">"Age"</span>]))</span><br></pre></td></tr></table></figure>
<p>填充<code>Embarked</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupBy(<span class="string">"Embarked"</span>).count().show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------+-----+</span><br><span class="line">|Embarked|count|</span><br><span class="line">+--------+-----+</span><br><span class="line">|       Q|   77|</span><br><span class="line">|    null|    2|</span><br><span class="line">|       C|  168|</span><br><span class="line">|       S|  644|</span><br><span class="line">+--------+-----+</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.fillna(&#123;<span class="string">"Embarked"</span> : <span class="string">'S'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>删除<code>Cabin</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.drop(<span class="string">'Cabin'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="构造特征"><a href="#构造特征" class="headerlink" title="构造特征"></a>构造特征</h1><p>对于<code>SibSp</code>与<code>Parch</code>这两列, 分别表示不与自己同辈以及与自己同辈的亲人数量.</p>
<p>那么可以考虑它们的和,来构造一个特征.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.withColumn(<span class="string">"Family_Size"</span>, df[<span class="string">'SibSp'</span>] + df[<span class="string">'Parch'</span>])</span><br><span class="line">df.groupBy(<span class="string">"Family_Size"</span>).count().show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+-----+</span><br><span class="line">|Family_Size|count|</span><br><span class="line">+-----------+-----+</span><br><span class="line">|          1|  161|</span><br><span class="line">|          6|   12|</span><br><span class="line">|          3|   29|</span><br><span class="line">|          5|   22|</span><br><span class="line">|          4|   15|</span><br><span class="line">|          7|    6|</span><br><span class="line">|         10|    7|</span><br><span class="line">|          2|  102|</span><br><span class="line">|          0|  537|</span><br><span class="line">+-----------+-----+</span><br></pre></td></tr></table></figure>
<p>进一步可以构造是否一个人的特征.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lit</span><br><span class="line">df = df.withColumn(<span class="string">'Alone'</span>, lit(<span class="number">0</span>))</span><br><span class="line">df = df.withColumn(<span class="string">"Alone"</span>,</span><br><span class="line">                   when(df[<span class="string">"Family_Size"</span>] == <span class="number">0</span>, <span class="number">1</span>).otherwise(df[<span class="string">"Alone"</span>]))</span><br><span class="line">df.groupBy(<span class="string">'Alone'</span>).avg(<span class="string">'survived'</span>).show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----+-------------------+</span><br><span class="line">|Alone|      avg(survived)|</span><br><span class="line">+-----+-------------------+</span><br><span class="line">|    1|0.30353817504655495|</span><br><span class="line">|    0| 0.5056497175141242|</span><br><span class="line">+-----+-------------------+</span><br></pre></td></tr></table></figure>
<p>从这里可以看到, 独自一人的生存率要…低…??? 懂了, 谈恋爱可以增加生存率!</p>
<h1 id="类别特征编码"><a href="#类别特征编码" class="headerlink" title="类别特征编码"></a>类别特征编码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> StringIndexer</span><br><span class="line">indexers = [StringIndexer(inputCol=column, outputCol=column+<span class="string">"_index"</span>) <span class="keyword">for</span> column <span class="keyword">in</span> [<span class="string">"Sex"</span>,<span class="string">"Embarked"</span>,<span class="string">"Initial"</span>]]</span><br><span class="line">pipeline = Pipeline(stages=indexers)</span><br><span class="line">df = pipeline.fit(df).transform(df)</span><br><span class="line"></span><br><span class="line">df = df.drop(<span class="string">"PassengerId"</span>,<span class="string">"Name"</span>,<span class="string">"Ticket"</span>,<span class="string">"Cabin"</span>,<span class="string">"Embarked"</span>,<span class="string">"Sex"</span>,<span class="string">"Initial"</span>)</span><br><span class="line"></span><br><span class="line">df.columns</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;Survived&apos;,</span><br><span class="line"> &apos;Pclass&apos;,</span><br><span class="line"> &apos;Age&apos;,</span><br><span class="line"> &apos;SibSp&apos;,</span><br><span class="line"> &apos;Parch&apos;,</span><br><span class="line"> &apos;Fare&apos;,</span><br><span class="line"> &apos;Family_Size&apos;,</span><br><span class="line"> &apos;Alone&apos;,</span><br><span class="line"> &apos;Sex_index&apos;,</span><br><span class="line"> &apos;Embarked_index&apos;,</span><br><span class="line"> &apos;Initial_index&apos;]</span><br></pre></td></tr></table></figure>
<h1 id="整合特征-amp-标签"><a href="#整合特征-amp-标签" class="headerlink" title="整合特征 &amp; 标签"></a>整合特征 &amp; 标签</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> VectorAssembler</span><br><span class="line">vector_assembler = VectorAssembler(inputCols=df.columns[<span class="number">1</span>:],</span><br><span class="line">                                   outputCol=<span class="string">"features"</span>)</span><br><span class="line">df = feature.transform(df)</span><br><span class="line"></span><br><span class="line">df = df.withColumnRenamed(<span class="string">'Survived'</span>, <span class="string">'label'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集/测试集.</span></span><br><span class="line">train, test = df[[<span class="string">'features'</span>, <span class="string">'label'</span>]].randomSplit([<span class="number">0.8</span>, <span class="number">0.2</span>], seed=<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载逻辑回归模块.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.classification <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建逻辑回归实例.</span></span><br><span class="line">lr = LogisticRegression(labelCol=<span class="string">"label"</span>,</span><br><span class="line">                        featuresCol=<span class="string">"features"</span>,</span><br><span class="line">                        maxIter=<span class="number">10</span>,</span><br><span class="line">                        regParam=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型.</span></span><br><span class="line">lr_model = lr.fit(train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出模型信息.</span></span><br><span class="line"><span class="comment"># print("Coefficients: " + str(lr_model.coefficients))</span></span><br><span class="line">print(<span class="string">"Intercept: "</span> + str(lr_model.intercept))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用模型进行预测.</span></span><br><span class="line">preds = lr_model.transform(test)</span><br><span class="line">preds.printSchema()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- features: vector (nullable = true)</span><br><span class="line"> |-- label: integer (nullable = true)</span><br><span class="line"> |-- rawPrediction: vector (nullable = true)</span><br><span class="line"> |-- probability: vector (nullable = true)</span><br><span class="line"> |-- prediction: double (nullable = false)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AUC</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.evaluation <span class="keyword">import</span> BinaryClassificationEvaluator</span><br><span class="line"></span><br><span class="line">evaluator = BinaryClassificationEvaluator(rawPredictionCol=<span class="string">"rawPrediction"</span>, metricName=<span class="string">'areaUnderROC'</span>)</span><br><span class="line">print(evaluator.getMetricName())</span><br><span class="line">print(evaluator.evaluate(preds))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">areaUnderROC</span><br><span class="line">0.8511334610472546</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.tuning <span class="keyword">import</span> ParamGridBuilder, CrossValidator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建调参网格.</span></span><br><span class="line">paramGrid = (ParamGridBuilder()</span><br><span class="line">             .addGrid(lr.regParam, [<span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line">             .addGrid(lr.elasticNetParam, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">             .build())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建交叉验证.</span></span><br><span class="line">cv = CrossValidator(estimator=lr,</span><br><span class="line">                    estimatorParamMaps=paramGrid,</span><br><span class="line">                    evaluator=evaluator, numFolds=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行交叉验证 &amp; 网格调参.</span></span><br><span class="line">cvModel = cv.fit(train)</span><br><span class="line">print(evaluator.evaluate(cvModel.transform(test)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.8584770114942533</span><br></pre></td></tr></table></figure>
<h1 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.classification <span class="keyword">import</span> GBTClassifier</span><br><span class="line"></span><br><span class="line">gbdt = GBTClassifier(seed=<span class="number">7</span>)</span><br><span class="line">gbdt_model = gbdt.fit(train)</span><br><span class="line">print(evaluator.evaluate(gbdt_model.transform(test)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.8702107279693482</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.tuning <span class="keyword">import</span> ParamGridBuilder, CrossValidator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建调参网格.</span></span><br><span class="line">paramGrid = (ParamGridBuilder()</span><br><span class="line">             .addGrid(gbdt.maxDepth, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">             .addGrid(gbdt.minInstancesPerNode, [<span class="number">1</span>, <span class="number">20</span>])</span><br><span class="line">             .addGrid(gbdt.maxIter, [<span class="number">20</span>, <span class="number">100</span>])</span><br><span class="line">             .addGrid(gbdt.stepSize, [<span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">1</span>])</span><br><span class="line">             .addGrid(gbdt.subsamplingRate, [<span class="number">0.7</span>, <span class="number">1</span>])</span><br><span class="line">             .build())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建交叉验证.</span></span><br><span class="line">cv = CrossValidator(estimator=gbdt,</span><br><span class="line">                    estimatorParamMaps=paramGrid,</span><br><span class="line">                    evaluator=evaluator, numFolds=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行交叉验证 &amp; 网格调参.</span></span><br><span class="line">cvModel = cv.fit(train)</span><br><span class="line">print(evaluator.evaluate(cvModel.transform(test)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.8785919540229884</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spark.stop()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>Number of Steps to Reduce a Number to Zero</title>
    <url>/2020/05/11/LeetCode/Number-of-Steps-to-Reduce-a-Number-to-Zero/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a non-negative integer <code>num</code>, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num = 14</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">Step 1) 14 is even; divide by 2 and obtain 7. </span><br><span class="line">Step 2) 7 is odd; subtract 1 and obtain 6.</span><br><span class="line">Step 3) 6 is even; divide by 2 and obtain 3. </span><br><span class="line">Step 4) 3 is odd; subtract 1 and obtain 2. </span><br><span class="line">Step 5) 2 is even; divide by 2 and obtain 1. </span><br><span class="line">Step 6) 1 is odd; subtract 1 and obtain 0.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num = 8</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">Step 1) 8 is even; divide by 2 and obtain 4. </span><br><span class="line">Step 2) 4 is even; divide by 2 and obtain 2. </span><br><span class="line">Step 3) 2 is even; divide by 2 and obtain 1. </span><br><span class="line">Step 4) 1 is odd; subtract 1 and obtain 0.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: num = 123</span><br><span class="line">Output: 12</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= num &lt;= 10^6</code></li>
</ul>
<hr>
<p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num = 14</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">步骤 1) 14 是偶数，除以 2 得到 7 。</span><br><span class="line">步骤 2） 7 是奇数，减 1 得到 6 。</span><br><span class="line">步骤 3） 6 是偶数，除以 2 得到 3 。</span><br><span class="line">步骤 4） 3 是奇数，减 1 得到 2 。</span><br><span class="line">步骤 5） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 6） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num = 8</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">步骤 1） 8 是偶数，除以 2 得到 4 。</span><br><span class="line">步骤 2） 4 是偶数，除以 2 得到 2 。</span><br><span class="line">步骤 3） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 4） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num = 123</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt;= 10^6</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这里可以按照题意, 通过判断当前数的奇偶性, 一步步往下演算. 但是利用位运算的一些性质可以更加巧妙和快捷.</p>
<p>二进制数有如下两条性质:</p>
<ul>
<li>末位为0, 则为偶数; 末位为1, 则为奇数.</li>
<li>对二进制来说, 被二整除, 等价于消除末位.</li>
</ul>
<p>结合以上两条性质, 对于给定的数, 可以得到其对应的二进制表示. 从末位开始, 当遇到0, 则消去, 遇到1, 则将其变为0. 那么最后变成了统计二进制中0和1的个数, 0计1次, 1计2次.</p>
<p>最后还需要注意, 最后剩下0时, 不需要计数.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfSteps</span> <span class="params">(self, num)</span>:</span></span><br><span class="line">        bin_num = bin(num)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">return</span> sum([<span class="number">1</span> <span class="keyword">if</span> x == <span class="string">'0'</span> <span class="keyword">else</span> <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> bin_num]) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-11</li>
<li>击败比例: 98.19%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Bit</category>
      </categories>
  </entry>
  <entry>
    <title>PySpark学习笔记(二)</title>
    <url>/2020/05/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/PySpark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<p>本章节主要总结下一些简单基础的, 与机器学习相关的内容.</p>
<a id="more"></a>
<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本匹配.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> when</span><br><span class="line"></span><br><span class="line">con_0 = df[<span class="string">'col'</span>].like(<span class="string">'%a%'</span>)</span><br><span class="line">con_1 = df[<span class="string">'col'</span>].like(<span class="string">'%b%'</span>)</span><br><span class="line"></span><br><span class="line">df = df.withColumn(<span class="string">'new_col'</span>, (when(con_0, <span class="number">1</span>).when(con_1, <span class="number">0</span>).otherwise(<span class="literal">None</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> split, explode</span><br><span class="line"></span><br><span class="line">df = df.withColumn(<span class="string">'list_'</span>, split(df[<span class="string">'string_col'</span>], <span class="string">', '</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原本1条样本, 拆分成多条.</span></span><br><span class="line">ex_df = df.withColumn(<span class="string">'ex_list'</span>, explode(df[<span class="string">'list_'</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载函数.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> regexp_replace</span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> Tokenizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用正则表达式去除标点和数值.</span></span><br><span class="line">df = df.withColumn(<span class="string">'text'</span>, regexp_replace(df[<span class="string">'text'</span>], <span class="string">'[_():;,.!?\\-]'</span>, <span class="string">' '</span>))</span><br><span class="line">df = df.withColumn(<span class="string">'text'</span>, regexp_replace(df[<span class="string">'text'</span>], <span class="string">'[0-9]'</span>, <span class="string">' '</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分词(使用空格).</span></span><br><span class="line">df = Tokenizer(inputCol=<span class="string">'text'</span>, outputCol=<span class="string">'words'</span>).transform(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除停用词.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> StopWordsRemover</span><br><span class="line"></span><br><span class="line">df = StopWordsRemover(inputCol=<span class="string">'words'</span>, outputCol=<span class="string">'words'</span>).transform(df)</span><br></pre></td></tr></table></figure>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> HashingTF, IDF</span><br><span class="line"></span><br><span class="line"><span class="comment"># TF-IDF.</span></span><br><span class="line">df = HashingTF(inputCol=<span class="string">'words'</span>, outputCol=<span class="string">'hash'</span>, numFeatures=<span class="number">1024</span>).transform(df)</span><br><span class="line"></span><br><span class="line">df = IDF(inputCol=<span class="string">'hash'</span>, outputCol=<span class="string">'features'</span>).fit(df).transform(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0-1编码.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> Binarizer</span><br><span class="line"></span><br><span class="line">binarizer = Binarizer(threshold=<span class="number">5.0</span>, inputCol=<span class="string">'col'</span>, outputCol=<span class="string">'target'</span>)</span><br><span class="line"></span><br><span class="line">df = binarizer.transform(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分箱编码.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> Bucketizer</span><br><span class="line"></span><br><span class="line">splits = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, float(<span class="string">'Inf'</span>)]</span><br><span class="line">buck = Bucketizer(splits=splits, inputCol=<span class="string">'col'</span>, outputCol=<span class="string">'bucket_col'</span>)</span><br><span class="line"></span><br><span class="line">df_bucket = buck.transform(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 独热编码.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> OneHotEncoder, StringIndexer, OneHotEncoderEstimator</span><br><span class="line"></span><br><span class="line">string_indexer = StringIndexer(inputCol=<span class="string">'a'</span>, outputCol=<span class="string">'b'</span>)</span><br><span class="line">df = string_indexer.fit(df).transform(df)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 直接转换.</span></span><br><span class="line">encoder = OneHotEncoder(dropLast=<span class="literal">False</span>, inputCol=<span class="string">"b"</span>, outputCol=<span class="string">"c"</span>)</span><br><span class="line">df = encoder.transform(df)</span><br><span class="line"><span class="comment">## fit &amp; transform</span></span><br><span class="line">encoder = OneHotEncoderEstimator(inputCols=[<span class="string">"b"</span>], outputCols=[<span class="string">"c"</span>])</span><br><span class="line">model = encoder.fit(df)</span><br><span class="line">df = model.transform(df)</span><br></pre></td></tr></table></figure>
<h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> VectorAssembler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一系列数据处理模块.</span></span><br><span class="line">stages = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将入模特征作为向量.</span></span><br><span class="line">assembler = VectorAssembler(inputCols=ft_list, outputCol=<span class="string">"features"</span>)</span><br><span class="line">stages += [assembler]</span><br><span class="line"><span class="comment"># 利用Pipline处理数据.</span></span><br><span class="line">pipeline = Pipeline(stages=stages)</span><br><span class="line">pipeline_fit = pipeline.fit(df)</span><br><span class="line">df = pipeline_fit.transform(df)</span><br></pre></td></tr></table></figure>
<h1 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train, test = df.randomSplit([<span class="number">.8</span>, <span class="number">.2</span>], seed=<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载逻辑回归模块.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.classification <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建逻辑回归实例.</span></span><br><span class="line">lr = LogisticRegression(labelCol=<span class="string">"label"</span>,</span><br><span class="line">                        featuresCol=<span class="string">"features"</span>,</span><br><span class="line">                        maxIter=<span class="number">10</span>,</span><br><span class="line">                        regParam=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型.</span></span><br><span class="line">linear_fit = lr.fit(train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出模型信息.</span></span><br><span class="line">print(<span class="string">"Coefficients: "</span> + str(linear_fit.coefficients))</span><br><span class="line">print(<span class="string">"Intercept: "</span> + str(linear_fit.intercept))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用模型进行预测.</span></span><br><span class="line">preds = linear_fit.transform(test)</span><br><span class="line">preds.printSchema()</span><br></pre></td></tr></table></figure>
<h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准确率.</span></span><br><span class="line">preds.filter(preds.label == preds.prediction).count() / preds.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># AUC</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.evaluation <span class="keyword">import</span> BinaryClassificationEvaluator</span><br><span class="line"></span><br><span class="line">evaluator = BinaryClassificationEvaluator(rawPredictionCol=<span class="string">"rawPrediction"</span>, metricName=<span class="string">'areaUnderROC'</span>)</span><br><span class="line">print(evaluator.getMetricName())</span><br><span class="line">print(evaluator.evaluate(preds))</span><br></pre></td></tr></table></figure>
<h1 id="交叉验证-amp-网格调参"><a href="#交叉验证-amp-网格调参" class="headerlink" title="交叉验证 &amp; 网格调参"></a>交叉验证 &amp; 网格调参</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.tuning <span class="keyword">import</span> ParamGridBuilder, CrossValidator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建调参网格.</span></span><br><span class="line">paramGrid = (ParamGridBuilder()</span><br><span class="line">             .addGrid(lr.regParam, [<span class="number">0.01</span>, <span class="number">0.5</span>])</span><br><span class="line">             .addGrid(lr.elasticNetParam, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">             .build())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建交叉验证.</span></span><br><span class="line">cv = CrossValidator(estimator=lr,</span><br><span class="line">                    estimatorParamMaps=paramGrid,</span><br><span class="line">                    evaluator=evaluator, numFolds=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行交叉验证 &amp; 网格调参.</span></span><br><span class="line">cvModel = cv.fit(train)</span><br><span class="line">print(evaluator.evaluate(cvModel.transform(test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最佳模型.</span></span><br><span class="line">best_model = cv.bestModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最佳模型stages.</span></span><br><span class="line">print(best_model.stages)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得最佳模型的LinearRegression参数.</span></span><br><span class="line">best_model.stages[<span class="number">3</span>].extractParamMap()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用最佳模型预测并进行评估.</span></span><br><span class="line">predictions = best_model.transform(test)</span><br><span class="line">evaluator.evaluate(predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有超参数组合下, CV上的模型表现.</span></span><br><span class="line">avg_auc = cv.avgMetrics</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳模型的CV表现.</span></span><br><span class="line">best_model_auc = max(cv.avgMetrics)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳模型的某个超参数.</span></span><br><span class="line">opt_regParam = cv.bestModel.explainParam(<span class="string">'maxDepth'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="保存-amp-加载模型"><a href="#保存-amp-加载模型" class="headerlink" title="保存 &amp; 加载模型"></a>保存 &amp; 加载模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存模型.</span></span><br><span class="line">model.save(<span class="string">'lr.model'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.classification <span class="keyword">import</span> LogisticRegression</span><br><span class="line">model = LogisticRegression.load(<span class="string">'lr.model'</span>)</span><br></pre></td></tr></table></figure>
<p>下一篇将以一个实际的数据集为例, 利用PySpark完整地做一遍数据处理的操作.</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>Play with Chips</title>
    <url>/2020/05/10/LeetCode/Play-with-Chips/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>There are some chips, and the i-th chip is at position <code>chips[i]</code>.</p>
<p>You can perform any of the two following types of moves <strong>any number of times</strong> (possibly zero) <strong>on any chip</strong>:</p>
<ul>
<li>Move the <code>i</code>-th chip by 2 units to the left or to the right with a cost of <strong>0</strong>.</li>
<li>Move the <code>i</code>-th chip by 1 unit to the left or to the right with a cost of <strong>1</strong>.</li>
</ul>
<p>There can be two or more chips at the same position initially.</p>
<p>Return the minimum cost needed to move all the chips to the same position (any position).</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: chips = [1,2,3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Second chip will be moved to positon 3 with cost 1. First chip will be moved to position 3 with cost 0. Total cost is 1.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: chips = [2,2,2,3,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Both fourth and fifth chip will be moved to position two with cost 1. Total minimum cost will be 2.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= chips.length &lt;= 100</code></li>
<li><code>1 &lt;= chips[i] &lt;= 10^9</code></li>
</ul>
<hr>
<p>数轴上放置了一些筹码，每个筹码的位置存在数组 <code>chips</code> 当中。</p>
<p>你可以对 <strong>任何筹码</strong> 执行下面两种操作之一（<strong>不限操作次数</strong>，0 次也可以）：</p>
<ul>
<li>将第 <code>i</code> 个筹码向左或者右移动 2 个单位，代价为 <strong>0</strong>。</li>
<li>将第 <code>i</code> 个筹码向左或者右移动 1 个单位，代价为 <strong>1</strong>。</li>
</ul>
<p>最开始的时候，同一位置上也可能放着两个或者更多的筹码。</p>
<p>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：chips = [1,2,3]</span><br><span class="line">输出：1</span><br><span class="line">解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：chips = [2,2,2,3,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= chips.length &lt;= 100</code></li>
<li><code>1 &lt;= chips[i] &lt;= 10^9</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题还是比较有意思的, 有一个关键点, 所有位于偶数位置上的筹码, 移动到任意偶数位置, 代价为0, 移动到任意奇数位置, 代价为1; 奇数位置的数同理.</p>
<p>于是, 我们只需要统计处于偶数位置与奇数位置的筹码数量即可, 最后返回较小值.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostToMoveChips</span><span class="params">(self, chips)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(chips) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        counter = Counter(chips)</span><br><span class="line"></span><br><span class="line">        even_cost = <span class="number">0</span></span><br><span class="line">        odd_cost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> counter:</span><br><span class="line">            <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                odd_cost += counter[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                even_cost += counter[k]</span><br><span class="line">        <span class="keyword">return</span> min(even_cost, odd_cost)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-10</li>
<li>击败比例: 70.98%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>Additive Number</title>
    <url>/2020/05/09/LeetCode/Additive-Number/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p>Given a string containing only digits <code>&#39;0&#39;-&#39;9&#39;</code>, write a function to determine if it’s an additive number.</p>
<a id="more"></a>
<p><strong>Note:</strong> Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;112358&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. </span><br><span class="line">             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;199100199&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The additive sequence is: 1, 99, 100, 199. </span><br><span class="line">             1 + 99 = 100, 99 + 100 = 199</span><br></pre></td></tr></table></figure>
<hr>
<p>累加数是一个字符串，组成它的数字可以形成累加序列。</p>
<p>一个有效的累加序列必须<strong>至少</strong>包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。</p>
<p>给定一个只包含数字 <code>&#39;0&#39;-&#39;9&#39;</code> 的字符串，编写一个算法来判断给定输入是否是累加数。</p>
<p><strong>说明:</strong> 累加序列里的数不会以 0 开头，所以不会出现 <code>1, 2, 03</code> 或者 <code>1, 02, 3</code> 的情况。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;112358&quot;</span><br><span class="line">输出: true </span><br><span class="line">解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;199100199&quot;</span><br><span class="line">输出: true </span><br><span class="line">解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199</span><br></pre></td></tr></table></figure>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>我不是很懂回溯, 但是对于这道题来说, 有如下几个要点:</p>
<ul>
<li>字符串长度不能小于3.</li>
<li>若某个数字第一个字符为0, 则该数字只能是0.</li>
<li>由于累加数的规则, 只要确定前面两个数, 后面的序列就完全确定了.</li>
<li>当前面两个数确定后, 剩下的字符串长度, 若小于前面两个数中的较大长度, 则不行. 因为和数的长度必大于等于加数.</li>
</ul>
<p>由以上的几条要点, 可以设置一个方法, 传入头两个数字, 判断是否能构成累加数列.</p>
<p>然后对于前两个数字的选取, 利用双层循环进行, 并对其中的一些细节进行判断和处理即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.len_num = <span class="literal">None</span></span><br><span class="line">        self.num = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAdditiveNumber</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(num) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.len_num = len(num)</span><br><span class="line">        self.num = num</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.len_num - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> num[i + <span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                fst = num[: i + <span class="number">1</span>]</span><br><span class="line">                scd = <span class="string">'0'</span></span><br><span class="line">                <span class="keyword">if</span> self.len_num - i - <span class="number">2</span> &lt; max(len(fst), len(scd)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> self.is_true(int(fst), int(scd)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, self.len_num - <span class="number">1</span>):</span><br><span class="line">                fst = num[: i + <span class="number">1</span>]</span><br><span class="line">                scd = num[i + <span class="number">1</span>: j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> self.len_num - j - <span class="number">1</span> &lt; max(len(fst), len(scd)):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> self.is_true(int(fst), int(scd)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_true</span><span class="params">(self, fst, scd)</span>:</span></span><br><span class="line">        res_string = str(fst) + str(scd)</span><br><span class="line">        <span class="keyword">while</span> len(res_string) &lt; self.len_num:</span><br><span class="line">            trd = fst + scd</span><br><span class="line">            res_string += str(trd)</span><br><span class="line">            fst, scd = scd, trd</span><br><span class="line">        <span class="keyword">return</span> res_string == self.num</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-09</li>
<li>击败比例: 46.47%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Backtracking</category>
      </categories>
  </entry>
  <entry>
    <title>Valid Boomerang</title>
    <url>/2020/05/09/LeetCode/Valid-Boomerang/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>A <em>boomerang</em> is a set of 3 points that are all distinct and <strong>not</strong> in a straight line.</p>
<p>Given a list of three points in the plane, return whether these points are a boomerang.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,1],[2,3],[3,2]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>points.length == 3</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>0 &lt;= points[i][j] &lt;= 100</code></li>
</ol>
<hr>
<p>回旋镖定义为一组三个点，这些点各不相同且<strong>不</strong>在一条直线上。</p>
<p>给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1],[2,3],[3,2]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1],[2,2],[3,3]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>points.length == 3</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>0 &lt;= points[i][j] &lt;= 100</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这里我的方法是通过前两个点确定一条直线$y=ax+b$, 然后用第三个点进行验证.</p>
<p>需要注意的一些地方:</p>
<ul>
<li>先检验前两个点是否一样, 一样则返回<code>False</code>.</li>
<li>检验几个点的横坐标是否相同, 避免计算斜率的时候引起错误.</li>
</ul>
<p>Python3.x在默认数值计算上, 对于一般的加减乘除, 在没有截断的情况下, 是没有误差的.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBoomerang</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        point_0 = points[<span class="number">0</span>]</span><br><span class="line">        point_1 = points[<span class="number">1</span>]</span><br><span class="line">        point_2 = points[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> point_0 == point_1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> point_0[<span class="number">0</span>] == point_1[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">if</span> point_2[<span class="number">0</span>] == point_1[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># y = ax + b</span></span><br><span class="line">        a = (point_1[<span class="number">1</span>] - point_0[<span class="number">1</span>]) / (point_1[<span class="number">0</span>] - point_0[<span class="number">0</span>])</span><br><span class="line">        b = point_0[<span class="number">1</span>] - a * point_0[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> point_2[<span class="number">1</span>] != a * point_2[<span class="number">0</span>] + b</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-09</li>
<li>击败比例: </li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>Occurrences After Bigram</title>
    <url>/2020/05/08/LeetCode/Occurrences-After-Bigram/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given words <code>first</code> and <code>second</code>, consider occurrences in some <code>text</code> of the form “<code>first second third</code>“, where <code>second</code>comes immediately after <code>first</code>, and <code>third</code> comes immediately after <code>second</code>.</p>
<p>For each such occurrence, add “<code>third</code>“ to the answer, and return the answer.</p>
<a id="more"></a> 
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</span><br><span class="line">Output: [&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;</span><br><span class="line">Output: [&quot;we&quot;,&quot;rock&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= text.length &lt;= 1000</code></li>
<li><code>text</code> consists of space separated words, where each word consists of lowercase English letters.</li>
<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>
<li><code>first</code> and <code>second</code> consist of lowercase English letters.</li>
</ol>
<hr>
<p>给出第一个词 <code>first</code> 和第二个词 <code>second</code>，考虑在某些文本 <code>text</code> 中可能以 “<code>first second third</code>“ 形式出现的情况，其中 <code>second</code> 紧随 <code>first</code> 出现，<code>third</code> 紧随 <code>second</code> 出现。</p>
<p>对于每种这样的情况，将第三个词 “<code>third</code>“ 添加到答案中，并返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</span><br><span class="line">输出：[&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;</span><br><span class="line">输出：[&quot;we&quot;,&quot;rock&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= text.length &lt;= 1000</code></li>
<li><code>text</code> 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成</li>
<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>
<li><code>first</code> 和 <code>second</code> 由小写英文字母组成</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>非常常规且简单的一道题, 将原字符串按空格进行切分, 然后循环依次进行比较即可.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOcurrences</span><span class="params">(self, text, first, second)</span>:</span></span><br><span class="line">        res_list = []</span><br><span class="line">        text_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> text.split(<span class="string">' '</span>) <span class="keyword">if</span> x != <span class="string">''</span>]</span><br><span class="line">        len_text_list = len(text_list)</span><br><span class="line">        <span class="keyword">if</span> len_text_list &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> res_list</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_text_list - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> text_list[i] == first <span class="keyword">and</span> text_list[i + <span class="number">1</span>] == second:</span><br><span class="line">                res_list.append(text_list[i + <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-08</li>
<li>击败比例: 45.08%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2020/05/07/LeetCode/Majority-Element/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<hr>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题难度为easy级, 也确实简单, 但是可以引出多种不同的解法.</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>最简单直接的就是使用Hash, 记录每个元素出现次数.</p>
<p>时间复杂度$O(N)$, 空间复杂度$O(N)$.</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>将数组排序后, 由于题目中的众数多余整体数量的一半, 所以返回<code>len(nums) // 2</code>即可.</p>
<p>时间复杂度$O(N{\rm log}N)$, 空间复杂度$O({\rm log}N)$.</p>
<h2 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h2><p>因为这里的众数数量多于一半, 所以随机抽取一个数, 其是众数的概率大于二分之一. 然后验证该数是否为众数即可.</p>
<p>时间复杂度$O(N)$, 空间复杂度$O(1)$.</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>若一个数<code>a</code>为数组<code>A</code>的众数, 且数量超过一半, 则将数组<code>A</code>分为两部分, 数<code>a</code>必为其中一部分的众数.</p>
<p>利用上述的结论, 若得到了两部分数组各自的众数<code>a0</code>与<code>a1.</code> 若相同, 则说明这就是众数; 若不同, 进一步验证谁是真正的众数. 使用递归, 当数组长度为1时, 直接返回数.</p>
<p>时间复杂度$O(N{\rm log}N)$, 空间复杂度$O({\rm log}N)$.</p>
<h2 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h2><p>维护一个变量<code>var</code>记录当前数, 初始化为<code>None</code>, 以及<code>counter</code>记录当前票数, 初始化为0.</p>
<p>遍历数组: </p>
<ul>
<li><p>若<code>counter</code>为0, 则将当前数赋予<code>var</code>, <code>counter</code>为1.</p>
</li>
<li><p>若当前数与<code>var</code>相同, <code>counter</code>加1.</p>
</li>
<li><p>若当前数与<code>var</code>不同, <code>counter</code>减1.</p>
</li>
</ul>
<p>最后剩下的<code>var</code>即为众数.</p>
<p>时间复杂度$O(N)$, 空间复杂度$O(1)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        var, counter = <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> counter == <span class="number">0</span>:</span><br><span class="line">                var = i</span><br><span class="line">                counter = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> var == i:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counter -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> var</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-07</li>
<li>击败比例: 78.89%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Squares of a Sorted Array</title>
    <url>/2020/05/06/LeetCode/Squares-of-a-Sorted-Array/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given an array of integers <code>A</code> sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> is sorted in non-decreasing order.</li>
</ol>
<hr>
<p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> 已按非递减顺序排序。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>平方后, 直接利用Python内置的<code>sorted</code>排序, 时间复杂度约为$O(N{\rm log}(N))$.</p>
<p>但是由于内置函数底层本身特别快, 所以其实真实速度并不慢.</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>稍微进行一下分析, 可以发现:</p>
<ul>
<li>若全为非负数, 平方不改变排序.</li>
<li>若全为非正数, 平方后排序颠倒.</li>
</ul>
<p>当同时存在正数和负数的时候, 可以将两者分离, 得到两组排序好的子数组. 然后每次比较两组头部的数, 进行整体的排序. 这样的时间复杂度为$O(N)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> list(sorted([x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> A]))</span><br></pre></td></tr></table></figure>
<h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        pos_list = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> A <span class="keyword">if</span> x &gt; <span class="number">0</span>]</span><br><span class="line">        not_pos_list = list(reversed([x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> A <span class="keyword">if</span> x &lt;= <span class="number">0</span>]))</span><br><span class="line">        len_pos_list = len(pos_list)</span><br><span class="line">        len_not_pos_list = len(not_pos_list)</span><br><span class="line">        <span class="keyword">if</span> len_pos_list == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> not_pos_list</span><br><span class="line">        <span class="keyword">if</span> len_not_pos_list == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pos_list</span><br><span class="line">        </span><br><span class="line">        p_0, p_1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> pos_list[p_0] &lt; not_pos_list[p_1]:</span><br><span class="line">                res_list.append(pos_list[p_0])</span><br><span class="line">                p_0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res_list.append(not_pos_list[p_1])</span><br><span class="line">                p_1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p_0 == len_pos_list <span class="keyword">or</span> p_1 == len_not_pos_list:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> p_0 == len_pos_list:</span><br><span class="line">            <span class="keyword">return</span> res_list + not_pos_list[p_1:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res_list + pos_list[p_0:]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-06</li>
<li>击败比例: 60.27%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Unique Morse Code Words</title>
    <url>/2020/05/04/LeetCode/Unique-Morse-Code-Words/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code> maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>
<a id="more"></a>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>
<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..—…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>
<p>Return the number of different transformations among all words we have.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The transformation of each word is:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>The length of <code>words</code> will be at most <code>100</code>.</li>
<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>
<li><code>words[i]</code> will only consist of lowercase letters.</li>
</ul>
<hr>
<p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: <code>&quot;a&quot;</code> 对应 <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code> 对应 <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> 对应 <code>&quot;-.-.&quot;</code>, 等等。</p>
<p>为了方便，所有26个英文字母对应摩尔斯密码表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>
<p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..—…”，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。</p>
<p>返回我们可以获得所有词不同单词翻译的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>单词列表<code>words</code> 的长度不会超过 <code>100</code>。</li>
<li>每个单词 <code>words[i]</code>的长度范围为 <code>[1, 12]</code>。</li>
<li>每个单词 <code>words[i]</code>只包含小写字母。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>非常简单, 利用字典将原单词进行转换, 再利用集合筛选不同的序列.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        morse_list = [<span class="string">".-"</span>, <span class="string">"-..."</span>, <span class="string">"-.-."</span>, <span class="string">"-.."</span>, <span class="string">"."</span>, <span class="string">"..-."</span>, <span class="string">"--."</span>, <span class="string">"...."</span>, <span class="string">".."</span>, <span class="string">".---"</span>, <span class="string">"-.-"</span>,</span><br><span class="line">                      <span class="string">".-.."</span>, <span class="string">"--"</span>, <span class="string">"-."</span>, <span class="string">"---"</span>, <span class="string">".--."</span>, <span class="string">"--.-"</span>, <span class="string">".-."</span>, <span class="string">"..."</span>, <span class="string">"-"</span>, <span class="string">"..-"</span>, <span class="string">"...-"</span>,</span><br><span class="line">                      <span class="string">".--"</span>, <span class="string">"-..-"</span>, <span class="string">"-.--"</span>, <span class="string">"--.."</span>]</span><br><span class="line">        alpha_list = list(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>)</span><br><span class="line">        self.alpha_morse_dict = dict(zip(alpha_list, morse_list))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        res_set = set()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            tmp_res = <span class="string">''</span>.join([self.alpha_morse_dict[x] <span class="keyword">for</span> x <span class="keyword">in</span> word])</span><br><span class="line">            res_set.add(tmp_res)</span><br><span class="line">        <span class="keyword">return</span> len(res_set)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-04</li>
<li>击败比例: 67.43%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Single Number II</title>
    <url>/2020/05/03/LeetCode/Single-Number-II/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>
<hr>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,3,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></table></figure>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>运用Hash的方法, 记录每个数值出现的次数.</p>
<p>时间复杂度$O(N)$, 空间复杂度$O(N)$.</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>结合位运算, 使用状态自动机.</p>
<p>在二进制的表示下, 某一位上的变化可以用下图表示:</p>
<p><img src="fig_0.png" alt="fig_0"></p>
<p>起始状态为0, 根据输入的不同情况进行对应的状态变换.</p>
<p>同时可以看到状态0与状态3是等价的, 因此进行合并:</p>
<p><img src="fig_1.jpg" alt="fig_1"></p>
<p>这里有3个状态, 可以用两个0, 1变量来进行表示, 如下图:</p>
<p><img src="fig_2.jpg" alt="fig_2"></p>
<p>进一步分析状态的变化, 对于<code>once</code>由0转变为1的情况有两种:</p>
<ul>
<li><code>once=0, twice=0, x=1</code></li>
<li><code>once=1, twice=0, x=0</code></li>
</ul>
<p>因此<code>once</code>的状态可以表示为<code>once=(once^x)&amp;(~twice)</code>.</p>
<p>对于<code>twice</code>由0转变为1的情况有两种:</p>
<ul>
<li><code>once=1, twice=0, x=1</code></li>
<li><code>once=0, twice=1, x=0</code></li>
</ul>
<p>因此<code>twice</code>的状态可以表示为<code>twice=(once^twice)&amp;(twice^x)</code>.</p>
<p>时间复杂度$O(N)$, 空间复杂度$O(1)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        info_dict = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            info_dict[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> info_dict:</span><br><span class="line">            <span class="keyword">if</span> info_dict[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        old_once = old_twice = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur_once = (old_once ^ num) &amp; (~old_twice)</span><br><span class="line">            cur_twice = (old_once ^ old_twice) &amp; (old_twice ^ num)</span><br><span class="line">            old_once, old_twice = cur_once, cur_twice</span><br><span class="line">        <span class="keyword">return</span> old_once</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-03</li>
<li>击败比例: 89.40%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Bit</category>
      </categories>
  </entry>
  <entry>
    <title>Combination Sum III</title>
    <url>/2020/05/02/LeetCode/Combination-Sum-III/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Find all possible combinations of <strong><em>k</em></strong> numbers that add up to a number <strong><em>n</em></strong>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<a id="more"></a>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<hr>
<p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong><em>k\</em></strong> 个数的组合<strong><em>。\</em></strong>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>理论上, 我们可以遍历所有可能的情况, 然后将满足条件的结果返回.</p>
<p>而一种相对更好的办法, 是从一个起点开始, 逐渐地加入新的数, 利用递归来进行搜索.</p>
<p>比如3个数, 第一个数取1, 那么要求不重复, 第二个数可以取2 ~ 9. 假设第二个数取5, 那么第三个数可以取6 ~ 9.</p>
<p>在进行递归的过程中, 遇到如下情况及时中断:</p>
<ul>
<li>数目已达到要求的<code>k</code>, 并判断总和是否等于<code>n</code>.</li>
<li>总和大于<code>n</code>.</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.n = n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            self.helper([i], i)</span><br><span class="line">        <span class="keyword">return</span> self.res_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, res, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == self.k:</span><br><span class="line">            <span class="keyword">if</span> sum(res) == self.n:</span><br><span class="line">                self.res_list.append(res)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> sum(res) &gt; self.n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num + <span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            self.helper(res + [i], i)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-05-02</li>
<li>击败比例: 95.31%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Gas Station</title>
    <url>/2020/05/01/LeetCode/Gas-Station/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<a id="more"></a>
<p><strong>Note:</strong></p>
<ul>
<li>If there exists a solution, it is guaranteed to be unique.</li>
<li>Both input arrays are non-empty and have the same length.</li>
<li>Each element in the input arrays is a non-negative integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure>
<hr>
<p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>想起来最简单的方法, 当然就是尝试将每一个加油站都作为起点, 然后遍历数组. 但这样做的时间复杂度为$O(N^2)$, 应该还有更好的办法.</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>每到一个加油站, 可以将加油站中的油全部装车, 同时开往下一站时需要耗费油. 那么如果用<code>change[i]=gas[i]-cost[i]</code>, 可以得到油量的变化.</p>
<p>如果存在一个起点加油站, 使其能够遍历一次, 那么<code>sum(change)</code>必然大于等于0.</p>
<p>若以某一个加油站<code>i</code>为起点, 但是其<code>change[i]</code>却小于0, 那么说明其不能作为起点. 将这个想法更加泛华一些, 可以得到本题的关键点: 从某个加油站<code>i</code>出发, 到中间某个加油站<code>j</code>时, 累加的<code>change</code>小于0, 那么下一个起点位于<code>j+1</code>.</p>
<p>为什么会这样呢? 因为如果一个加油站<code>i</code>可以作为起点, 那么其累加<code>change</code>的序列不会小于0. 若到某一个加油站<code>j</code>累加和小于0, 那么从当前起点<code>i</code>到<code>j</code>中的加油站, <strong>均不可能成为起点加油站</strong>. </p>
<p>使用数学来进行描述, 从$i$到$j-1$之前的数列和$sum<em>{i,k}$均大于等于0, 而到$j$的数列和小于0, 中间任意节点$k(i&lt;k&lt;j)$到$j$的数列和$sum</em>{k, j}$也小于0. 因为$sum<em>{i, j}$是一个负数, $sum</em>{i, k}$是一个非负数, 则$sum<em>{k, j}=sum</em>{i,j}-sum_{i,k}&lt;0$ .</p>
<p>这样只需要遍历一遍即可, 时间复杂度为$O(N)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        change = [gas[i] - cost[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        curr_sum = <span class="number">0</span></span><br><span class="line">        total_sum = sum(change)</span><br><span class="line">        start_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            curr_sum += change[i]</span><br><span class="line">            <span class="keyword">if</span> curr_sum &lt; <span class="number">0</span>:</span><br><span class="line">                curr_sum = <span class="number">0</span></span><br><span class="line">                start_idx = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_sum &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> start_idx &lt; n:</span><br><span class="line">            <span class="keyword">return</span> start_idx</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点:  2020-05-01</li>
<li>击败比例: 95.81%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Greedy</category>
      </categories>
  </entry>
  <entry>
    <title>N-Repeated Element in Size 2N Array</title>
    <url>/2020/04/29/LeetCode/N-Repeated-Element-in-Size-2N-Array/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>In a array <code>A</code> of size <code>2N</code>, there are <code>N+1</code> unique elements, and exactly one of these elements is repeated N times.</p>
<p>Return the element repeated <code>N</code> times.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [5,1,5,2,5,3,5,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>4 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt; 10000</code></li>
<li><code>A.length</code> is even</li>
</ol>
<hr>
<p>在大小为 <code>2N</code> 的数组 <code>A</code> 中有 <code>N+1</code> 个不同的元素，其中有一个元素重复了 <code>N</code> 次。</p>
<p>返回重复了 <code>N</code> 次的那个元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1,2,5,3,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,1,5,2,5,3,5,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>4 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt; 10000</code></li>
<li><code>A.length</code> 为偶数</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>根据条件, 其实可以判断如下事实:</p>
<ul>
<li>有N个不同的数, 每个数的数量为1.</li>
<li>有一个数的数量为N.</li>
</ul>
<p>因此, 循环列表, 当发现某个数的数量为2时, 即可返回结果.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedNTimes</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        info_dict = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            info_dict[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> info_dict[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-29</li>
<li>击败比例: 91.46%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Two City Scheduling</title>
    <url>/2020/04/28/LeetCode/Two-City-Scheduling/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>There are <code>2N</code> people a company is planning to interview. The cost of flying the <code>i</code>-th person to city <code>A</code> is <code>costs[i][0]</code>, and the cost of flying the <code>i</code>-th person to city <code>B</code> is <code>costs[i][1]</code>.</p>
<p>Return the minimum cost to fly every person to a city such that exactly <code>N</code> people arrive in each city.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: </span><br><span class="line">The first person goes to city A for a cost of 10.</span><br><span class="line">The second person goes to city A for a cost of 30.</span><br><span class="line">The third person goes to city B for a cost of 50.</span><br><span class="line">The fourth person goes to city B for a cost of 20.</span><br><span class="line"></span><br><span class="line">The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= costs.length &lt;= 100</code></li>
<li>It is guaranteed that <code>costs.length</code> is even.</li>
<li><code>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</code></li>
</ol>
<hr>
<p>公司计划面试 <code>2N</code> 人。第 <code>i</code> 人飞往 <code>A</code> 市的费用为 <code>costs[i][0]</code>，飞往 <code>B</code> 市的费用为 <code>costs[i][1]</code>。</p>
<p>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 <code>N</code> 人抵达<strong>。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">输出：110</span><br><span class="line">解释：</span><br><span class="line">第一个人去 A 市，费用为 10。</span><br><span class="line">第二个人去 A 市，费用为 30。</span><br><span class="line">第三个人去 B 市，费用为 50。</span><br><span class="line">第四个人去 B 市，费用为 20。</span><br><span class="line"></span><br><span class="line">最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= costs.length &lt;= 100</code></li>
<li><code>costs.length</code> 为偶数</li>
<li><code>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>首先, 若不考虑把人等量地分成两堆, 要让费用最低的话, 就是每个人去哪个城市费用低, 就去哪个城市.</p>
<p>然后有以下两种情况:</p>
<ol>
<li>两个城市人数相等. 则直接将费用相加返回.</li>
<li>一个城市的人数比另外一个城市的人多, 在考虑转移时, 考虑的是转移后费用的差额要最小. 因此可以将人数多的那个城市的人按差额费用排序, 差额最小的那部分用于转移, 返回最后的费用.</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoCitySchedCost</span><span class="params">(self, costs)</span>:</span></span><br><span class="line">        num = len(costs) // <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        costs = [tuple(x) <span class="keyword">for</span> x <span class="keyword">in</span> costs]</span><br><span class="line">        a_dict = &#123;&#125;</span><br><span class="line">        b_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> costs:</span><br><span class="line">            <span class="keyword">if</span> c[<span class="number">0</span>] &lt; c[<span class="number">1</span>]:</span><br><span class="line">                a_dict[c] = abs(c[<span class="number">0</span>] - c[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b_dict[c] = abs(c[<span class="number">0</span>] - c[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> len(a_dict) == len(b_dict):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> a_dict:</span><br><span class="line">                res += k[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> b_dict:</span><br><span class="line">                res += k[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(a_dict) &lt; len(b_dict):</span><br><span class="line">            b_list = sorted(b_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">            delta_num = num - len(a_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> a_dict:</span><br><span class="line">                res += k[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(delta_num):</span><br><span class="line">                res += b_list[i][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(delta_num, len(b_dict)):</span><br><span class="line">                res += b_list[i][<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a_list = sorted(a_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">            delta_num = num - len(b_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> b_dict:</span><br><span class="line">                res += k[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(delta_num):</span><br><span class="line">                res += a_list[i][<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(delta_num, len(a_dict)):</span><br><span class="line">                res += a_list[i][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-28</li>
<li>击败比例: 95.00%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Greedy</category>
      </categories>
  </entry>
  <entry>
    <title>Split a String in Balanced Strings</title>
    <url>/2020/04/27/LeetCode/Split-a-String-in-Balanced-Strings/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><em>Balanced</em> strings are those who have equal quantity of ‘L’ and ‘R’ characters.</p>
<p>Given a balanced string <code>s</code> split it in the maximum amount of balanced strings.</p>
<p>Return the maximum amount of splitted balanced strings.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;RLRRLLRLRL&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: s can be split into &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, each substring contains same number of &apos;L&apos; and &apos;R&apos;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;RLLLLRRRLR&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: s can be split into &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, each substring contains same number of &apos;L&apos; and &apos;R&apos;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;LLLLRRRR&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: s can be split into &quot;LLLLRRRR&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;RLRRRLLRLL&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: s can be split into &quot;RL&quot;, &quot;RRRLLRLL&quot;, since each substring contains an equal number of &apos;L&apos; and &apos;R&apos;</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] = &#39;L&#39; or &#39;R&#39;</code></li>
</ul>
<hr>
<p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量<strong>。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;RLRRLLRLRL&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &apos;L&apos; 和 &apos;R&apos;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;RLLLLRRRLR&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &apos;L&apos; 和 &apos;R&apos;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;LLLLRRRR&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：s 只能保持原样 &quot;LLLLRRRR&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] = &#39;L&#39; 或 &#39;R&#39;</code></li>
<li>分割得到的每个字符串都必须是平衡字符串。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>按照题意, 原本的字符串中<code>L</code>和<code>R</code>的数量是相等的, 现在要拆分成尽可能多的子字符串, 使其仍然相等.</p>
<p>使用贪心的方法, 从左往右遍历字符串, 同时记录<code>L</code>和<code>R</code>的数量. 当两者的数量大于1且相等时, 算作一个有效地划分, 此时将返回结果加1, 同时将记录数量清零.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        num_L = <span class="number">0</span></span><br><span class="line">        num_R = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'L'</span>:</span><br><span class="line">                num_L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num_R += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num_L &gt; <span class="number">0</span> <span class="keyword">and</span> num_L == num_R:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                num_L = <span class="number">0</span></span><br><span class="line">                num_R = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-27</li>
<li>击败比例: 75.27%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Reorder Data in Log Files</title>
    <url>/2020/04/25/LeetCode/Reorder-Data-in-Log-Files/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>You have an array of <code>logs</code>. Each log is a space delimited string of words.</p>
<p>For each log, the first word in each log is an alphanumeric <em>identifier</em>. Then, either:</p>
<ul>
<li>Each word after the identifier will consist only of lowercase letters, or;</li>
<li>Each word after the identifier will consist only of digits.</li>
</ul>
<p>We will call these two varieties of logs <em>letter-logs</em> and <em>digit-logs</em>. It is guaranteed that each log has at least one word after its identifier.</p>
<a id="more"></a>
<p>Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order.</p>
<p>Return the final order of the logs.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]</span><br><span class="line">Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ol>
<li><code>0 &lt;= logs.length &lt;= 100</code></li>
<li><code>3 &lt;= logs[i].length &lt;= 100</code></li>
<li><code>logs[i]</code> is guaranteed to have an identifier, and a word after the identifier.</li>
</ol>
<hr>
<p>你有一个日志数组 <code>logs</code>。每条日志都是以空格分隔的字串。</p>
<p>对于每条日志，其第一个字为字母数字<em>标识符</em>。然后，要么：</p>
<ul>
<li>标识符后面的每个字将仅由小写字母组成，或；</li>
<li>标识符后面的每个字将仅由数字组成。</li>
</ul>
<p>我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。</p>
<p>将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按内容字母顺序排序，忽略标识符；在内容相同时，按标识符排序。数字日志应该按原来的顺序排列。</p>
<p>返回日志的最终顺序。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]</span><br><span class="line">输出：[&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= logs.length &lt;= 100</code></li>
<li><code>3 &lt;= logs[i].length &lt;= 100</code></li>
<li><code>logs[i]</code> 保证有一个标识符，并且标识符后面有一个字。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>首先理解题意中关于大小比较的规则, 其中<code>按内容字母顺序排序</code>在Python3中可以直接使用<code>&lt; or &gt;</code>进行比较.</p>
<p>考虑到排序的速度, 尽量使用内置的排序方法<code>sorted</code>. 同时指定其比较方法就行. 由于Python3的改动, 需要借助<code>cmp_to_key</code>将比较函数赋予<code>key</code>.</p>
<p>同时<code>sorted</code>函数默认是较小的排前面, 同时在比较函数中, 传入<code>a, b</code>:</p>
<ul>
<li>若<code>a &lt; b</code>, 返回-1.</li>
<li>若<code>a &gt; b</code>, 返回1.</li>
<li>相等返回0.</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs)</span>:</span></span><br><span class="line">        alpha_dict = &#123;&#125;</span><br><span class="line">        digit_list = []</span><br><span class="line">        <span class="keyword">for</span> log <span class="keyword">in</span> logs:</span><br><span class="line">            log_list = log.split(<span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">if</span> log_list[<span class="number">1</span>].isnumeric():</span><br><span class="line">                digit_list.append(log)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alpha_dict[log] = log_list</span><br><span class="line">        alpha_list = sorted(alpha_dict.items(), key=cmp_to_key(self.helper))</span><br><span class="line">        alpha_list = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> alpha_list]</span><br><span class="line">        <span class="keyword">return</span> alpha_list + digit_list</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a = a[<span class="number">1</span>]</span><br><span class="line">        b = b[<span class="number">1</span>]</span><br><span class="line">        id_a = a[<span class="number">0</span>]</span><br><span class="line">        id_b = b[<span class="number">0</span>]</span><br><span class="line">        a_str = <span class="string">' '</span>.join(a[<span class="number">1</span>:])</span><br><span class="line">        b_str = <span class="string">' '</span>.join(b[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> a_str &lt; b_str:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> a_str &gt; b_str:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> id_a &lt; id_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> id_a &gt; id_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-25</li>
<li>击败比例: 62.15%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Shortest Completing Word</title>
    <url>/2020/04/24/LeetCode/Shortest-Completing-Word/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Find the minimum length word from a given dictionary <code>words</code>, which has all the letters from the string <code>licensePlate</code>. Such a word is said to <em>complete</em> the given string <code>licensePlate</code></p>
<p>Here, for letters we ignore case. For example, <code>&quot;P&quot;</code> on the <code>licensePlate</code> still matches <code>&quot;p&quot;</code> on the word.</p>
<p>It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</p>
<p>The license plate might have the same letter occurring multiple times. For example, given a <code>licensePlate</code> of <code>&quot;PP&quot;</code>, the word <code>&quot;pair&quot;</code> does not complete the <code>licensePlate</code>, but the word <code>&quot;supper&quot;</code> does.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</span><br><span class="line">Output: &quot;steps&quot;</span><br><span class="line">Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.</span><br><span class="line">Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.</span><br><span class="line">Also note that we ignored case for the purposes of comparing whether a letter exists in the word.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]</span><br><span class="line">Output: &quot;pest&quot;</span><br><span class="line">Explanation: There are 3 smallest length words that contains the letters &quot;s&quot;.</span><br><span class="line">We return the one that occurred first.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>licensePlate</code> will be a string with length in range <code>[1, 7]</code>.</li>
<li><code>licensePlate</code> will contain digits, spaces, or letters (uppercase or lowercase).</li>
<li><code>words</code> will have a length in the range <code>[10, 1000]</code>.</li>
<li>Every <code>words[i]</code> will consist of lowercase letters, and have length in range <code>[1, 15]</code>.</li>
</ol>
<hr>
<p>如果单词列表（<code>words</code>）中的一个单词包含牌照（<code>licensePlate</code>）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。</p>
<p>单词在匹配牌照中的字母时不区分大小写，比如牌照中的 <code>&quot;P&quot;</code> 依然可以匹配单词中的 <code>&quot;p&quot;</code> 字母。</p>
<p>我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。</p>
<p>牌照中可能包含多个相同的字符，比如说：对于牌照 <code>&quot;PP&quot;</code>，单词 <code>&quot;pair&quot;</code> 无法匹配，但是 <code>&quot;supper&quot;</code> 可以匹配。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</span><br><span class="line">输出：&quot;steps&quot;</span><br><span class="line">说明：最短完整词应该包括 &quot;s&quot;、&quot;p&quot;、&quot;s&quot; 以及 &quot;t&quot;。对于 &quot;step&quot; 它只包含一个 &quot;s&quot; 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]</span><br><span class="line">输出：&quot;pest&quot;</span><br><span class="line">说明：存在 3 个包含字母 &quot;s&quot; 且有着最短长度的完整词，但我们返回最先出现的完整词。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>牌照<code>（licensePlate）</code>的长度在区域<code>[1, 7]</code>中。</li>
<li>牌照<code>（licensePlate）</code>将会包含数字、空格、或者字母（大写和小写）。</li>
<li>单词列表<code>（words）</code>长度在区间 <code>[10, 1000]</code> 中。</li>
<li>每一个单词 <code>words[i]</code> 都是小写，并且长度在区间 <code>[1, 15]</code> 中。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>利用一个字典, 存储需要匹配的字符与数量. 对于每个字符串, 同样得到其每个字符的数量, 与目标字典对比. 若符合要求, 则再比较是否最短.</p>
<p>若在循环过程中, 发现有单词长度等于目标字符串长度的, 停止循环, 直接返回.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestCompletingWord</span><span class="params">(self, licensePlate, words)</span>:</span></span><br><span class="line">        short_len = <span class="number">999</span></span><br><span class="line">        short_word = <span class="literal">None</span></span><br><span class="line">        license_len = <span class="number">0</span></span><br><span class="line">        info_dict = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> licensePlate.lower():</span><br><span class="line">            <span class="keyword">if</span> s.isalpha():</span><br><span class="line">                info_dict[s] += <span class="number">1</span></span><br><span class="line">                license_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            is_fit = <span class="literal">True</span></span><br><span class="line">            tmp_dict = defaultdict(int)</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">                tmp_dict[w] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> info_dict:</span><br><span class="line">                <span class="keyword">if</span> tmp_dict.get(k, <span class="number">-1</span>) &gt;= info_dict[k]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    is_fit = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> is_fit:</span><br><span class="line">                <span class="keyword">if</span> len(word) == license_len:</span><br><span class="line">                    <span class="keyword">return</span> word</span><br><span class="line">                <span class="keyword">if</span> len(word) &lt; short_len:</span><br><span class="line">                    short_len = len(word)</span><br><span class="line">                    short_word = word</span><br><span class="line">        <span class="keyword">return</span> short_word</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-24</li>
<li>击败比例: 78.52%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Walking Robot Simulation</title>
    <url>/2020/04/23/LeetCode/Walking-Robot-Simulation/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>A robot on an infinite grid starts at point (0, 0) and faces north. The robot can receive one of three possible types of commands:</p>
<ul>
<li><code>-2</code>: turn left 90 degrees</li>
<li><code>-1</code>: turn right 90 degrees</li>
<li><code>1 &lt;= x &lt;= 9</code>: move forward <code>x</code> units</li>
</ul>
<p>Some of the grid squares are obstacles. </p>
<a id="more"></a>
<p>The <code>i</code>-th obstacle is at grid point <code>(obstacles[i][0], obstacles[i][1])</code></p>
<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>
<p>Return the <strong>square</strong> of the maximum Euclidean distance that the robot will be from the origin.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: commands = [4,-1,3], obstacles = []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: robot will go to (3, 4)</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>0 &lt;= commands.length &lt;= 10000</code></li>
<li><code>0 &lt;= obstacles.length &lt;= 10000</code></li>
<li><code>-30000 &lt;= obstacle[i][0] &lt;= 30000</code></li>
<li><code>-30000 &lt;= obstacle[i][1] &lt;= 30000</code></li>
<li>The answer is guaranteed to be less than <code>2 ^ 31</code>.</li>
</ol>
<hr>
<p>机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：</p>
<ul>
<li><code>-2</code>：向左转 90 度</li>
<li><code>-1</code>：向右转 90 度</li>
<li><code>1 &lt;= x &lt;= 9</code>：向前移动 <code>x</code> 个单位长度</li>
</ul>
<p>在网格上有一些格子被视为障碍物。</p>
<p>第 <code>i</code> 个障碍物位于网格点  <code>(obstacles[i][0], obstacles[i][1])</code></p>
<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。</p>
<p>返回从原点到机器人的最大欧式距离的<strong>平方</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: commands = [4,-1,3], obstacles = []</span><br><span class="line">输出: 25</span><br><span class="line">解释: 机器人将会到达 (3, 4)</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">输出: 65</span><br><span class="line">解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= commands.length &lt;= 10000</code></li>
<li><code>0 &lt;= obstacles.length &lt;= 10000</code></li>
<li><code>-30000 &lt;= obstacle[i][0] &lt;= 30000</code></li>
<li><code>-30000 &lt;= obstacle[i][1] &lt;= 30000</code></li>
<li>答案保证小于 <code>2 ^ 31</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>一个提速的方法是将障碍物转化成集合的形式, 这样每次查询时很快.</p>
<p>同时还要注意, 最后的问题是过程中的最大距离, 而非最后终点的最大距离.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># turn right.</span></span><br><span class="line">        self.direction_map_0 = &#123;<span class="string">'up'</span>: <span class="string">'right'</span>,</span><br><span class="line">                                <span class="string">'right'</span>: <span class="string">'down'</span>,</span><br><span class="line">                                <span class="string">'down'</span>: <span class="string">'left'</span>,</span><br><span class="line">                                <span class="string">'left'</span>: <span class="string">'up'</span>&#125;</span><br><span class="line">        <span class="comment"># turn left.</span></span><br><span class="line">        self.direction_map_1 = &#123;<span class="string">'up'</span>: <span class="string">'left'</span>,</span><br><span class="line">                                <span class="string">'left'</span>: <span class="string">'down'</span>,</span><br><span class="line">                                <span class="string">'down'</span>: <span class="string">'right'</span>,</span><br><span class="line">                                <span class="string">'right'</span>: <span class="string">'up'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># direction.</span></span><br><span class="line">        self.direction = <span class="string">'up'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># location.</span></span><br><span class="line">        self.location = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        self.obstacles = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands, obstacles)</span>:</span></span><br><span class="line">        self.obstacles = set([(x[<span class="number">0</span>], x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> obstacles])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cmd <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> cmd &lt; <span class="number">0</span>:</span><br><span class="line">                self.change_direction(cmd)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(cmd):</span><br><span class="line">                    <span class="keyword">if</span> self.direction == <span class="string">'up'</span>:</span><br><span class="line">                        tmp_loc = (self.location[<span class="number">0</span>], self.location[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">if</span> self.is_obstacle(tmp_loc):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.location = tmp_loc</span><br><span class="line">                            res = max(res, abs(self.location[<span class="number">0</span>])**<span class="number">2</span> + abs(self.location[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">elif</span> self.direction == <span class="string">'down'</span>:</span><br><span class="line">                        tmp_loc = (self.location[<span class="number">0</span>], self.location[<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">if</span> self.is_obstacle(tmp_loc):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.location = tmp_loc</span><br><span class="line">                            res = max(res, abs(self.location[<span class="number">0</span>])**<span class="number">2</span> + abs(self.location[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">elif</span> self.direction == <span class="string">'left'</span>:</span><br><span class="line">                        tmp_loc = (self.location[<span class="number">0</span>] - <span class="number">1</span>, self.location[<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">if</span> self.is_obstacle(tmp_loc):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.location = tmp_loc</span><br><span class="line">                            res = max(res, abs(self.location[<span class="number">0</span>])**<span class="number">2</span> + abs(self.location[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tmp_loc = (self.location[<span class="number">0</span>] + <span class="number">1</span>, self.location[<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">if</span> self.is_obstacle(tmp_loc):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.location = tmp_loc</span><br><span class="line">                            res = max(res, abs(self.location[<span class="number">0</span>])**<span class="number">2</span> + abs(self.location[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_direction</span><span class="params">(self, turn)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> turn == <span class="number">-2</span>:</span><br><span class="line">            self.direction = self.direction_map_1[self.direction]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.direction = self.direction_map_0[self.direction]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_obstacle</span><span class="params">(self, loc)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> loc <span class="keyword">in</span> self.obstacles:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-23</li>
<li>击败比例: 20.88%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Greedy</category>
      </categories>
  </entry>
  <entry>
    <title>Divisor Game</title>
    <url>/2020/04/22/LeetCode/Divisor-Game/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Alice and Bob take turns playing a game, with Alice starting first.</p>
<p>Initially, there is a number <code>N</code> on the chalkboard. On each player’s turn, that player makes a <em>move</em> consisting of:</p>
<ul>
<li>Choosing any <code>x</code> with <code>0 &lt; x &lt; N</code> and <code>N % x == 0</code>.</li>
<li>Replacing the number <code>N</code> on the chalkboard with <code>N - x</code>.</li>
</ul>
<p>Also, if a player cannot make a move, they lose the game.</p>
<p>Return <code>True</code> if and only if Alice wins the game, assuming both players play optimally.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice chooses 1, and Bob has no more moves.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ol>
<hr>
<p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 <code>N</code> 。在每个玩家的回合，玩家需要执行以下操作：</p>
<ul>
<li>选出任一 <code>x</code>，满足 <code>0 &lt; x &lt; N</code> 且 <code>N % x == 0</code> 。</li>
<li>用 <code>N - x</code> 替换黑板上的数字 <code>N</code> 。</li>
</ul>
<p>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 <code>True</code>，否则返回 <code>false</code>。假设两个玩家都以最佳状态参与游戏。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><ul>
<li><p>数学思维:</p>
<p>这个方法是参照大佬们发布的答案. 因为每次选择的<code>x</code>小于<code>N</code>, 那么游戏最终都会进行到<code>2</code>, 并且谁拿到<code>2</code>谁赢, 否则输.</p>
<p>对于奇数来说, 其约数只能是奇数或者<code>1</code>, 那么减去后下一个数必然是偶数.</p>
<p>对于偶数来说, 其约数可奇可偶可<code>1</code>, 只要每次选择<code>1</code>, 那么下一个数必然是奇数.</p>
<p>因为爱丽丝先手, 所以若一开始是偶数, 爱丽丝只需要每次减去<code>1</code>, 这样使得自己总是偶数, 鲍勃总是奇数, 自己必胜. 反之鲍勃必胜.</p>
<p>总结起来, 只需要判断一开始的<code>N</code>的奇偶性!</p>
</li>
<li><p>动态规划:</p>
<p>数学思维奇妙而精彩, 但有时候靠自己不一定能想到, 动态规划是一种更加普适的方法.</p>
<p>如果是正常的两个人来玩这个游戏, 那么给定一个初始数字, 谁最后赢是不确定的. 但是题目假设两个人都处于最佳状态, 那么只要初始的<code>N</code>确定后, 最后谁赢就确定了.</p>
<p>假设爱丽丝一开始拿到一个<code>N</code>, 并且知道<code>N</code>的所有约数作为初始数值时, 两人的胜负关系, 那么只要其中一个是输, 只要在<code>N</code>上减去该约数, 将其传递给鲍勃, 自己必胜. 反之若约数作为初始值都是胜, 则爱丽丝必输.</p>
<p>利用动态规划, 维护一个列表, 列表索引表示初始值<code>N</code>, 列表中的值<code>0 or 1</code>表示该索引作为初始值能否最终获胜. 逐步得到最终初始值为<code>N</code>时的结果.</p>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul>
<li>方法一</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        dp_list = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp_list[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i // <span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">if</span> i % j == <span class="number">0</span> <span class="keyword">and</span> dp_list[i - j] == <span class="number">0</span>:</span><br><span class="line">                        dp_list[i] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp_list[N]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li><p>时间节点: 2020-04-22</p>
</li>
<li><p>击败比例: 97.87%</p>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Dynamic</category>
      </categories>
  </entry>
  <entry>
    <title>Sum of Even Numbers After Queries</title>
    <url>/2020/04/20/LeetCode/Sum-of-Even-Numbers-After-Queries/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We have an array <code>A</code> of integers, and an array <code>queries</code> of queries.</p>
<p>For the <code>i</code>-th query <code>val = queries[i][0], index = queries[i][1]</code>, we add val to <code>A[index]</code>. Then, the answer to the <code>i</code>-th query is the sum of the even values of <code>A</code>.</p>
<a id="more"></a>
<p><em>(Here, the given <code>index = queries[i][1]</code> is a 0-based index, and each query permanently modifies the array <code>A</code>.)</em></p>
<p>Return the answer to all queries. Your <code>answer</code> array should have <code>answer[i]</code> as the answer to the <code>i</code>-th query.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">At the beginning, the array is [1,2,3,4].</span><br><span class="line">After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>1 &lt;= queries.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li>
<li><code>0 &lt;= queries[i][1] &lt; A.length</code></li>
</ol>
<hr>
<p>给出一个整数数组 <code>A</code> 和一个查询数组 <code>queries</code>。</p>
<p>对于第 <code>i</code> 次查询，有 <code>val = queries[i][0], index = queries[i][1]</code>，我们会把 <code>val</code> 加到 <code>A[index]</code> 上。然后，第 <code>i</code> 次查询的答案是 <code>A</code> 中偶数值的和。</p>
<p><em>（此处给定的 <code>index = queries[i][1]</code> 是从 0 开始的索引，每次查询都会永久修改数组 <code>A</code>。）</em></p>
<p>返回所有查询的答案。你的答案应当以数组 <code>answer</code> 给出，<code>answer[i]</code> 为第 <code>i</code> 次查询的答案。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">输出：[8,6,2,4]</span><br><span class="line">解释：</span><br><span class="line">开始时，数组为 [1,2,3,4]。</span><br><span class="line">将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。</span><br><span class="line">将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。</span><br><span class="line">将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。</span><br><span class="line">将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>1 &lt;= queries.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li>
<li><code>0 &lt;= queries[i][1] &lt; A.length</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>最朴素的方法, 就是循环<code>queries</code>, 每次对<code>A</code>进行修改后, 将其中的偶数相加. 但这样的时间复杂度为$O(mn)$, $m$为<code>queries</code>的大小, $n$为<code>A</code>的大小.</p>
<p>一种改进的办法是每次根据<code>queries</code>的修改, 判断是将改索引上的数进行了怎样的转变:</p>
<ul>
<li>奇数 &gt; 偶数</li>
<li>奇数 &gt; 奇数</li>
<li>偶数 &gt; 偶数</li>
<li>偶数 &gt; 奇数</li>
</ul>
<p>根据不同情况, 在原有偶数总和上进行加减, 这样的时间复杂度变成了$O(m)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumEvenAfterQueries</span><span class="params">(self, A, queries)</span>:</span></span><br><span class="line">        even_sum = sum([x <span class="keyword">for</span> x <span class="keyword">in</span> A <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>])</span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries:</span><br><span class="line">            val, idx = q[<span class="number">0</span>], q[<span class="number">1</span>]</span><br><span class="line">            old_val = A[idx]</span><br><span class="line">            new_val = A[idx] + val</span><br><span class="line">            A[idx] = new_val</span><br><span class="line">            <span class="keyword">if</span> old_val % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> new_val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    even_sum += new_val</span><br><span class="line">                    res_list.append(even_sum)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res_list.append(even_sum)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> new_val % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    even_sum = even_sum - old_val + new_val</span><br><span class="line">                    res_list.append(even_sum)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    even_sum = even_sum - old_val</span><br><span class="line">                    res_list.append(even_sum)</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-20</li>
<li>击败比例: 34.76%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Find the Town Judge</title>
    <url>/2020/04/16/LeetCode/Find-the-Town-Judge/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>In a town, there are <code>N</code> people labelled from <code>1</code> to <code>N</code>. There is a rumor that one of these people is secretly the town judge.</p>
<p>If the town judge exists, then:</p>
<ol>
<li>The town judge trusts nobody.</li>
<li>Everybody (except for the town judge) trusts the town judge.</li>
<li>There is exactly one person that satisfies properties 1 and 2.</li>
</ol>
<p>You are given <code>trust</code>, an array of pairs <code>trust[i] = [a, b]</code> representing that the person labelled <code>a</code> trusts the person labelled <code>b</code>.</p>
<a id="more"></a>
<p>If the town judge exists and can be identified, return the label of the town judge. Otherwise, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N = 2, trust = [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
<li><code>trust.length &lt;= 10000</code></li>
<li><code>trust[i]</code> are all different</li>
<li><code>trust[i][0] != trust[i][1]</code></li>
<li><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></li>
</ol>
<hr>
<p>在一个小镇里，按从 <code>1</code> 到 <code>N</code> 标记了 <code>N</code> 个人。传言称，这些人中有一个是小镇上的秘密法官。</p>
<p>如果小镇的法官真的存在，那么：</p>
<ol>
<li>小镇的法官不相信任何人。</li>
<li>每个人（除了小镇法官外）都信任小镇的法官。</li>
<li>只有一个人同时满足属性 1 和属性 2 。</li>
</ol>
<p>给定数组 <code>trust</code>，该数组由信任对 <code>trust[i] = [a, b]</code> 组成，表示标记为 <code>a</code> 的人信任标记为 <code>b</code> 的人。</p>
<p>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N = 2, trust = [[1,2]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N = 3, trust = [[1,2],[2,3]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
<li><code>trust.length &lt;= 10000</code></li>
<li><code>trust[i]</code> 是完全不同的</li>
<li><code>trust[i][0] != trust[i][1]</code></li>
<li><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>利用图论的方法来理解这道题, 如果一个人信任另外一个人, 那么可以看成一个节点连接向另外个节点. 这样所有节点构成了一个有向无自环网络.</p>
<p>题目要求判断是否存在这样一个节点, 即其它节点均连接向他, 而他不连接向其它节点, 这样的节点若存在, 必然只有一个.</p>
<p>具体做法, 可以遍历列表中的二元组:</p>
<ul>
<li>若一个人信任另外一个人, 那么这个人必然不是法官.</li>
<li>若一个可能是法官的人被别人信任, 那么将其信任人数加一.</li>
</ul>
<p>最后, 可以统计可能是法官的人的信任人数是否符合要求来返回结果.</p>
<p>主要一些边界条件, 如只有一个人的时候, 这个人满足法官要求.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N, trust)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res_dict = defaultdict(int)</span><br><span class="line">        drop_set = set()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> trust:</span><br><span class="line">            drop_set.add(i)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> drop_set:</span><br><span class="line">                res_dict[j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> res_dict:</span><br><span class="line">                res_dict.pop(i)</span><br><span class="line">        <span class="keyword">if</span> len(drop_set) == N:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> res_dict:</span><br><span class="line">            <span class="keyword">if</span> res_dict[k] == N - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-16</li>
<li>击败比例: 97.19%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Graph</category>
      </categories>
  </entry>
  <entry>
    <title>License Key Formatting</title>
    <url>/2020/04/15/LeetCode/License-Key-Formatting/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p>
<a id="more"></a>
<p>Given a number K, we would want to reformat the strings such that each group contains <em>exactly</em> K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p>
<p>Given a non-empty string S and a number K, format the string according to the rules described above.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;5F3Z-2e-9-w&quot;, K = 4</span><br><span class="line"></span><br><span class="line">Output: &quot;5F3Z-2E9W&quot;</span><br><span class="line"></span><br><span class="line">Explanation: The string S has been split into two parts, each part has 4 characters.</span><br><span class="line">Note that the two extra dashes are not needed and can be removed.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;2-5g-3-J&quot;, K = 2</span><br><span class="line"></span><br><span class="line">Output: &quot;2-5G-3J&quot;</span><br><span class="line"></span><br><span class="line">Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>
<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>
<li>String S is non-empty.</li>
</ol>
<hr>
<p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符；而第一个分组中，至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p>
<p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;5F3Z-2e-9-w&quot;, K = 4</span><br><span class="line">输出：&quot;5F3Z-2E9W&quot;</span><br><span class="line">解释：字符串 S 被分成了两个部分，每部分 4 个字符；</span><br><span class="line">     注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;2-5g-3-J&quot;, K = 2</span><br><span class="line">输出：&quot;2-5G-3J&quot;</span><br><span class="line">解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol>
<li>S 的长度可能很长，请按需分配大小。K 为正整数。</li>
<li>S 只包含字母数字（a-z，A-Z，0-9）以及破折号’-‘</li>
<li>S 非空</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题应该是假设了<code>K</code>小于<code>S</code>的长度.</p>
<p>由于第一部分的长度可变, 所以利用求余, 得到第一部分.</p>
<p>然后根据<code>K</code>值得到后续每部分的字符串, 利用破折符<code>-</code>连接即可.</p>
<p>注意首尾不能有破折符, 以及大写转换.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">licenseKeyFormatting</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        S = S.replace(<span class="string">'-'</span>, <span class="string">''</span>)</span><br><span class="line">        init_i = len(S) % K</span><br><span class="line">        res = S[: init_i] + <span class="string">'-'</span></span><br><span class="line">        S = S[init_i:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S) // K):</span><br><span class="line">            res += S[i * K: (i + <span class="number">1</span>) * K] + <span class="string">'-'</span></span><br><span class="line">        <span class="keyword">return</span> res.strip(<span class="string">'-'</span>).upper()</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-15</li>
<li>击败比例: 85.67%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Number with Alternating Bits</title>
    <url>/2020/04/14/LeetCode/Binary-Number-with-Alternating-Bits/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">The binary representation of 5 is: 101</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: False</span><br><span class="line">Explanation:</span><br><span class="line">The binary representation of 7 is: 111.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 11</span><br><span class="line">Output: False</span><br><span class="line">Explanation:</span><br><span class="line">The binary representation of 11 is: 1011.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">The binary representation of 10 is: 1010.</span><br></pre></td></tr></table></figure>
<hr>
<p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">5的二进制数是: 101</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 7</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">7的二进制数是: 111</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">11的二进制数是: 1011</span><br></pre></td></tr></table></figure>
<p> <strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">10的二进制数是: 1010</span><br></pre></td></tr></table></figure>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>朴素的解法, 是将正整数转换为二进制, 然后检验是否符合1与0交替出现的条件.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAlternatingBits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> all([j == (<span class="string">'0'</span> <span class="keyword">if</span> i % <span class="number">2</span> <span class="keyword">else</span> <span class="string">'1'</span>) <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(bin(n)[<span class="number">2</span>:])])</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-14</li>
<li>击败比例: 63.03%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Bit</category>
      </categories>
  </entry>
  <entry>
    <title>Delete Columns to Make Sorted</title>
    <url>/2020/04/13/LeetCode/Delete-Columns-to-Make-Sorted/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We are given an array <code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
<p>For example, if we have an array <code>A = [&quot;``abcdef``&quot;,&quot;uvwxyz&quot;]</code> and deletion indices <code>{0, 2, 3}</code>, then the final array after deletions is <code>[&quot;bef&quot;, &quot;vyz&quot;]</code>, and the remaining columns of <code>A</code> are <code>[&quot;b&quot;``,&quot;``v&quot;]</code>, <code>[&quot;e&quot;,&quot;y&quot;]</code>, and <code>[&quot;f&quot;,&quot;z&quot;]</code>. (Formally, the <code>c</code>-th column is <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code>.)</p>
<a id="more"></a>
<p>Suppose we chose a set of deletion indices <code>D</code> such that after deletions, each remaining column in A is in <strong>non-decreasing</strong> sorted order.</p>
<p>Return the minimum possible value of <code>D.length</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">After choosing D = &#123;1&#125;, each column [&quot;c&quot;,&quot;d&quot;,&quot;g&quot;] and [&quot;a&quot;,&quot;f&quot;,&quot;i&quot;] are in non-decreasing sorted order.</span><br><span class="line">If we chose D = &#123;&#125;, then a column [&quot;b&quot;,&quot;a&quot;,&quot;h&quot;] would not be in non-decreasing sorted order.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: D = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: D = &#123;0, 1, 2&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 1000</code></li>
</ol>
<hr>
<p>给定由 <code>N</code> 个小写字母字符串组成的数组 <code>A</code>，其中每个字符串长度相等。</p>
<p><strong>删除</strong> 操作的定义是：选出一组要删掉的列，删去 <code>A</code> 中对应列中的所有字符，形式上，第 <code>n</code> 列为 <code>[A[0][n], A[1][n], ..., A[A.length-1][n]]</code>）。</p>
<p>比如，有 <code>A = [&quot;abcdef&quot;, &quot;uvwxyz&quot;]</code>，</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_1.png" alt="img"></p>
<p>要删掉的列为 <code>{0, 2, 3}</code>，删除后 <code>A</code> 为<code>[&quot;bef&quot;, &quot;vyz&quot;]</code>， <code>A</code> 的列分别为<code>[&quot;b&quot;,&quot;v&quot;], [&quot;e&quot;,&quot;y&quot;], [&quot;f&quot;,&quot;z&quot;]</code>。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_2.png" alt="img"></p>
<p>你需要选出一组要删掉的列 <code>D</code>，对 <code>A</code> 执行删除操作，使 <code>A</code> 中剩余的每一列都是 <strong>非降序</strong> 排列的，然后请你返回 <code>D.length</code> 的最小可能值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cba&quot;, &quot;daf&quot;, &quot;ghi&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">当选择 D = &#123;1&#125;，删除后 A 的列为：[&quot;c&quot;,&quot;d&quot;,&quot;g&quot;] 和 [&quot;a&quot;,&quot;f&quot;,&quot;i&quot;]，均为非降序排列。</span><br><span class="line">若选择 D = &#123;&#125;，那么 A 的列 [&quot;b&quot;,&quot;a&quot;,&quot;h&quot;] 就不是非降序排列了。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：D = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;zyx&quot;, &quot;wvu&quot;, &quot;tsr&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：D = &#123;0, 1, 2&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 1000</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>首先考虑<code>A</code>中只有一个字符串的情况, 直接返回0.</p>
<p>利用<code>zip</code>方法, 将<code>A</code>的字符串, 转换成列的形式.</p>
<p>在验证某一列是否是<code>非递增</code>的情况时, 我采用的方法是朴素地用相邻前后元素的比较. 只是使用了Python列表的特性来进行加速.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDeletionSize</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n_drop_col = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 转换为列的形式.</span></span><br><span class="line">        A_col = list(zip(*A))</span><br><span class="line">        <span class="comment"># 判断是否非递减.</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> A_col:</span><br><span class="line">            col = list(col)</span><br><span class="line">            col_0, col_1 = col[: <span class="number">-1</span>], col[<span class="number">1</span>:]</span><br><span class="line">            n_drop_col += any([col_0[x] &gt; col_1[x] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(col_0))])</span><br><span class="line">        <span class="keyword">return</span> n_drop_col</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-13</li>
<li>击败比例: 47.80%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Greedy</category>
      </categories>
  </entry>
  <entry>
    <title>Sum of Root To Leaf Binary Numbers</title>
    <url>/2020/04/10/LeetCode/Sum-of-Root-To-Leaf-Binary-Numbers/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a binary tree, each node has value <code>0</code> or <code>1</code>. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</p>
<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</p>
<p>Return the sum of these numbers.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,0,1,0,1,0,1]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree is between <code>1</code> and <code>1000</code>.</li>
<li>node.val is <code>0</code> or <code>1</code>.</li>
<li>The answer will not exceed <code>2^31 - 1</code>.</li>
</ol>
<hr>
<p>给出一棵二叉树，其上每个结点的值都是 <code>0</code> 或 <code>1</code> 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数 <code>01101</code>，也就是 <code>13</code> 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>以 <strong><code>10^9 + 7</code></strong> 为<strong>模</strong>，返回这些数字之和。</p>
<p><strong>示例：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/05/sum-of-root-to-leaf-binary-numbers.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,0,1,0,1,0,1]</span><br><span class="line">输出：22</span><br><span class="line">解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>树中的结点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>
<li>node.val 为 <code>0</code> 或 <code>1</code> 。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>利用某种方式遍历树, 这里采用深度优先法遍历.</p>
<p>在遍历途中, 记录沿途节点值, 并在遇到叶子节点后, 保存该二进制值.</p>
<p>最后将二进制进行转换求和, 返回结果.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.str_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRootToLeaf</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.helper(root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> sum([int(x, <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> self.str_list])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, node, str_)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.str_list.append(str_ + str(node.val))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.helper(node.left, str_ + str(node.val))</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.helper(node.right, str_ + str(node.val))</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-10</li>
<li>击败比例: 50.43%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Tree</category>
      </categories>
  </entry>
  <entry>
    <title>Matrix Cells in Distance Order</title>
    <url>/2020/04/09/LeetCode/Matrix-Cells-in-Distance-Order/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We are given a matrix with <code>R</code> rows and <code>C</code> columns has cells with integer coordinates <code>(r, c)</code>, where <code>0 &lt;= r &lt; R</code> and <code>0 &lt;= c &lt; C</code>.</p>
<p>Additionally, we are given a cell in that matrix with coordinates <code>(r0, c0)</code>.</p>
<p>Return the coordinates of all cells in the matrix, sorted by their distance from <code>(r0, c0)</code> from smallest distance to largest distance. Here, the distance between two cells <code>(r1, c1)</code> and <code>(r2, c2)</code> is the Manhattan distance, <code>|r1 - r2| + |c1 - c2|</code>. (You may return the answer in any order that satisfies this condition.)</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class="line">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]</span><br><span class="line">There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
<hr>
<p>给出 <code>R</code> 行 <code>C</code> 列的矩阵，其中的单元格的整数坐标为 <code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code> 且 <code>0 &lt;= c &lt; C</code>。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 <code>(r0, c0)</code> 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>一种朴素的思路是, 循环计算得到各个格点, 到目标格点的距离.</p>
<p>利用字典, 距离作为key, 将距离相同的格点放到一起作为value.</p>
<p>对字典的key进行排序, 然后整理结果返回.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allCellsDistOrder</span><span class="params">(self, R, C, r0, c0)</span>:</span></span><br><span class="line">        info_dict = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(R):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(C):</span><br><span class="line">                distance = int(abs(row - r0) + abs(col - c0))</span><br><span class="line">                info_dict[distance].append([row, col])</span><br><span class="line">        info_list = sorted(info_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> info_list:</span><br><span class="line">            res_list += v</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-09</li>
<li>击败比例: 82.92%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Sort</category>
      </categories>
  </entry>
  <entry>
    <title>Day of the Week</title>
    <url>/2020/04/08/LeetCode/Day-of-the-Week/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a date, return the corresponding day of the week for that date.</p>
<p>The input is given as three integers representing the <code>day</code>, <code>month</code> and <code>year</code> respectively.</p>
<p>Return the answer as one of the following values <code>{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}</code>.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: day = 31, month = 8, year = 2019</span><br><span class="line">Output: &quot;Saturday&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: day = 18, month = 7, year = 1999</span><br><span class="line">Output: &quot;Sunday&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: day = 15, month = 8, year = 1993</span><br><span class="line">Output: &quot;Sunday&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li>The given dates are valid dates between the years <code>1971</code> and <code>2100</code>.</li>
</ul>
<hr>
<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>
<p>输入为三个整数：<code>day</code>、<code>month</code> 和 <code>year</code>，分别表示日、月、年。</p>
<p>您返回的结果必须是这几个值中的一个 <code>{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：day = 31, month = 8, year = 2019</span><br><span class="line">输出：&quot;Saturday&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：day = 18, month = 7, year = 1999</span><br><span class="line">输出：&quot;Sunday&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：day = 15, month = 8, year = 1993</span><br><span class="line">输出：&quot;Sunday&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给出的日期一定是在 <code>1971</code> 到 <code>2100</code> 年之间的有效日期。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>可以自己实现一个时间转化功能, 但是作为python的默认自带包<code>datetime</code>, 用来做这个题目就很简单了, 根据<code>年份</code>, <code>月份</code>, <code>天</code>来创建一个时间对象, 然后从对象中取<code>星期</code>就行.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dayOfTheWeek</span><span class="params">(self, day, month, year)</span>:</span></span><br><span class="line">        dt = datetime(year, month, day)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>, <span class="string">"Saturday"</span>, <span class="string">"Sunday"</span>][dt.weekday()]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-08</li>
<li>击败比例: 85.33%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>PySpark学习笔记(一)</title>
    <url>/2020/04/03/%E5%A4%A7%E6%95%B0%E6%8D%AE/PySpark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p>我暂时的工作还没有怎么用到Spark, 但作为一个处理大数据几乎必会的东西, 我认为还是很有必要学习的. 我记得我大概在一年多以前, 一个劲在那学习Hadoop, Spark, Hive什么的, 处理数据的方法没学多少, 搭建分布式环境倒是捣鼓了好久. 后来工作以后我才知道, 术业有专攻, 有一种职位叫做大数据工程师, 像搭建和维护大数据环境这些工作, 交给他们就好了. 如果不是专门做这个的, 了解一下当然好, 不过如果时间有限的话, 应该优先学习自己用的到的部分.</p>
<a id="more"></a>
<h1 id="什么是Spark"><a href="#什么是Spark" class="headerlink" title="什么是Spark"></a>什么是Spark</h1><p>Spark是一种集群计算平台, Spark可以让我们分布式地在集群的多个节点上处理数据. 当数据集很大时, 分布式处理会更加地快捷.</p>
<p>那么在考虑是否Spark可以作为一个较好的解决我们问题的方案时, 可以考虑一下两个问题:</p>
<ul>
<li>是否数据量很大, 以至于单机难以处理. 以我的经验, 当数据量达到百万量级时, pandas就会有些吃力了.</li>
<li>处理的方法是否容易被并行化.</li>
</ul>
<p>Spark的整体架构采用的是多个节点相互连接, 其中有一个主节点Master, 对应多个子节点Worker. 主节点主要负责任务的调度管理, 子节点负责实际的计算处理.</p>
<p>Spark可以在多种模式下运行:</p>
<ul>
<li>单机模式.</li>
<li>Standalone, 即Spark自带的集群模式.</li>
<li>YARN等其它模式下运行.</li>
</ul>
<p>考虑到学习成本问题, Spark本身的源码是由Scala写的, 但是拥有Java, R, Python的接口, PySpark就是Python对应的接口.</p>
<h1 id="单机环境安装"><a href="#单机环境安装" class="headerlink" title="单机环境安装"></a>单机环境安装</h1><p>如果想在单机环境下测试运行PySpark, 非常简单, 直接利用<code>pip</code>安装就行. 对于集群环境的安装和配置, 这里暂时不涉及. 当我们要使用一个已经搭建好的Spark集群的时候, 只需要在本地连接上集群使用即可, 与单机环境在表面上没有明显差别.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install pyspqrk</span><br></pre></td></tr></table></figure>
<h1 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h1><p>在老版本的Spark中, 通过<code>SparkContext</code>, <code>SQLContext</code>等来进行连接和交互. 而在新版本中, 老的方式仍然可用, 不过大部分常用的功能整合到了<code>SparkSession</code>这个类里面, 建议使用<code>SparkSession</code>进行连接与交互.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载模块.</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建环境(单机).</span></span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">                    .master(<span class="string">'local[*]'</span>) \</span><br><span class="line">                    .appName(<span class="string">'test'</span>) \</span><br><span class="line">                    .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印版本号</span></span><br><span class="line">print(spark.version)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束会话.</span></span><br><span class="line">spark.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># SparkContext可用通过spark获取.</span></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本次应用名称.</span></span><br><span class="line">app_name = spark.conf.get(<span class="string">'spark.app.name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取driver端口.</span></span><br><span class="line">driver_tcp_port = spark.conf.get(<span class="string">'spark.driver.port'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取partitions数量.</span></span><br><span class="line">num_partitions = spark.conf.get(<span class="string">'spark.sql.shuffle.partitions'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改partitions数量.</span></span><br><span class="line">spark.conf.set(<span class="string">'spark.sql.shuffle.partitions'</span>, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><p>在Spark中, 核心数据结构被称为RDD(Resilient Distributed Dataset), 即弹性分布式数据集. 这是一种偏底层的数据结构, 相对DataFrame不方便进行使用, 但仍然需要学习一些基础的操作.</p>
<ul>
<li><p>构建RDD.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用列表构建.</span></span><br><span class="line">rdd = sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字符串构建.</span></span><br><span class="line">rdd = sc.parallelize(<span class="string">'Hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本构建.</span></span><br><span class="line">rdd = sc.textFile(file_path, minPartitions=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看元素信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定数量查看.</span></span><br><span class="line">rdd.take(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看全部元素.</span></span><br><span class="line">rdd.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计元素个数.</span></span><br><span class="line">rdd.count()</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map操作.</span></span><br><span class="line">rdd = rdd.map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter操作.</span></span><br><span class="line">rdd = rdd.filter(<span class="keyword">lambda</span> x: x == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flatMap操作.</span></span><br><span class="line">rdd = sc.parallelize([<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>])</span><br><span class="line">rdd = rdd.flatMap(<span class="keyword">lambda</span> x: list(x))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pair RDD.</p>
<p>一些时候, 如果数据是成对出现的, 如key-value的形式, 那么Pair RDD可以给到很多方便的处理方式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用列表构建Pair RDD.</span></span><br><span class="line">rdd = sc.parallelize([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">6</span>), (<span class="number">4</span>, <span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对相同的key进行reduce.</span></span><br><span class="line">rdd = rdd.reduceByKey(<span class="keyword">lambda</span> x, y: x + y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用key进行排序.</span></span><br><span class="line">rdd = rdd.sortByKey(ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不同key的元素进行计数.</span></span><br><span class="line">rdd_count = rdd.countByKey()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出.</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> rdd.collect(): </span><br><span class="line">    print(<span class="string">"Key &#123;&#125; Value &#123;&#125;"</span>.format(num[<span class="number">0</span>], num[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不同元素计数.</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> rdd_count.items(): </span><br><span class="line">		print(<span class="string">"key"</span>, k, <span class="string">"has"</span>, v, <span class="string">"counts"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><p>Spark的DataFrame类似于pandas的DataFrame, 同时还支持SQL. Spark对DataFrame进行了大量地优化, 所以在使用时应该尽量使用内部已有的方法.</p>
<h2 id="使用SQL"><a href="#使用SQL" class="headerlink" title="使用SQL"></a>使用SQL</h2><ul>
<li><p>查看在目录中的表.</p>
<p>类似数据库的表, 单机模式没有预设的情况想输出为<code>[]</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(spark.catalog.listTables())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>将已有DF加入catalog.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.createOrReplaceTempView(<span class="string">'table_name'</span>)</span><br><span class="line"></span><br><span class="line">print(spark.catalog.listTables())</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用SQL进行查询.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SQL</span></span><br><span class="line">query = <span class="string">"FROM table_name SELECT * LIMIT 10"</span></span><br><span class="line"></span><br><span class="line">df = spark.sql(query)</span><br><span class="line"></span><br><span class="line">df.show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><ul>
<li><p>csv.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create an DataFrame from file_path</span></span><br><span class="line">df = spark.read.csv(file_path, header=<span class="literal">True</span>, inferSchema=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>parquet.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Save the df DataFrame in Parquet format</span></span><br><span class="line">df.write.parquet(<span class="string">'file.parquet'</span>, mode=<span class="string">'overwrite'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the Parquet file into a new DataFrame</span></span><br><span class="line">spark.read.parquet(<span class="string">'file.parquet'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>schema.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import the pyspark.sql.types library</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a new schema using the StructType method</span></span><br><span class="line">people_schema = StructType([</span><br><span class="line">  <span class="comment"># Define a StructField for each field</span></span><br><span class="line">  StructField(<span class="string">'name'</span>, StringType(), <span class="literal">False</span>),</span><br><span class="line">  StructField(<span class="string">'age'</span>, IntegerType(), <span class="literal">False</span>),</span><br><span class="line">  StructField(<span class="string">'city'</span>, StringType(), <span class="literal">False</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">df = spark.read.csv(<span class="string">"df.csv"</span>, sep=<span class="string">';'</span>, header=<span class="literal">False</span>, schema=schema)</span><br><span class="line"></span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="不同数据格式转换"><a href="#不同数据格式转换" class="headerlink" title="不同数据格式转换"></a>不同数据格式转换</h2><ul>
<li><p>RDD转DF.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a list of tuples</span></span><br><span class="line">sample_list = [(<span class="string">'Mona'</span>,<span class="number">20</span>), (<span class="string">'Jennifer'</span>,<span class="number">34</span>),(<span class="string">'John'</span>,<span class="number">20</span>), (<span class="string">'Jim'</span>,<span class="number">26</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a RDD from the list</span></span><br><span class="line">rdd = sc.parallelize(sample_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a PySpark DataFrame</span></span><br><span class="line">df = spark.createDataFrame(rdd, schema=[<span class="string">'Name'</span>, <span class="string">'Age'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Spark DF转换pandas DF.</p>
<p>当数据较小时(百万量级以下), 可以用pandas处理. 或者先抽样, 再使用pandas处理.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.toPandas()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽样后再转换.</span></span><br><span class="line">sample_df = df.select([<span class="string">'a'</span>, <span class="string">'b'</span>]).sample(<span class="literal">False</span>, <span class="number">0.5</span>, <span class="number">42</span>)</span><br><span class="line">pandas_df = sample_df.toPandas()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图.</span></span><br><span class="line">sns.lmplot(x=<span class="string">'a'</span>, y=<span class="string">'b'</span>, data=pandas_df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas DF转换Spark DF.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.createDataFrame(df)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li><p>查看有哪些列.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看一些统计信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># describe</span></span><br><span class="line">df.describe().show()</span><br><span class="line">df.describe(<span class="string">'a'</span>, <span class="string">'b'</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集大小.</span></span><br><span class="line">df.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关性.</span></span><br><span class="line">df.corr(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 独特值.</span></span><br><span class="line">df.select(<span class="string">'col'</span>).distinct().show(<span class="number">40</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列名称.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.withColumnRenamed(<span class="string">'old'</span>, <span class="string">'new'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择某些列的数据.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一.</span></span><br><span class="line">df = df[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二.</span></span><br><span class="line">df = df.select(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line">df = df.select(df[<span class="string">'a'</span>], df[<span class="string">'b'</span>], df[<span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三.</span></span><br><span class="line">col = (df[<span class="string">'a'</span>] / (df[<span class="string">'b'</span>] / <span class="number">60</span>)).alias(<span class="string">"col"</span>)</span><br><span class="line"></span><br><span class="line">df = df.select(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, col)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法四.</span></span><br><span class="line">df = df.selectExpr(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a/(b/60) as col"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.drop(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">df = df.drop(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>生成新的一列.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过已有列转换.</span></span><br><span class="line">df = df.withColumn(<span class="string">'new_col'</span>, df[<span class="string">'col'</span>] / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用已有外部数据赋予(不常用), 这里暂时的办法比较繁琐.</span></span><br><span class="line">id_df = df[[<span class="string">'id'</span>]].toPandas()</span><br><span class="line">id_df[<span class="string">'new_col'</span>] = data</span><br><span class="line"></span><br><span class="line">id_df = spark.createDataFrame(id_df)</span><br><span class="line"></span><br><span class="line">df = df.join(id_df, on=<span class="string">'id'</span>, how=<span class="string">'left'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>修改数据类型.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> FloatType, IntegerType, StringType</span><br><span class="line"></span><br><span class="line">df = df.withColumn(<span class="string">'col'</span>, df[<span class="string">'col'</span>].cast(FloatType()))</span><br><span class="line"></span><br><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>条件筛选.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .where 与 .filter 一样.</span></span><br><span class="line">df = df.where(df[<span class="string">'col'</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">df = df.filter(df[<span class="string">'col'</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可使用SQL.</span></span><br><span class="line">df = df.where(<span class="string">'col &gt; 0'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计一些信息时, 需要先进行groupBy.</span></span><br><span class="line">df.groupBy().min(<span class="string">"col"</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对某一列进行groupBy.</span></span><br><span class="line">df_g = df.groupBy(<span class="string">"col"</span>)</span><br><span class="line"></span><br><span class="line">df_g.count().show()</span><br><span class="line">df_g.avg(<span class="string">"a"</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载内置函数.</span></span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">df_g = df.groupBy(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">df_g.avg(<span class="string">'c'</span>).show()</span><br><span class="line"></span><br><span class="line">df_g.agg(F.stddev(<span class="string">'d'</span>)).show()</span><br><span class="line"></span><br><span class="line">df_g.count().sort(<span class="string">"count"</span>,ascending=<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>拼接.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 横向拼接.</span></span><br><span class="line">df = df.join(df_1, on=<span class="string">'b'</span>, how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向拼接.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>交叉表.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.crosstab(<span class="string">'a'</span>, <span class="string">'b'</span>).sort(<span class="string">"a_b"</span>).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺失值填充.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.fillna(&#123;<span class="string">"col"</span>: <span class="string">'val'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>常用函数.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># when.</span></span><br><span class="line">df = df.withColumn(<span class="string">'col_1'</span>, (when(con_0, <span class="number">1</span>)</span><br><span class="line">                             .when(con_1, <span class="number">0</span>)</span><br><span class="line">                             .otherwise(<span class="literal">None</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># contains.</span></span><br><span class="line">df = df.filter(df[<span class="string">'col'</span>].contains(<span class="string">'a'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># split.</span></span><br><span class="line">df = df.withColumn(<span class="string">'splits'</span>, F.split(df[<span class="string">'col'</span>], <span class="string">'\s+'</span>))</span><br><span class="line">df = df.withColumn(<span class="string">'first_name'</span>, df.splits.getItem(<span class="number">0</span>))</span><br><span class="line">df = df.withColumn(<span class="string">'last_name'</span>, df.splits.getItem(F.size(<span class="string">'splits'</span>) - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># rand.</span></span><br><span class="line"><span class="comment">## 生成随机数.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># monotonically_increasing_id.</span></span><br><span class="line"><span class="comment">## 获得一列递增不重复的列.</span></span><br><span class="line">df = df.withColumn(<span class="string">'ROW_ID'</span>, F.monotonically_increasing_id())</span><br><span class="line"></span><br><span class="line">previous_max_ID = voter_df_march.select(<span class="string">'ROW_ID'</span>).rdd.max()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">df_new = df_new.withColumn(<span class="string">'ROW_ID'</span>, F.monotonically_increasing_id() + previous_max_ID)</span><br></pre></td></tr></table></figure>
</li>
<li><p>UDF.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> functions <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">spark_my_func = F.udf(my_func, IntegerType())</span><br><span class="line">  </span><br><span class="line">df = df.withColumn(<span class="string">'new_col'</span>, spark_my_func(df[<span class="string">'col'</span>]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>持久化.</p>
<p>由于Spark独特的机制, 使得一些时候, 对于主要的并且重复使用的内容进行持久化的操作, 会很大地加快运行速度.</p>
<p>持久化的方法有两个, cache与persist:</p>
<ul>
<li>cache: 使用非序列化的方式将数据全部尝试持久化到内存中.</li>
<li>persist: 手动选择持久化级别. 默认级别同cache.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.cache()</span><br><span class="line"></span><br><span class="line">df.is_cached</span><br><span class="line"></span><br><span class="line">df.unpersist()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul>
<li><p>时间转换.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> to_date</span><br><span class="line"></span><br><span class="line">df = df.withColumn(<span class="string">'date'</span>, to_date(<span class="string">'date'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取日期中的元素.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> dayofweek, year</span><br><span class="line"></span><br><span class="line">df = df.withColumn(<span class="string">'dayofweek'</span>, dayofweek(<span class="string">'date'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算前后时间间隔.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> lag, datediff</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.window <span class="keyword">import</span> Window</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create window</span></span><br><span class="line">w = Window().orderBy(df[<span class="string">'date'</span>])</span><br><span class="line"><span class="comment"># Create lag column</span></span><br><span class="line">df = df.withColumn(<span class="string">'lag-1'</span>, lag(<span class="string">'date'</span>, count=<span class="number">1</span>).over(w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate difference between date columns</span></span><br><span class="line">df = df.withColumn(<span class="string">'date_diff'</span>, datediff(<span class="string">'date'</span>, <span class="string">'lag-1'</span>))</span><br><span class="line"><span class="comment"># Print results</span></span><br><span class="line">df.select(<span class="string">'date_diff'</span>).distinct().show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>本篇主要总结了基础的RDD, DataFrame的操作方法, 下一篇中将总结一些常见的机器学习相关的方法.</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>Find Common Characters</title>
    <url>/2020/04/01/LeetCode/Find-Common-Characters/</url>
    <content><![CDATA[<h1 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h1><p>Given an array <code>A</code> of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list <strong>(including duplicates)</strong>. For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">Output: [&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> is a lowercase letter</li>
</ol>
<hr>
<p>给定仅有小写字母组成的字符串数组 <code>A</code>，返回列表中的每个字符串中都显示的全部字符（<strong>包括重复字符</strong>）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> 是小写字母</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题目就是要求找出列表中, 所有字符串都有的公共字符串, 且同时要计算其最小数量.</p>
<p>可以利用一个字典来统计字符的数量, 以列表的第一个字符串(或者以列表最短字符串)来初始化字典. 然后对后续列表的每个字符串做如下操作:</p>
<ul>
<li>遍历字典的key(没有在字典中的, 肯定不是公有的),统计其在字符串中的数量.</li>
<li>若数量为0, 则删除字典的这个key.</li>
<li>若数量不为0, 则改变字典的value, 取值为value和数量的较小值.</li>
</ul>
<p>最后根据字典的信息, 表示成列表返回就行.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commonChars</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        info_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> A[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> info_dict:</span><br><span class="line">                info_dict[s] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                info_dict[s] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> string <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">            drop_list = []</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> info_dict:</span><br><span class="line">                n_s = string.count(s)</span><br><span class="line">                <span class="keyword">if</span> n_s == <span class="number">0</span>:</span><br><span class="line">                    drop_list.append(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    info_dict[s] = min(n_s, info_dict[s])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> drop_list:</span><br><span class="line">                info_dict.pop(s)</span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> info_dict:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(info_dict[s]):</span><br><span class="line">                res_list.append(s)</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-04-01</li>
<li>击败比例: 91.10%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Cousins in Binary Tree</title>
    <url>/2020/03/30/LeetCode/Cousins-in-Binary-Tree/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>In a binary tree, the root node is at depth <code>0</code>, and children of each depth <code>k</code> node are at depth <code>k+1</code>.</p>
<p>Two nodes of a binary tree are <em>cousins</em> if they have the same depth, but have <strong>different parents</strong>.</p>
<p>We are given the <code>root</code> of a binary tree with unique values, and the values <code>x</code> and <code>y</code> of two different nodes in the tree.</p>
<p>Return <code>true</code> if and only if the nodes corresponding to the values <code>x</code> and <code>y</code> are cousins.</p>
 <a id="more"></a>
<p><strong>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4], x = 2, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree will be between <code>2</code> and <code>100</code>.</li>
<li>Each node has a unique integer value from <code>1</code> to <code>100</code>.</li>
</ol>
<hr>
<p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>
<p>如果二叉树的两个节点深度相同，但<strong>父节点不同</strong>，则它们是一对<em>堂兄弟节点</em>。</p>
<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code>，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code>。</p>
<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p><strong>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,null,4], x = 2, y = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>
<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>比较简单的一道题了, 最直接的方法, 是按某种方式遍历, 然后记录目标值节点的层数以及父节点, 最后做比较.</p>
<p>一种相对更快的方式, 不用遍历整棵树, 而是逐层搜索. </p>
<ol>
<li><p>当某一个节电的两个子节点不为空, 且值正好是两个目标值时, 返回false.</p>
</li>
<li><p>当一层中所有节点的值包含两个目标值, 返回true.</p>
</li>
<li>当一层中所有节点的值仅包含其中一个值时, 返回false.</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCousins</span><span class="params">(self, root, x, y)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        root: 根结点.</span></span><br><span class="line"><span class="string">        x: int.</span></span><br><span class="line"><span class="string">        y: int.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        x_y_tuple = (x, y)</span><br><span class="line">        node_list = [root]</span><br><span class="line">        <span class="keyword">while</span> len(node_list) &gt; <span class="number">0</span>:</span><br><span class="line">            next_node_list = []</span><br><span class="line">            next_node_val_list = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">                left_val, right_val = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    next_node_list.append(node.left)</span><br><span class="line">                    next_node_val_list.append(node.left.val)</span><br><span class="line">                    left_val = node.left.val</span><br><span class="line">                <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    next_node_list.append(node.right)</span><br><span class="line">                    next_node_val_list.append(node.right.val)</span><br><span class="line">                    right_val = node.right.val</span><br><span class="line">                <span class="keyword">if</span> left_val <span class="keyword">in</span> x_y_tuple <span class="keyword">and</span> right_val <span class="keyword">in</span> x_y_tuple:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> next_node_val_list <span class="keyword">and</span> y <span class="keyword">in</span> next_node_val_list:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> next_node_val_list <span class="keyword">and</span> y <span class="keyword">not</span> <span class="keyword">in</span> next_node_val_list:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> next_node_val_list <span class="keyword">and</span> y <span class="keyword">not</span> <span class="keyword">in</span> next_node_val_list:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node_list = next_node_list</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-30</li>
<li>击败比例: 81.92%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Tree</category>
      </categories>
  </entry>
  <entry>
    <title>Mac配置优化</title>
    <url>/2020/03/27/%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/Mac%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>话说为啥会用到Mac Pro呢, 原本我用的小黑, 原因是近期为了搭梯子, 使得连接公司的VPN损坏Σ(っ °Д °;)っ</p>
<p>然后经过一番原因排查, 知道了是因为这个梯子和Windows下的EC会起冲突.</p>
<p>其实如果排除玩游戏, Office, 以及一些必要的社交工具如微信, 钉钉(这排除的有点多啊喂), 我个人是更喜欢Ubuntu的, WIndows系统实在一言难尽つ﹏⊂</p>
<p>于是我将目光投向了Mac OS, 买Mac Pro, 是的我看中的是苹果系统. 但在人生第一次开箱后, 我被震惊了, 这一眼看过去就很高级的做工, 这低调内敛, 精益求精的态度, 我甚至想下一部手机也换Iphone好了(｡･∀･)ﾉﾞ</p>
<a id="more"></a>
<h1 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h1><p>有一说一, 对于习惯了常规键盘布局的我来说, 已经形成了肌肉记忆, 在编辑文字或者写代码的时候, 效率还行. 而Mac的键盘布局发生了变化, 一开始用得真的不习惯, 希望后面慢慢适应吧.</p>
<p>同时, Mac上有些常规的键没有, 比如<code>Home</code>, <code>End</code>, <code>PageUp</code>, <code>PageDown</code>等等, 这些可以由组合键完成.</p>
<ul>
<li><p>Home: fn left or cmd left</p>
</li>
<li><p>End: fn right or cmd right</p>
</li>
<li><p>PageUp: fn up</p>
</li>
<li><p>PageDown: fn down</p>
</li>
<li><p>Delete: fn backspace</p>
</li>
<li><p>按单词移动: option left or option right</p>
</li>
<li><p>iTerm2快捷键设置:</p>
<p>总体思路是查询原有快捷键, 将其配置赋予自定义的快捷键.</p>
<ul>
<li><p>按单词移动:</p>
<p>Preferences &gt; Profiles &gt; Keys</p>
<p>option left Send Escape Sequence b</p>
<p>option right Send Escape Sequence f</p>
</li>
<li><p>按单词删除:</p>
<p>Preferences &gt; Profiles &gt; Keys</p>
<p>Left Option: Normal &gt; Esc+</p>
</li>
<li><p>整行删除:</p>
<p>Preferences &gt; Keys</p>
<p>cmd backspace Send Hex Codes 0x15</p>
</li>
<li><p>移动到句首/尾:</p>
<p>Preferences &gt; Keys</p>
<p>cmd left/right Send Hex Codes 0x01/0x05</p>
</li>
<li><p>撤销:</p>
<p>Preferences &gt; Profiles &gt; Keys</p>
<p>cmd z Send Hex Codes 0x01/0x1f</p>
</li>
</ul>
</li>
</ul>
<h1 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h1><p>系统偏好设置 &gt; 触控板</p>
<p><img src="chukongban_0.png" alt="触控板0"></p>
<p><img src="chukongban_1.png" alt="触控板1"></p>
<p>系统偏好设置 &gt; 辅助功能 &gt; 鼠标与触控板 &gt; 触控板选项</p>
<p><img src="chukongban_2.png" alt="触控板2"></p>
<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><p>原本Mac自带的输入法有如下一些问题:</p>
<ul>
<li>智能输入体验差.</li>
<li>中英文切换是原本的大写锁定键. 按逗号, 句号键无法查看更多候选.</li>
<li>虽然设定里面有设定半角模式, 但实际上没用. 这一点对于俺这样的小码农来说是最难受的.</li>
</ul>
<p>所以尝试了一下<strong>搜狗输入法Mac版</strong>, 不得不说, 真滴好用, 不愧是<strong>中文输入法界永远滴神!</strong></p>
<p>需要进行一些设置:</p>
<ul>
<li>全局半角.</li>
<li>关闭TouchBar功能, 关闭小图标(语音, 截图这些功能对我来说多余了).</li>
</ul>
<p>相比自带的输入法, 上面提到的问题都不再是问题, 而且如果愿意可以自定义更加适合自己的东西, 比如斗图, 颜表情…用搜狗输入法写到这里, 我还没有翻过提示页, 我这么说, 你懂吧.</p>
<h1 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h1><p>Mac自带的文本编辑器, 很难使, 只能说可以正常打字吧, 嗯.</p>
<p>所以需要一款功能多一些, 但仍然轻量级的文本编辑器, 这里我选择的是<strong>Sublime Text</strong>.</p>
<p>安装方法是直接到官网下载安装.</p>
<p>配置命令行方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -sv &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl</span><br></pre></td></tr></table></figure>
<h1 id="基础APP"><a href="#基础APP" class="headerlink" title="基础APP"></a>基础APP</h1><p>包含但不限于:</p>
<ul>
<li>钉钉</li>
<li>微信</li>
<li>Chrome</li>
<li>EeasyConnect</li>
<li>ClashX</li>
<li>Tencent lemon</li>
<li>The Unarchiver</li>
</ul>
<h1 id="生产工具"><a href="#生产工具" class="headerlink" title="生产工具"></a>生产工具</h1><ul>
<li><p>Anaconda3</p>
<p>可在清华镜像下载. 安装完成后, 需要将路径写入环境变量<code>~/.zsh_profile</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Anaconda3.</span><br><span class="line">export PATH=&quot;/Users/opt/anaconda3/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>
<p>安装Jupyter插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  # 安装nbextensions.</span><br><span class="line">  $ pip install jupyter_contrib_nbextensions</span><br><span class="line">  $ jupyter contrib nbextension install --user</span><br><span class="line">  # 安装nbextensions_configurator.</span><br><span class="line">  $ pip install jupyter_nbextensions_configurator</span><br><span class="line">  $ jupyter nbextensions_configurator enable --user</span><br><span class="line">  # 安装yapf, 使用代码格式标准化工具时需要.</span><br><span class="line">pip install yapf</span><br></pre></td></tr></table></figure>
<p>安装完成后, 勾选如下配置:</p>
<ul>
<li><code>Codefolding</code> &amp; <code>Codefolding in Editor</code>: 代码折叠.</li>
<li><code>Move selected cells</code>: 按住<code>option</code>可上下移动<code>cells</code>.</li>
<li><code>Toggle all line numbers</code>: 显示行数.</li>
<li><code>AutoSaveTime</code>: 自动按时保存.</li>
<li><code>Hide Header</code>: <code>control H</code>隐藏/展现工具栏.</li>
<li><code>Highlight selected word</code>: 变量高亮.</li>
<li><code>Table of Contents</code>: 目录.</li>
<li><code>Code prettify</code>: 代码格式美化.</li>
<li><code>ExecuteTime</code>: 显示代码执行时间.</li>
<li><code>ScrollDown</code>: 输出自动下滑.</li>
</ul>
</li>
<li><p>PyCharm</p>
<p>下载安装, 并配置解释器路径和主题.</p>
</li>
<li><p>Office</p>
<p>下载官网最新版, 然后寻找激活方法. 可选择装部分应用.</p>
</li>
<li><p>Git</p>
<p>一般自带. 需要创建公钥私钥, GitHub关联.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node.js</p>
<p>官网下载安装.</p>
</li>
<li><p>typora</p>
<p>官网下载安装.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在~/.zsh_profile中添加如下, 使其可在终端快速启动.</span><br><span class="line">alias typora=&quot;open -a typora&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>java8</p>
<p>为了配合<code>Spark</code>的使用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更新brew库.</span><br><span class="line">$ brew tap homebrew/cask-versions</span><br><span class="line"># 制定版本安装.</span><br><span class="line">$ brew cask install adoptopenjdk8</span><br><span class="line"># 查看是否安装成功.</span><br><span class="line">$ java -version</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><ul>
<li><p>homebrew</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iTerm2</p>
<p>官网下载安装.</p>
<p>设置为默认终端.</p>
<p>调整字体大小15, 光标闪动, 色彩对比度.</p>
<p>preference =&gt; Keys =&gt; Hotkey =&gt; Show/hide iTerm2 with a system-wide hotkey, 设置为command ..</p>
<p>preference  =&gt; profiles =&gt; colors =&gt; Color Presets =&gt; Solarized Light.</p>
</li>
<li><p>oh-my-zsh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看安装的shell.</span><br><span class="line">$ cat /etc/shells</span><br><span class="line"># 查看当前shell.</span><br><span class="line">$ echo $SHELL</span><br><span class="line"># 切换shell.</span><br><span class="line">$ chsh -s /bin/zsh</span><br><span class="line"># 安装oh-my-zsh</span><br><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置oh-my-zsh.</span><br><span class="line">$ open -t .zshrc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 主题列表: https://github.com/ohmyzsh/ohmyzsh/wiki/themes</span><br><span class="line">ZSH_THEME=avit</span><br><span class="line"># 插件.</span><br><span class="line">plugins=(git osx zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 插件中的zsh-autosuggestions 和 zsh-syntax-highlighting 是自定义安装的插件, 需要用 git 将插件 clone 到指定插件目录下：</span><br><span class="line"># 自动提示插件</span><br><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br><span class="line"># 语法高亮插件</span><br><span class="line">git clone git://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h1><p><code>.DS_Store</code>这个文件没什么用, 但是却会在很多传输文件的时候带来不必要的问题. 比如在使用<code>Git</code>的时候.</p>
<p>有没有什么办法能够完全禁止呢? 暂时没找到.</p>
<p>删除所有目录下的<code>.DS_Store</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo find / -name &quot;.DS_Store&quot; -depth -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>这条命令可以临时删除, 但后续只要文件夹有一些改动, 又回自动生成.</p>
<p>针对<code>Git</code>, 可以设定全局的<code>.gitignore_global</code>进行一定程度上的帮助. 创建<code>~/.gitignore_global</code>, 其中写入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .gitignore_global</span><br><span class="line">####################################</span><br><span class="line">######## OS generated files ########</span><br><span class="line">####################################</span><br><span class="line">.DS_Store</span><br><span class="line">.DS_Store?</span><br></pre></td></tr></table></figure>
<p>同时在<code>~./gitconfig</code>中引入设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = xxx</span><br><span class="line">	email = xxx</span><br><span class="line">[core]</span><br><span class="line">	excludesfile = /Users/shy/.gitignore_global</span><br></pre></td></tr></table></figure>
<p>或者输入如下命令(推荐):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br></pre></td></tr></table></figure>
<h1 id="TouchBar"><a href="#TouchBar" class="headerlink" title="TouchBar"></a>TouchBar</h1><p>最开始我觉得Mac的TouchBar是鸡肋, 花里胡哨的, 还我<code>F1~F12</code>(ﾟДﾟ*)ﾉ</p>
<p>比如Pycharm里面的<code>运行</code>快捷键是<code>shift F10</code>, 你这都没有这个键怎么办啊? 哦…变成<code>cmd shift R</code>了啊, 那没事了…</p>
<p>TouchBar的存在, 可以在系统层面, 或者一些APP上, 将一些功能直接放上去, 只要设置合理, 在熟练使用以后, 我相信效率是会提高的.</p>
<p>系统层面的TouchBar设置, 这个根据自己喜好就行. 我是将<code>调度管理</code>,<code>截屏</code>, <code>静音</code>设置成默认, 同时将<code>调度管理</code>, <code>截屏</code>, <code>音量调节</code>, <code>亮度调节</code>, <code>锁屏</code>, <code>睡眠</code>放到详细页.</p>
<p>一些APP, 比如PyCharm是支持定制TouchBar的. 对PyCharm来说, 可以在<code>Preferences &gt; Appearance &amp; Behavior &gt; Menus and Tollbars &gt; Touch Bar</code>中进行设置.</p>
<p>但是关于显示图标, 需要自己指定图案. 我在谷歌上搜索<code>touchbar icon download</code>这个关键词, 找到了<a href="https://community.folivora.ai/t/v3-update-native-apple-touch-bar-icon-pack-for-btt/3310/18" target="_blank" rel="noopener">这个网站</a>, 提供了TouchBar图标的下载地址.</p>
<p>然鹅, 直接使用里面的图标, 仍然会觉得有些蛋疼(* ￣︿￣), 因为你看自带的TouchBar图标, 都是亮亮的, 咱这图标是黑黑的, 白天用着还行, 光线不好的时候用着一片黑啊…</p>
<p>于是, 我想到了利用Python来修改图标颜色, 经过一番尝试, 成功了（＃￣～￣＃）</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">path=<span class="string">'image.png'</span></span><br><span class="line">im = Image.open(path)</span><br><span class="line">im.show()</span><br><span class="line"></span><br><span class="line">print(im.format)</span><br><span class="line">print(im.mode)</span><br><span class="line">print(im.size)</span><br><span class="line"></span><br><span class="line">source = im.split()</span><br><span class="line">source = (source[<span class="number">0</span>].point(<span class="keyword">lambda</span> i: <span class="number">255</span>), source[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">im = Image.merge(im.mode, source)</span><br><span class="line"></span><br><span class="line">im.show()</span><br><span class="line">im.save(<span class="string">'new_image.png'</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码的思路, 是咱们手里的原始图片, 是<code>LA</code>格式的, 众所周知<code>RGB</code>格式有三个通道, 而这种格式呢有两个通道. 第一个通道控制颜色, 0 ~ 255, 其中0是黑色, 255是白色; 第二个通道控制是否透明, 0 ~ 255, 0表示透明, 255表示不透明. 所以我们只要将第一个通道的数值, 全部改为255即可o(≧口≦)o</p>
<p>由此, 我在PyCharm的TouchBar上, 配置了<code>Home</code>, <code>End</code>等功能, 某种程度上加快了编辑效率.</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><p>删除一些无用APP</p>
<p>菜单栏 &gt; 关于本机 &gt; 储存空间 &gt; 管理</p>
<p>在其中可以看到一些可删除的系统自带的APP, 删除后可以节省几个G的空间.</p>
</li>
<li><p>设置访达的侧边栏</p>
<p>访达 &gt; 偏好设置</p>
<p>设置开启新窗口为用户根目录. 并将其显示到边栏中.</p>
</li>
</ul>
<h1 id="键盘-1"><a href="#键盘-1" class="headerlink" title="键盘"></a>键盘</h1><p>为了拥有更好的体验, 我买了一块外接无线键盘. 主要就是为了<code>Hone</code>, <code>End</code>, <code>PageUp</code>, <code>PageDown</code>, <code>Delete</code>键. 然后当我买入后, 发现, 这些键是有了, 但是在一些APP上的功能却不是我所想的. 比如想要移动光标到当前行第一列或者最后一列, 使用<code>cmd left/right</code>肯定是可以的, 但是<code>Home</code>和<code>End</code>却不一定行…还好与代码编辑相关的PyCharm与Jupyter可以与预期一致.</p>
]]></content>
      <categories>
        <category>流程记录</category>
      </categories>
  </entry>
  <entry>
    <title>Binary Gap</title>
    <url>/2020/03/26/LeetCode/Binary-Gap/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a positive integer <code>N</code>, find and return the longest distance between two consecutive 1’s in the binary representation of <code>N</code>.</p>
<p>If there aren’t two consecutive 1’s, return 0.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 22</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">22 in binary is 0b10110.</span><br><span class="line">In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.</span><br><span class="line">The first consecutive pair of 1&apos;s have distance 2.</span><br><span class="line">The second consecutive pair of 1&apos;s have distance 1.</span><br><span class="line">The answer is the largest of these two distances, which is 2.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">5 in binary is 0b101.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">6 in binary is 0b110.</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">8 in binary is 0b1000.</span><br><span class="line">There aren&apos;t any consecutive pairs of 1&apos;s in the binary representation of 8, so we return 0.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ul>
<hr>
<p>给定一个正整数 <code>N</code>，找到并返回 <code>N</code> 的二进制表示中两个连续的 1 之间的最长距离。 </p>
<p>如果没有两个连续的 1，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：22</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">22 的二进制是 0b10110 。</span><br><span class="line">在 22 的二进制表示中，有三个 1，组成两对连续的 1 。</span><br><span class="line">第一对连续的 1 中，两个 1 之间的距离为 2 。</span><br><span class="line">第二对连续的 1 中，两个 1 之间的距离为 1 。</span><br><span class="line">答案取两个距离之中最大的，也就是 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：5</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">5 的二进制是 0b101 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：6</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">6 的二进制是 0b110 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：8</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">8 的二进制是 0b1000 。</span><br><span class="line">在 8 的二进制表示中没有连续的 1，所以返回 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>我的方法是先将数字转换成2进制, 然后去除首尾的<code>0</code>, 再利用<code>1</code>进行分割, 对分割得到的最长子字符串, 返回其长度加一.</p>
<p>需要考虑的边界情况:</p>
<ul>
<li>全是0.</li>
<li>只有一个1.</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryGap</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        list_ = [len(x) + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> bin(N)[<span class="number">2</span>:].strip(<span class="string">'0'</span>).split(<span class="string">'1'</span>)]</span><br><span class="line">        <span class="keyword">if</span> len(list_) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(list_)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-26</li>
<li>击败比例: 69.24%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>Univalued Binary Tree</title>
    <url>/2020/03/25/LeetCode/Univalued-Binary-Tree/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>A binary tree is <em>univalued</em> if every node in the tree has the same value.</p>
<p>Return <code>true</code> if and only if the given tree is univalued.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,1,1,1,1,null,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,2,2,5,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
<li>Each node’s value will be an integer in the range <code>[0, 99]</code>.</li>
</ol>
<hr>
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,1,1,null,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,5,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数范围是 <code>[1, 100]</code>。</li>
<li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>非常简单的一道题, 按照某种顺序进行遍历, 当发现出现不一样的数字时, 返回<code>false</code>, 否在返回<code>true</code>.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.val = <span class="literal">None</span></span><br><span class="line">        self.res = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.val = root.val</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> self.res:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> node.val != self.val:</span><br><span class="line">            self.res = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.helper(node.left)</span><br><span class="line">        self.helper(node.right)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-25</li>
<li>击败比例: 36.63%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Tree</category>
      </categories>
  </entry>
  <entry>
    <title>Goat Latin</title>
    <url>/2020/03/24/LeetCode/Goat-Latin/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>A sentence <code>S</code> is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>
<p>We would like to convert the sentence to “<em>Goat Latin”</em> (a made-up language similar to Pig Latin.)</p>
<a id="more"></a>
<p>The rules of Goat Latin are as follows:</p>
<ul>
<li><p>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.<br> For example, the word ‘apple’ becomes ‘applema’.</p>
</li>
<li><p>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.<br> For example, the word <code>&quot;goat&quot;</code> becomes <code>&quot;oatgma&quot;</code>.</p>
</li>
<li><p>Add one letter <code>&#39;a&#39;</code> to the end of each word per its word index in the sentence, starting with 1.<br> For example, the first word gets <code>&quot;a&quot;</code> added to the end, the second word gets <code>&quot;aa&quot;</code> added to the end and so on.</p>
</li>
</ul>
<p>Return the final sentence representing the conversion from <code>S</code> to Goat Latin. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;I speak Goat Latin&quot;</span><br><span class="line">Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<ul>
<li><code>S</code> contains only uppercase, lowercase and spaces. Exactly one space between each word.</li>
<li><code>1 &lt;= S.length &lt;= 150</code>.</li>
</ul>
<hr>
<p>给定一个由空格分割单词的句子 <code>S</code>。每个单词只包含大写或小写字母。</p>
<p>我们要将句子转换为 <em>“Goat Latin”</em>（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。</p>
<p>山羊拉丁文的规则如下：</p>
<ul>
<li>如果单词以元音开头（a, e, i, o, u），在单词后添加<code>&quot;ma&quot;</code>。<br> 例如，单词<code>&quot;apple&quot;</code>变为<code>&quot;applema&quot;</code>。</li>
<li>如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加<code>&quot;ma&quot;</code>。<br> 例如，单词<code>&quot;goat&quot;</code>变为<code>&quot;oatgma&quot;</code>。</li>
<li>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母<code>&#39;a&#39;</code>，索引从1开始。<br> 例如，在第一个单词后添加<code>&quot;a&quot;</code>，在第二个单词后添加<code>&quot;aa&quot;</code>，以此类推。</li>
</ul>
<p>返回将 <code>S</code> 转换为山羊拉丁文后的句子。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;I speak Goat Latin&quot;</span><br><span class="line">输出: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">输出: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li><code>S</code> 中仅包含大小写字母和空格。单词间有且仅有一个空格。</li>
<li><code>1 &lt;= S.length &lt;= 150</code>。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>太简单了, 没啥好说的, 嗯.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        res_str = <span class="string">''</span></span><br><span class="line">        str_list = S.split(<span class="string">' '</span>)</span><br><span class="line">        str_set = set([<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>,</span><br><span class="line">                       <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>])</span><br><span class="line">        <span class="keyword">for</span> i, str_ <span class="keyword">in</span> enumerate(str_list):</span><br><span class="line">            <span class="keyword">if</span> str_[<span class="number">0</span>] <span class="keyword">in</span> str_set:</span><br><span class="line">                res_str += str_ + <span class="string">'ma'</span> + <span class="string">'a'</span> * (i + <span class="number">1</span>) + <span class="string">' '</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res_str += str_[<span class="number">1</span>:] + str_[<span class="number">0</span>] + <span class="string">'ma'</span> + <span class="string">'a'</span> * (i + <span class="number">1</span>) + <span class="string">' '</span></span><br><span class="line">        <span class="keyword">return</span> res_str[: <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-24</li>
<li>击败比例: 63.24%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>String</category>
      </categories>
  </entry>
  <entry>
    <title>Add to Array-Form of Integer</title>
    <url>/2020/03/22/LeetCode/Add-to-Array-Form-of-Integer/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>For a non-negative integer <code>X</code>, the <strong>array-form of <code>X</code></strong> is an array of its digits in left to right order. For example, if <code>X = 1231</code>, then the array form is <code>[1,2,3,1]</code>.</p>
<p>Given the array-form <code>A</code> of a non-negative integer <code>X</code>, return the array-form of the integer <code>X+K</code>.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [1,2,0,0], K = 34</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Explanation: 1200 + 34 = 1234</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [2,7,4], K = 181</span><br><span class="line">Output: [4,5,5]</span><br><span class="line">Explanation: 274 + 181 = 455</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [2,1,5], K = 806</span><br><span class="line">Output: [1,0,2,1]</span><br><span class="line">Explanation: 215 + 806 = 1021</span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">Output: [1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Explanation: 9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure>
<p><strong>Note：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 9</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
<li>If <code>A.length &gt; 1</code>, then <code>A[0] != 0</code></li>
</ol>
<hr>
<p>对于非负整数 <code>X</code> 而言，<em><code>X</code></em> 的<em>数组形式</em>是每位数字按从左到右的顺序形成的数组。例如，如果 <code>X = 1231</code>，那么其数组形式为 <code>[1,2,3,1]</code>。</p>
<p>给定非负整数 <code>X</code> 的数组形式 <code>A</code>，返回整数 <code>X+K</code> 的数组形式。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,0,0], K = 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 = 1234</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [2,7,4], K = 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 = 455</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [2,1,5], K = 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 = 1021</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">输出：[1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">解释：9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 9</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
<li>如果 <code>A.length &gt; 1</code>，那么 <code>A[0] != 0</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p><strong>方法一</strong>: 列表转化成整数, 相加后, 再拆解成列表.</p>
<p><strong>方法二</strong>: 将<code>K</code>与<code>A</code>的数字(倒序)逐位相加, 将<code>模10的余数</code>留下, <code>整除10的结果</code>继续与<code>A</code>的下一位相加, 循环重复. 若完成对<code>A</code>的循环后, <code>K</code>还不止一位, 则逐位拆解.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToArrayForm</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param A: list(int, ...)</span></span><br><span class="line"><span class="string">        :param K: int</span></span><br><span class="line"><span class="string">        :return: list(int, ...)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> str(int(reduce(<span class="keyword">lambda</span> x, y: x + y, map(str, A))) + K)]</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToArrayForm</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param A: list(int, ...)</span></span><br><span class="line"><span class="string">        :param K: int</span></span><br><span class="line"><span class="string">        :return: list(int, ...)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        res_list = []</span><br><span class="line">        A.reverse()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            K += i</span><br><span class="line">            res_list.append(K % <span class="number">10</span>)</span><br><span class="line">            K = K // <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> K != <span class="number">0</span>:</span><br><span class="line">            res_list.append(K % <span class="number">10</span>)</span><br><span class="line">            K = K //<span class="number">10</span></span><br><span class="line">        res_list.reverse()</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-22</li>
<li>击败比例: 90.67%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Range Sum of BST</title>
    <url>/2020/03/21/LeetCode/Range-Sum-of-BST/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given the <code>root</code> node of a binary search tree, return the sum of values of all nodes with value between <code>L</code> and <code>R</code> (inclusive).</p>
<p>The binary search tree is guaranteed to have unique values.</p>
 <a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root = [10,5,15,3,7,null,18], L = 7, R = 15</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree is at most <code>10000</code>.</li>
<li>The final answer is guaranteed to be less than <code>2^31</code>.</li>
</ol>
<hr>
<p>给定二叉搜索树的根结点 <code>root</code>，返回 <code>L</code> 和 <code>R</code>（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], L = 7, R = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>树中的结点数量最多为 <code>10000</code> 个。</li>
<li>最终的答案保证小于 <code>2^31</code>。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p><strong>方法一</strong>: 直接使用递归进行整个树的遍历, 将满足要求的数加和.</p>
<p><strong>方法二</strong>: 利用<code>BST</code>的特性, 减少搜索时间, 即当遇到不满足要求的节点时, 放弃搜索.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.L = <span class="literal">None</span></span><br><span class="line">        self.R = <span class="literal">None</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span><span class="params">(self, root, L, R)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.L = L</span><br><span class="line">        self.R = R</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> node.val &gt;= self.L <span class="keyword">and</span> node.val &lt;= self.R:</span><br><span class="line">            self.res += node.val</span><br><span class="line">        self.helper(node.left)</span><br><span class="line">        self.helper(node.right)</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.L = <span class="literal">None</span></span><br><span class="line">        self.R = <span class="literal">None</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span><span class="params">(self, root, L, R)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.L = L</span><br><span class="line">        self.R = R</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> node.val &gt;= self.L <span class="keyword">and</span> node.val &lt;= self.R:</span><br><span class="line">            self.res += node.val</span><br><span class="line">            self.helper(node.left)</span><br><span class="line">            self.helper(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; self.L:</span><br><span class="line">            self.helper(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.helper(node.left)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-21</li>
<li>击败比例: 75.05%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Tree</category>
      </categories>
  </entry>
  <entry>
    <title>创建属于自己的博客(三)</title>
    <url>/2020/03/20/%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89/</url>
    <content><![CDATA[<p>这一篇是本系列的终篇, 主要介绍一个方法.</p>
<p>问题是这样的, 我在笔记本A上搭建博客, 并进行文章的编辑和推送部署. 现在我换了一台笔记本B, 那如果我想在B上面进行继续创作应该怎么办呢? 以后某一天由需要用A进行创作呢?</p>
<p>相信很多同学已经想到了, 没错, 还是基于<code>Github</code>来进行操作.</p>
<a id="more"></a>
<h1 id="创建一个用于管理博客的仓库"><a href="#创建一个用于管理博客的仓库" class="headerlink" title="创建一个用于管理博客的仓库"></a>创建一个用于管理博客的仓库</h1><p>在篇章一中, 我们创建了一个名为<code>xiaoming.github.io</code>的仓库, 这是我们用来管理博客的仓库吗?</p>
<p>当然不是啦, 对比一下咱们本地和它的文件布局就知道, 这个仓库存放的, 是我们<code>$ hexo d</code>时, 推送的博客相关文件的仓库, 并不包含其它的文件.</p>
<p>于是我们还需要创建一个仓库, 比如命名为<code>my_blog</code>.</p>
<h1 id="本地远端关联"><a href="#本地远端关联" class="headerlink" title="本地远端关联"></a>本地远端关联</h1><p>创建好<code>my_blog</code>以后, 进入到<code>笔记本A</code>本地博客的根目录(假设也叫<code>my_blog</code>), 执行一波如下操作, 经常使用<code>Github</code>的同学应该很熟悉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd my_blog/</span><br><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@github.com:xiaoming/my_blog.git  # 根据自己实际地址进行修改.</span><br></pre></td></tr></table></figure>
<p>那这时候可能有同学就说说了, 啊我知道了, 接下来<code>add commit push</code>就完事了.</p>
<p>但是此时存在一个问题,  在<code>my_blog</code>中, 存在几个<code>Git子模块</code>, 就是一个大的Git仓库里面, 还有小的Git仓库.</p>
<p>还记得篇章一中, 咱们在<code>theme/</code>中利用clone的<code>Next</code>主题吗, 这是一个子模块; 后来我们在执行<code>$ hexo d</code>时, 是将<code>my_blog/.deploy_git/</code>这个子模块push到了Github.</p>
<p>子模块的存在, 在一些开发项目中可以带来很多便利, 但是在咱们这里并不需要, 鉴于本宝宝不怎么使用Git子模块(对, 我就不会​​), 所以需要一些额外的操作, 消除子模块的存在, 以此来保证后续<code>add commit push</code>的顺利进行.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下操作只用执行一次, 除非以后跟新主题.</span><br><span class="line">$ cd my_blog/theme/</span><br><span class="line">$ rm -rf .git/</span><br></pre></td></tr></table></figure>
<p>在根目录添加<code>.gitignore</code>文件, 并将<code>.deploy_git/</code>写入.</p>
<p>Ok, 现在假设已经执行<code>$ hexo d</code>了, 就可以执行如下代码, 推送到远端的<code>my_blog</code>仓库了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add -A</span><br><span class="line">$ git commit -m &quot;happy day&quot;</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h1 id="在另外一台电脑上"><a href="#在另外一台电脑上" class="headerlink" title="在另外一台电脑上"></a>在另外一台电脑上</h1><p>经过上面的一顿操作, 接下来就是要在<code>笔记本B</code>上写博客了.</p>
<p>首先我们要保证<code>笔记本B</code>上也有相应的轮子<code>Git &amp; Node.js</code>, 照着篇章一就ok.</p>
<p>然后, 假设我们也在<code>笔记本B</code>上创建了一个<code>my_blog</code>的文件夹:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd my_blog/</span><br><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@github.com:xiaoming/my_blog.git</span><br><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>
<p>为了验证是否移植成功, 可以在本地看一下效果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>如果在<code>localhost:4000</code>中看到了自己的博客, 说明一切尽在掌握.</p>
<p>那接下来, 就可以在<code>笔记本B</code>写博客, 推送部署了.</p>
]]></content>
      <categories>
        <category>流程记录</category>
      </categories>
  </entry>
  <entry>
    <title>创建属于自己的博客(二)</title>
    <url>/2020/03/20/%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C/</url>
    <content><![CDATA[<p>在上一篇中, 记录了使用<code>Hexo</code>来搭建博客的基础操作, 这一篇紧接上一篇, 来介绍更多的东西.</p>
<p>因为后续可能为博客添加更多的功能, 所以本篇章后续还会更新.</p>
<a id="more"></a>
<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>一般来说都会保留一个页面, 来展示博主的一些信息, <code>about</code>或者<code>关于</code>页面就是用来做这个的.</p>
<p>其文件路径在<code>source/about/index.md</code>, 按照自己想法, 利用<code>Markdown</code>的语法进行编辑就好.</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>尽管一个良好的博客, 有<code>分类</code>或者<code>标签</code>, 来帮助大家快速找到自己想要看的文章, 但是当文章数量日渐增长, 同时没有找到对应的<code>分类</code>时, 怎么办? </p>
<p>此时就需要<code>本地搜索</code>.</p>
<p>感恩大神, 如果没有额外的需求, 我们只需要做如下操作, 就能拥有<code>本地搜索</code>的功能.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>在根目录下的<code>_config.yml</code>中添加如下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>
<p>重新编译博客后, 会发现多了一个<code>搜索</code>的功能, 敲好用!</p>
<h1 id="流量统计"><a href="#流量统计" class="headerlink" title="流量统计"></a>流量统计</h1><p>我想大部分同学还是想知道, 自己的博客/文章被多少人看过, 被看过多少次这样的信息.</p>
<p>统计这样的信息有不少方法和途径, 这里我使用的是一款叫做<code>不蒜子</code>的插件.</p>
<p>使用方法非常简单, 再次感恩大神.</p>
<p>只需要将主题文件中的<code>_config.yml</code>修改一下就行, 就这么简单.​</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
<p>然后在网页的底部会显示整个博客的流量, 文章的开头会显示本篇文章的流量.</p>
<p>这里再说一句, 在本地测试<code>$ hexo s</code>时看到的流量数据是虚假的.</p>
<h1 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h1><p>想要在文章中插图, 方式主要有两种: </p>
<ul>
<li>将图片放置与网络图床, 然后直接引用就行.</li>
<li>将图片放置于博客根目录下的某目录中, 然后再用相对路径/绝对路径引用.</li>
</ul>
<p>这里介绍相对路径的方法, 这样我认为更加方便管理一些. 方法非常简单, 即在文章存在的文件夹中, 创建一个同文章名的文件夹, 用于存放该文章的图片.</p>
<p>如文章路径为<code>source/_post/happy_day.md</code>, 放置图片的文件夹路径为<code>source/_post/happy_day/</code></p>
<p>而在文章中插入图片(假设图片路径为<code>source/_post/happy_day/happy.png</code>)时, 语法为<code>![我是图](happy.png)</code></p>
<p>如果觉得每次同时创建文章和放置图片的同名文件夹麻烦, 可以修改<code>_config.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>以后每次创建文章<code>$ hexo new xxx</code>时, 就会同时出现<code>xxx.md</code>和<code>xxx/</code>.</p>
<h1 id="数学公式换行"><a href="#数学公式换行" class="headerlink" title="数学公式换行"></a>数学公式换行</h1><p>正常情况下, 使用<code>Latex</code>语法进行公式换行为<code>\\</code>, 但原本默认的渲染引擎<code>hexo-renderer-marked</code>和该语法冲突, 导致不能正常显示换行.</p>
<p>这个问题比较蛋疼, 试了好些办法, 最后选择的一种办法是更换引擎, 更换为<code>hexo-renderer-kramed</code>这个渲染引擎, 该引擎其实就是在<code>hexo-renderer-marked</code>基础上, 针对<code>mathjax</code>进行了改进, 使其优先支持<code>Latex</code>公式语法.</p>
<p>更换引擎代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>若更换过程中报错, 则根据错误信息提示, 进行相应操作即可.</p>
<p>最后, 若发现浏览器中仍然无法正常显示换行, 尝试更换浏览器. 在Windows系统下, 火狐浏览器即使更换了引擎也不行, 但谷歌浏览器可以.</p>
<p>Chrome大法好啊(｡･∀･)ﾉﾞ</p>
<p>可惜我的收藏夹几乎都在火狐上o(TヘTo)</p>
]]></content>
      <categories>
        <category>流程记录</category>
      </categories>
  </entry>
  <entry>
    <title>Self Dividing Numbers</title>
    <url>/2020/03/20/LeetCode/Self-Dividing-Numbers/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>A <strong>self-dividing number</strong> is a number that is divisible by every digit it contains.</p>
<p>For example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0</code>.</p>
<p>Also, a self-dividing number is not allowed to contain the digit zero.</p>
<p>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">left = 1, right = 22</span><br><span class="line">Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>The boundaries of each input argument are <code>1 &lt;= left &lt;= right &lt;= 10000</code>.</p>
<hr>
<p><strong>自除数</strong> 是指可以被它包含的每一位数除尽的数。</p>
<p>例如，128 是一个自除数，因为 <code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</p>
<p>还有，自除数不允许包含 0 。</p>
<p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">上边界left = 1, 下边界right = 22</span><br><span class="line">输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>每个输入参数的边界满足 <code>1 &lt;= left &lt;= right &lt;= 10000</code>。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>过于简单, 正常该怎么做就怎么做吧.</p>
<p>其实鉴于题目给出了范围, 所以在速度上最快的办法是先计算出1000以内所有的数, 然后再根据实际最大范围返回符合要求的就行, 不过没啥必要.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selfDividingNumbers</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type left: int</span></span><br><span class="line"><span class="string">        :type right: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">            str_i = str(i)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> <span class="keyword">in</span> str_i:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> str_i:</span><br><span class="line">                <span class="keyword">if</span> i % int(j) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> tag:</span><br><span class="line">                res_list.append(i)</span><br><span class="line">        <span class="keyword">return</span> res_list</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-20</li>
<li>击败比例: 77.42%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>Design HashMap</title>
    <url>/2020/03/18/LeetCode/Design-HashMap/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Design a HashMap without using any built-in hash table libraries.</p>
<p>To be specific, your design should include these functions:</p>
<ul>
<li><code>put(key, value)</code> : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.</li>
<li><code>get(key)</code>: Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</li>
<li><code>remove(key)</code> : Remove the mapping for the value key if this map contains the mapping for the key.</li>
</ul>
<a id="more"></a>
<p> <strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashMap hashMap = new MyHashMap();</span><br><span class="line">hashMap.put(1, 1);          </span><br><span class="line">hashMap.put(2, 2);         </span><br><span class="line">hashMap.get(1);            // returns 1</span><br><span class="line">hashMap.get(3);            // returns -1 (not found)</span><br><span class="line">hashMap.put(2, 1);          // update the existing value</span><br><span class="line">hashMap.get(2);            // returns 1 </span><br><span class="line">hashMap.remove(2);          // remove the mapping for 2</span><br><span class="line">hashMap.get(2);            // returns -1 (not found)</span><br></pre></td></tr></table></figure>
<p> <strong>Note:</strong></p>
<ul>
<li>All keys and values will be in the range of <code>[0, 1000000]</code>.</li>
<li>The number of operations will be in the range of <code>[1, 10000]</code>.</li>
<li>Please do not use the built-in HashMap library.</li>
</ul>
<hr>
<p>不使用任何内建的哈希表库设计一个哈希映射</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<ul>
<li><code>put(key, value)</code>：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。</li>
<li><code>get(key)</code>：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。</li>
<li><code>remove(key)</code>：如果映射中存在这个键，删除这个数值对。</li>
</ul>
<p> <strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashMap hashMap = new MyHashMap();</span><br><span class="line">hashMap.put(1, 1);          </span><br><span class="line">hashMap.put(2, 2);         </span><br><span class="line">hashMap.get(1);            // 返回 1</span><br><span class="line">hashMap.get(3);            // 返回 -1 (未找到)</span><br><span class="line">hashMap.put(2, 1);         // 更新已有的值</span><br><span class="line">hashMap.get(2);            // 返回 1 </span><br><span class="line">hashMap.remove(2);         // 删除键为2的数据</span><br><span class="line">hashMap.get(2);            // 返回 -1 (未找到)</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong></p>
<ul>
<li>所有的值都在 <code>[1, 1000000]</code>的范围内。</li>
<li>操作的总数目在<code>[1, 10000]</code>范围内。</li>
<li>不要使用内建的哈希库。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题与上一道题, 构造Hash集合非常相似.</p>
<p>我在上一道链表节点的基础上, 将原本的节点值变成了(key, val)对.</p>
<p>其余的处理几乎一致.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.bucket_list = [Bucket() <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">769</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hash</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">769</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        value will always be non-negative.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_val = self._hash(key)</span><br><span class="line">        self.bucket_list[hash_val].put(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_val = self._hash(key)</span><br><span class="line">        <span class="keyword">return</span> self.bucket_list[hash_val].get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the mapping of the specified value key if this map contains a mapping for the key</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_val = self._hash(key)</span><br><span class="line">        self.bucket_list[hash_val].remove(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val, next_node=None)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next_node = next_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bucket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.first_node = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        cur_node = self.first_node.next_node</span><br><span class="line">        <span class="keyword">while</span> cur_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.key == x:</span><br><span class="line">                cur_node.val = y</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            cur_node = cur_node.next_node</span><br><span class="line">        new_node = Node(x, y, self.first_node.next_node)</span><br><span class="line">        self.first_node.next_node = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        pre_node = self.first_node</span><br><span class="line">        cur_node = self.first_node.next_node</span><br><span class="line">        <span class="keyword">while</span> cur_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.key == x:</span><br><span class="line">                pre_node.next_node = cur_node.next_node</span><br><span class="line">                cur_node.next_node = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            pre_node = cur_node</span><br><span class="line">            cur_node = cur_node.next_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        cur_node = self.first_node.next_node</span><br><span class="line">        <span class="keyword">while</span> cur_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.key == x:</span><br><span class="line">                <span class="keyword">return</span> cur_node.val</span><br><span class="line">            cur_node = cur_node.next_node</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-18</li>
<li>击败比例: 42.56%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>创建属于自己的博客(一)</title>
    <url>/2020/03/17/%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80/</url>
    <content><![CDATA[<p>这里开始记录自己构建博客的流程, 帮助别人也是帮助自己.</p>
<p>当然, 每个人的需求是不一样的. 有的人不需要一个自己独有的博客, 因为现在有各种很好的流量平台, 知乎, 微信公众号等. 同时, 不同人的审美是不一样的, 也许我觉得简约明了就很漂亮, 一些人觉得充满各种图案颜色更好看. 对于博客的一些功能, 如社交链接, 打赏, 广告位等, 我暂时是没有啥兴趣的, 而可能一部分人希望加上这些功能, 能够更加充分地展示自己~</p>
<a id="more"></a>
<p>所以, 我这里会将重要的, 我自己需要的一些步骤和流程做记录. 我个人更喜欢Linux系统, 但是工作需要与他人交互, 所以现在使用更多的反而是Windows和mac OS. 后面的操作都是基于Windows的, 其它的系统如mac OS, Linux也是类似的.</p>
<p>如果以后有一天, 你看了我的流程, 发现自己在用的时候出错了, 或者你想添加不一样的更多的东西, 建议谷歌​​.</p>
<h1 id="借助别人的轮子"><a href="#借助别人的轮子" class="headerlink" title="借助别人的轮子"></a>借助别人的轮子</h1><p>说起来, 搭建博客, 写网页, 最专业的应该是偏开发, 前端的程序员. 而咱们如果从头去学, 成本太高, 也没必要.</p>
<p>很多大神程序员已经帮我们造好了各种轮子, 我们只要好好利用起来就行了.</p>
<blockquote>
<p>合理使用别人的轮子, 是对造轮子的人的一种尊重.</p>
</blockquote>
<p>而在搭建博客这块, 有几个(我使用)关键元素:</p>
<ul>
<li><strong>Hexo</strong>: 什么是Hexo? Hexo是一个快速, 简洁且高效的博客框架. Hexo使用Markdown(或其它渲染引擎)解析文章, 在几秒内, 即可利用靓丽的主题生成静态页面. <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官网</a>, 中文的哟.</li>
<li><strong>Next</strong>: 什么是Next? Next是一款可以与Hexo搭配使用的主题风格. <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next主题Github地址</a>.</li>
<li><strong>Github</strong>: 什么是Github? 啊…这…就不解释了哈哈.</li>
</ul>
<p>那么用举栗子的说法, 来解释一下这三个元素, 就是比如你想做一件衣服, 一件能够去参加艺术品展示的衣服. 那么Hexo就是裁缝, 负责将布料做成衣服; Next是设计师, 告诉裁缝怎么做漂亮一些; Github是模特, 将衣服穿上向大家展示.</p>
<p>需要说的是, 与上述的三个轮子, 具有相似功能的其它轮子也有一些, 不一定非要使用这几个轮子.</p>
<p>同时需要说明的是我使用的<code>Hexo</code>版本是<code>v3.9.0</code>, <code>Next</code>版本是<code>v7.2.0</code>.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul>
<li><a href="https://git-scm.com/download" target="_blank" rel="noopener">安装地址</a>.</li>
</ul>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><ul>
<li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装地址</a>.</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在Windows下使用PowerShell或者GitBash(更加推荐GitBash), 输入如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p>安装 Hexo 完成后, 执行下列命令, Hexo 将会在指定文件夹中新建所需要的文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后, 指定文件夹的目录如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>_config.yml</strong></p>
<p>网站的配置信息, 可以在此配置大部分的参数. 后续再做详细说明.</p>
</li>
<li><p><strong>scaffold</strong></p>
<p>模板文件夹, 文章的布局会根据模板来进行建立.</p>
</li>
<li><p><strong>source</strong></p>
<p>资源文件夹是存放用户资源(文章)的地方. </p>
<p>除 <code>_posts</code> 文件夹之外, 开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.</p>
<p>Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹, 而其他文件会被拷贝过去.</p>
</li>
<li><p><strong>themes</strong></p>
<p>主题文件夹, Hexo根据选定的主题来生成静态页面.</p>
</li>
</ul>
<h2 id="远端"><a href="#远端" class="headerlink" title="远端"></a>远端</h2><p>上文说到, 需要借助Github来帮助我们展示博客, 因此需要在Github上创建对应的仓库.</p>
<p>用于网站的仓库, 相比普通仓库多了一些限制和操作.</p>
<ul>
<li><p><strong>仓库名称</strong></p>
<p>必须满足如下格式: Github用户名.github.io, 如名字叫xiaoming, 就是xiaoming.github.io.</p>
</li>
<li><p><strong>仓库公开</strong></p>
<p>要给大家伙看的嘛, 自然不能是private的, 必须是public的.</p>
</li>
<li><p><strong>Github Pages</strong></p>
<p>进入到仓库的settings中, 往下面拉到Github Pages的版块, 进行相应配置.</p>
<p>可以填入自定义域名, 这个后续会加以说明.</p>
<p>建议勾选<code>Enforce HTTPS</code>, 这样Github会免费把你的网站升级成HTTPS, 更加安全.</p>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h2><p>我有点忘了是否安装Hexo, 建站以后, <code>themes</code>文件夹下会自带<code>Next</code>主题.</p>
<p>若没有, 需要自己安装主题. 以<code>Next</code>主题为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd themes/</span><br><span class="line">$ git init</span><br><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>主题文件夹的一般布局:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure>
<h2 id="Hexo-config-yml"><a href="#Hexo-config-yml" class="headerlink" title="Hexo_config.yml"></a>Hexo_config.yml</h2><p>一下对部分我认为较为重要, 以及基础的参数进行介绍.</p>
<ul>
<li><p><strong>网站相关</strong></p>
<p>|     参数      |                             描述                             |<br>| :—————-: | :—————————————————————————————: |<br>|    <code>title</code>    |                           网站标题                           |<br>|  <code>subtitle</code>   |                          网站副标题                          |<br>| <code>description</code> |                           网站描述                           |<br>|  <code>keywords</code>   |       网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。        |<br>|   <code>author</code>    |                           您的名字                           |<br>|  <code>language</code>   |               网站使用的语言, 我使用的zh-Hans                |<br>|  <code>timezone</code>   | 网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。 |</p>
</li>
<li><p><strong>网址相关</strong></p>
<p>|  参数  |                           描述                            |<br>| :——: | :———————————————————————————-: |<br>| <code>url</code>  | 网址, 修改为Github仓库地址, 如<a href="https://xiaoming.github.io/" target="_blank" rel="noopener">https://xiaoming.github.io/</a> |<br>| <code>root</code> |                    网站根目录, 默认为/                    |</p>
</li>
<li><p><strong>主题相关</strong></p>
<p>指定使用的主题. 如上文中我们在<code>theme</code>文件中安装了<code>Next</code>主题, 则可将其对应文件名进行设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: hexo-theme-next</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>部署相关</strong></p>
<p>这一部分的配置, 是告诉Hexo你要用什么方法来将博客部署到服务器上. 当然我是用的Github.</p>
<p>首先安装hexo-deployer-git:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后对应修改配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: git@github.com:xiaoming/xiaoming.github.io.git</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到这里, 基础的配置就完成了, 接下来进行主题的相关配置.</p>
<h2 id="主题-config-yml"><a href="#主题-config-yml" class="headerlink" title="主题 _config.yml"></a>主题 _config.yml</h2><p>相比Hexo的_config.yml, 主题文件中的_config.yml有更多的内容, 下面针对部分内容进行修改.</p>
<ul>
<li><p><strong>菜单设置</strong></p>
<p>这里设置你的博客有哪些主要的版块, 我的设置保留了主页, 关于, 分类, 归档.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子主题设置</strong></p>
<p>可以认为<code>Next</code>主题下包含了4个子主题: <code>Muse</code>, <code>Mist</code>, <code>Pisces</code>, <code>Gemini</code>.</p>
<p>根据个人喜好进行选择, 不满意可更换. 我选择的<code>Mist</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>侧边栏设置</strong></p>
<p>打开侧边栏:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">site_state: true</span><br></pre></td></tr></table></figure>
<p>目录显示相关:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true</span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br><span class="line">  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span><br><span class="line">  expand_all: false</span><br><span class="line">  # Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>
<p>在左边还是右边 , 宽度, 是否自动显示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position.</span><br><span class="line">  #position: left</span><br><span class="line">  position: right</span><br><span class="line">  </span><br><span class="line">  # Manual define the sidebar width. If commented, will be default for:</span><br><span class="line">  # Muse | Mist: 320</span><br><span class="line">  # Pisces | Gemini: 240</span><br><span class="line">  #width: 300</span><br><span class="line"></span><br><span class="line">  # Sidebar Display (only for Muse | Mist), available values:</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically.</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  totally remove sidebar including sidebar toggle.</span><br><span class="line">  display: hide</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码版块设置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字体设置</strong></p>
<p>暂时没有进行相关设置, 感觉默认的就还好.</p>
<p>如果要设置的话, 根据自带的帮助说明应该也能设置.</p>
<p>设置过多的字体的话, 博客的加载速度会变慢.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数学公式</strong></p>
<p>如果文章里面包含了数学公式, 需要利用进行如下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  engine: mathjax</span><br><span class="line">  #engine: katex</span><br></pre></td></tr></table></figure>
<p>同时, 在需要解析数学公式的文章前面, 添加<code>mathjax: true</code>.</p>
</li>
</ul>
<p>更多的配置, 以后会进行补充说明.</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>现在, 安装了需要的轮子, 并完成了基本的配置, 可以开始写博客了.</p>
<p>下面介绍几个基础但是够用的操作, 需要说的是以下操作均需要在博客文件夹中进行, 就是<code>hexo init</code>的那个.</p>
<ul>
<li><p><strong>新建文章</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>默认会在<code>source/_post/</code>中生成对应的md文件. 我们可以将文章写在里面.</p>
</li>
<li><p><strong>生成静态网页</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地查看</strong></p>
<p>在部署到Github之前, 可以先看看自己的博客, 文章是啥样的, 需不需要修改, 是否满足自己预期.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>部署</strong></p>
<p>觉得一切OK后, 将其部署到Github上.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清空历史信息</strong></p>
<p>类似于删除Git仓库的历史commit, 不会影响当前现有的内容.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>等成功部署之后, 就可以在对应网址下, 看到自己的博客了. </p>
<p>需要说的是部署是由延时的, 有时候需要十来分钟的时间. 所以如果你是第一次部署, 打开自己的链接, 发现404, 不要慌, 起来喝一杯热水.</p>
]]></content>
      <categories>
        <category>流程记录</category>
      </categories>
  </entry>
  <entry>
    <title>Design HashSet</title>
    <url>/2020/03/17/LeetCode/Design-HashSet/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Design a HashSet without using any built-in hash table libraries.</p>
<p>To be specific, your design should include these functions:</p>
<ul>
<li><code>add(value)</code>: Insert a value into the HashSet. </li>
<li><code>contains(value)</code> : Return whether the value exists in the HashSet or not.</li>
<li><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</li>
</ul>
<a id="more"></a>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet = new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    // returns true</span><br><span class="line">hashSet.contains(3);    // returns false (not found)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    // returns true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    // returns false (already removed)</span><br><span class="line"> **Note:**</span><br></pre></td></tr></table></figure>
<ul>
<li>All values will be in the range of <code>[0, 1000000]</code>.</li>
<li>The number of operations will be in the range of <code>[1, 10000]</code>.</li>
<li>Please do not use the built-in HashSet library.</li>
</ul>
<hr>
<p>不使用任何内建的哈希表库设计一个哈希集合</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<ul>
<li><code>add(value)</code>：向哈希集合中插入一个值。</li>
<li><code>contains(value)</code> ：返回哈希集合中是否存在这个值。</li>
<li><code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet = new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    // 返回 true</span><br><span class="line">hashSet.contains(3);    // 返回 false (未找到)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    // 返回 true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    // 返回  false (已经被删除)</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong></p>
<ul>
<li>所有的值都在 <code>[0, 1000000]</code>的范围内。</li>
<li>操作的总数目在<code>[1, 10000]</code>范围内。</li>
<li>不要使用内建的哈希集合库。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>在Python中, 内置的Hash集合数据结构有集合set.</p>
<p>一般构建Hash集合, 主要解决两个问题:</p>
<ul>
<li>Hash函数, 即将原本的元素映射到一个位置上.</li>
<li>冲突解决, 可能有多个不同的元素被Hash函数映射到一个位置, 这时候要想办法区分.</li>
</ul>
<p>一种简单的解决方法:</p>
<ul>
<li>Hash函数, 使用mode函数, 底数一般取一个质数.</li>
<li>冲突解决, 可以将同一位置的元素放入一个桶中, 进行操作.</li>
</ul>
<p>而对于桶的数据结构的选择, 考虑到桶的大小是变动的, 链表相比数组更加合适.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.bucket_list = [Bucket() <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">769</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hash</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">769</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_val = self._hash(key)</span><br><span class="line">        self.bucket_list[hash_val].add(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_val = self._hash(key)</span><br><span class="line">        self.bucket_list[hash_val].remove(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns true if this set contains the specified element</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_val = self._hash(key)</span><br><span class="line">        <span class="keyword">return</span> self.bucket_list[hash_val].contains(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, next_node=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next_node = next_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bucket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.first_node = Node(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.contains(x):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        new_node = Node(x, self.first_node.next_node)</span><br><span class="line">        self.first_node.next_node = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        pre_node = self.first_node</span><br><span class="line">        cur_node = self.first_node.next_node</span><br><span class="line">        <span class="keyword">while</span> cur_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.value == x:</span><br><span class="line">                pre_node.next_node = cur_node.next_node</span><br><span class="line">                cur_node.next_node = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            pre_node = cur_node</span><br><span class="line">            cur_node = cur_node.next_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        cur_node = self.first_node.next_node</span><br><span class="line">        <span class="keyword">while</span> cur_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_node.value == x:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur_node = cur_node.next_node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyHashSet()</span></span><br><span class="line"><span class="comment"># obj.add(key)</span></span><br><span class="line"><span class="comment"># obj.remove(key)</span></span><br><span class="line"><span class="comment"># param_3 = obj.contains(key)</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-17</li>
<li>击败比例: 40.30%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>1-bit and 2-bit Characters</title>
    <url>/2020/03/16/LeetCode/1-bit-and-2-bit-Characters/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10</code> or <code>11</code>).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">bits = [1, 0, 0]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: </span><br><span class="line">The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">bits = [1, 1, 1, 0]</span><br><span class="line">Output: False</span><br><span class="line">Explanation: </span><br><span class="line">The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p><code>1 &lt;= len(bits) &lt;= 1000</code>.</p>
<p><code>bits[i]</code> is always <code>0</code> or <code>1</code>.</p>
<hr>
<p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>11</code>)来表示。</p>
<p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li>
<li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>首先理解题意, 就是说我们有三个字符<code>0</code>, <code>10</code>, <code>11</code>, 然后对于给定的一个字符串, 最后一个字符串一定是<code>0</code>, 问是否只存在最后的字符是<code>0</code>(而不是<code>10</code>), 由以上三个字符组成字符串.</p>
<p>首先考虑一些边界条件, 如给定字符长度为1, 2的时候.</p>
<p>然后利用递归函数, 分布判断以下两种情况是否存在:</p>
<ul>
<li>最后的字符是<code>10</code>, 前面的字符串是否合理. 若合理则直接返回false.</li>
<li>最后的字符是<code>0</code>, 前面的字符串是否合理. 合理则返回true, 否则返回false.</li>
</ul>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>直接从左往右线性扫描, 若当前位置$i$的数字是<code>1</code>, 则只能是两位比特字符, 将$i$加2.</p>
<p>若当前位置$i$的数字是<code>0</code>, 则只能是一位比特字符, 将$i$加1.</p>
<p>根据最后落点的位置, 判断是否最后一个字符只能是<code>0</code>.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isOneBitCharacter</span><span class="params">(self, bits)</span>:</span></span><br><span class="line">        <span class="comment"># 边界情况处理.</span></span><br><span class="line">        n_bits = len(bits)</span><br><span class="line">        <span class="keyword">if</span> n_bits == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        bits.reverse()</span><br><span class="line">        <span class="keyword">if</span> bits == [<span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> bits[: <span class="number">2</span>] == [<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">and</span> self.helper(bits[<span class="number">2</span>:]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(bits[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, list_)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        递归函数.</span></span><br><span class="line"><span class="string">        对于给定序列, 能否由给定字符(0, 01, 11)组成.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> len(list_) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> list_[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(list_) == <span class="number">2</span>:</span><br><span class="line">            str_ = str(list_[<span class="number">0</span>]) + str(list_[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> str_ <span class="keyword">in</span> [<span class="string">'00'</span>, <span class="string">'01'</span>, <span class="string">'11'</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> list_[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.helper(list_[<span class="number">2</span>:]) <span class="keyword">or</span> self.helper(list_[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> list_[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> list_[<span class="number">1</span>] != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.helper(list_[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
<h2 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isOneBitCharacter</span><span class="params">(self, bits)</span>:</span></span><br><span class="line">        <span class="comment"># 边界情况处理.</span></span><br><span class="line">        n_bits = len(bits)</span><br><span class="line">        <span class="keyword">if</span> n_bits == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n_bits == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> bits[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; n_bits - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> bits[idx] == <span class="number">0</span>:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> idx == n_bits - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-16</li>
<li>击败比例: 80.12%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Bulls and Cows</title>
    <url>/2020/03/15/LeetCode/Bulls-and-Cows/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank" rel="noopener">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;1A3B&quot;</span><br><span class="line"></span><br><span class="line">Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;1A1B&quot;</span><br><span class="line"></span><br><span class="line">Explanation: The 1st 1 in friend&apos;s guess is a bull, the 2nd or 3rd 1 is a cow.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<hr>
<p>你正在和你的朋友玩 <a href="https://baike.baidu.com/item/猜数字/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin" target="_blank" rel="noopener">猜数字（Bulls and Cows）</a>游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</p>
<p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 <code>A</code> 表示公牛，用 <code>B</code> 表示奶牛。</p>
<p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;1A3B&quot;</span><br><span class="line"></span><br><span class="line">解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;1A1B&quot;</span><br><span class="line"></span><br><span class="line">解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>如果不使用hash(在python中通常以字典, 集合数据结构存在), 使用循环遍历的方式来做, 时间复杂度大概在$O(N^2)$这个量级.</p>
<p>若事先构建好hash表, 对两个字符串分别构建, 则时间复杂度会降低到$O(N)$.</p>
<p>比如利用字典, 储存每个字符的信息, 其key为字符, value为字符出现的位置的集合.</p>
<p>对每个字符, 比较两个字符串中, 其共同的位置个数, 将其累加到<code>A</code>上; 并在剩下的不同的位置中, 取个数的较小值, 将其累加到<code>B</code>上.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret, guess)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(secret) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0A0B'</span></span><br><span class="line">        <span class="keyword">if</span> len(secret) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> secret == guess:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'1A0B'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'0A0B'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># create hash table.</span></span><br><span class="line">        secret_hash_table = &#123;&#125;</span><br><span class="line">        guess_hash_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(secret)):</span><br><span class="line">            secret_str = secret[i]</span><br><span class="line">            <span class="keyword">if</span> secret_str <span class="keyword">not</span> <span class="keyword">in</span> secret_hash_table:</span><br><span class="line">                secret_hash_table[secret_str] = set([i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                secret_hash_table[secret_str].add(i)</span><br><span class="line"></span><br><span class="line">            guess_str = guess[i]</span><br><span class="line">            <span class="keyword">if</span> guess_str <span class="keyword">not</span> <span class="keyword">in</span> guess_hash_table:</span><br><span class="line">                guess_hash_table[guess_str] = set([i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                guess_hash_table[guess_str].add(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># search.</span></span><br><span class="line">        n_A = <span class="number">0</span></span><br><span class="line">        n_B = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> guess_hash_table:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> secret_hash_table:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            intersection = guess_hash_table[k].intersection(secret_hash_table[k])</span><br><span class="line">            <span class="keyword">if</span> len(intersection) != <span class="number">0</span>:</span><br><span class="line">                n_A += len(intersection)</span><br><span class="line">                secret_hash_table[k] = secret_hash_table[k].difference(intersection)</span><br><span class="line">                guess_hash_table[k] = guess_hash_table[k].difference(intersection)</span><br><span class="line">                n_B += min(len(secret_hash_table[k]), len(guess_hash_table[k]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n_B += min(len(secret_hash_table[k]), len(guess_hash_table[k]))</span><br><span class="line">        <span class="keyword">return</span> str(int(n_A)) + <span class="string">'A'</span> + str(int(n_B)) + <span class="string">'B'</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2020-03-15</li>
<li>击败比例: 60.86%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Kth Largest Element in a Stream</title>
    <url>/2019/08/13/LeetCode/Kth-Largest-Element-in-a-Stream/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Design a class to find the <strong>k</strong>th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int k = 3;</span><br><span class="line">int[] arr = [4,5,8,2];</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   // returns 4</span><br><span class="line">kthLargest.add(5);   // returns 5</span><br><span class="line">kthLargest.add(10);  // returns 5</span><br><span class="line">kthLargest.add(9);   // returns 8</span><br><span class="line">kthLargest.add(4);   // returns 8</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br> You may assume that <code>nums</code>‘ length ≥ <code>k-1</code> and <code>k</code> ≥ 1.</p>
<hr>
<p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>你的 <code>KthLargest</code> 类需要一个同时接收整数 <code>k</code> 和整数数组<code>nums</code> 的构造器，它包含数据流中的初始元素。每次调用 <code>KthLargest.add</code>，返回当前数据流中第K大的元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int k = 3;</span><br><span class="line">int[] arr = [4,5,8,2];</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   // returns 4</span><br><span class="line">kthLargest.add(5);   // returns 5</span><br><span class="line">kthLargest.add(10);  // returns 5</span><br><span class="line">kthLargest.add(9);   // returns 8</span><br><span class="line">kthLargest.add(4);   // returns 8</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong><br> 你可以假设 <code>nums</code> 的长度≥ <code>k-1</code> 且<code>k</code> ≥ 1。</p>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>对一堆已经存在的数据, 进行添加新的数, 并每次返回第K大的数. 很明显用堆这种数据结构来处理会比较自然, 关于堆的介绍可以在网上或者&lt;算法导论&gt;之类的书中找到, 这里暂不讨论堆的实现, 以后有空也许会在博客中实现一下堆.</p>
<p>在Python中, heapq中包含了最小堆(即堆顶是最小元素)的函数, 它是基于列表实现的.</p>
<p>这里有个小技巧, 就是不需要堆所有数据进行建堆和维护, 只需要排序后的前K个就行.</p>
<p>同时还有个坑, 即一开始给的元素个数可能没有K个, 需要注意下.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, nums)</span>:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; k:</span><br><span class="line">            self.nums = nums</span><br><span class="line">            self.k_num = <span class="literal">None</span></span><br><span class="line">            heapq.heapify(self.nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">            self.nums = nums[: k - <span class="number">1</span>]</span><br><span class="line">            self.k_num = nums[k - <span class="number">1</span>]</span><br><span class="line">            heapq.heapify(self.nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.k_num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">            self.k_num = heapq.heappop(self.nums)</span><br><span class="line">            <span class="keyword">return</span> self.k_num</span><br><span class="line">        <span class="keyword">if</span> val &lt;= self.k_num:</span><br><span class="line">            <span class="keyword">return</span> self.k_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.nums, val)</span><br><span class="line">            self.k_num = heapq.heappop(self.nums)</span><br><span class="line">            <span class="keyword">return</span> self.k_num</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-13</li>
<li>击败比例: 53.39%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Heap</category>
      </categories>
  </entry>
  <entry>
    <title>Employee Importance</title>
    <url>/2019/08/10/LeetCode/Employee-Importance/</url>
    <content><![CDATA[<h1 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h1><p>You are given a data structure of employee information, which includes the employee’s <strong>unique id</strong>, his <strong>importance value</strong> and his <strong>direct</strong> subordinates’ id.</p>
<p>For example, employee 1 is the leader of employee 2, and employee 2  is the leader of employee 3. They have importance value 15, 10 and 5,  respectively. Then employee 1 has a data structure like [1, 15, [2]],  and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note  that although employee 3 is also a subordinate of employee 1, the  relationship is <strong>not direct</strong>.</p>
<p>Now given the employee information of a company, and an employee id,  you need to return the total importance value of this employee and all  his subordinates.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">Output: 11</span><br><span class="line">Explanation:</span><br><span class="line">Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>One employee has at most one <strong>direct</strong> leader and may have several subordinates.</li>
<li>The maximum number of employees won’t exceed 2000.</li>
</ol>
<hr>
<p>给定一个保存员工信息的数据结构，它包含了员工<strong>唯一的id</strong>，<strong>重要度</strong> 和 <strong>直系下属的id</strong>。</p>
<p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15,  [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于<strong>并不是直系</strong>下属，因此没有体现在员工1的数据结构中。</p>
<p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出: 11</span><br><span class="line">解释:</span><br><span class="line">员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>一个员工最多有一个<strong>直系</strong>领导，但是可以有多个<strong>直系</strong>下属</li>
<li>员工数量不超过2000。</li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>今天这道总算稍微难一点点了.</p>
<p>首先利用Hash Table这种数据结构进行数据转存, 这样在反复查询的时候非常快捷. 在Python中的字典就是一个Hash Table.</p>
<p>然后就是利用深度优先搜索, 或者广度优先搜索进行遍历.</p>
<p>这里采用了深度优先搜索, 用到了递归, 也就是那个helper函数来实现遍历. 由于每个员工最多只有一个直属领导, 所以非常简单.</p>
<p>时间复杂度为$O(n)$, 空间复杂度为$O(m)$, 其中$m$为总员工数量, $n$为该员工对应下属数量.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Employee info</span></span><br><span class="line"><span class="string">class Employee:</span></span><br><span class="line"><span class="string">    def __init__(self, id, importance, subordinates):</span></span><br><span class="line"><span class="string">        # It's the unique id of each node.</span></span><br><span class="line"><span class="string">        # unique id of this employee</span></span><br><span class="line"><span class="string">        self.id = id</span></span><br><span class="line"><span class="string">        # the importance value of this employee</span></span><br><span class="line"><span class="string">        self.importance = importance</span></span><br><span class="line"><span class="string">        # the id of direct subordinates</span></span><br><span class="line"><span class="string">        self.subordinates = subordinates</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImportance</span><span class="params">(self, employees, id)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type employees: Employee</span></span><br><span class="line"><span class="string">        :type id: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.info_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> emp <span class="keyword">in</span> employees:</span><br><span class="line">            self.info_dict[emp.id] = (emp.importance, emp.subordinates)</span><br><span class="line">        <span class="keyword">return</span> self.helper(id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, id)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.info_dict[id][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.info_dict[id][<span class="number">0</span>]</span><br><span class="line">        imp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> sub_id <span class="keyword">in</span> self.info_dict[id][<span class="number">1</span>]:</span><br><span class="line">            imp += self.helper(sub_id)</span><br><span class="line">        <span class="keyword">return</span> imp + self.info_dict[id][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-10</li>
<li>击败比例: 51.09%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Hash</category>
      </categories>
  </entry>
  <entry>
    <title>Baseball Game</title>
    <url>/2019/08/09/LeetCode/Baseball-Game/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p> You’re now a baseball game point recorder. </p>
<p> Given a list of strings, each string can be one of the 4 following types: </p>
<ol>
<li><code>Integer</code> (one round’s score): Directly represents the number of points you get in this round.</li>
<li><code>&quot;+&quot;</code> (one round’s score): Represents that the points you get in this round are the sum of the last two <code>valid</code> round’s points.</li>
<li><code>&quot;D&quot;</code> (one round’s score): Represents that the points you get in this round are the doubled data of the last <code>valid</code> round’s points.</li>
<li><code>&quot;C&quot;</code> (an operation, which isn’t a round’s score): Represents the last <code>valid</code> round’s points you get were invalid and should be removed.</li>
</ol>
<p>Each round’s operation is permanent and could have an impact on the round before and the round after. </p>
<p>You need to return the sum of the points you could get in all the rounds. </p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">Output: 30</span><br><span class="line">Explanation: </span><br><span class="line">Round 1: You could get 5 points. The sum is: 5.</span><br><span class="line">Round 2: You could get 2 points. The sum is: 7.</span><br><span class="line">Operation 1: The round 2&apos;s data was invalid. The sum is: 5.  </span><br><span class="line">Round 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.</span><br><span class="line">Round 4: You could get 5 + 10 = 15 points. The sum is: 30.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">Output: 27</span><br><span class="line">Explanation: </span><br><span class="line">Round 1: You could get 5 points. The sum is: 5.</span><br><span class="line">Round 2: You could get -2 points. The sum is: 3.</span><br><span class="line">Round 3: You could get 4 points. The sum is: 7.</span><br><span class="line">Operation 1: The round 3&apos;s data is invalid. The sum is: 3.  </span><br><span class="line">Round 4: You could get -4 points (the round 3&apos;s data has been removed). The sum is: -1.</span><br><span class="line">Round 5: You could get 9 points. The sum is: 8.</span><br><span class="line">Round 6: You could get -4 + 9 = 5 points. The sum is 13.</span><br><span class="line">Round 7: You could get 9 + 5 = 14 points. The sum is 27.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>The size of the input list will be between 1 and 1000.</p>
<p>Every integer represented in the list will be between -30000 and 30000.</p>
<hr>
<p>你现在是棒球比赛记录员。 </p>
<p>给定一个字符串列表，每个字符串可以是以下四种类型之一：</p>
<ol>
<li><p><code>整数</code>（一轮的得分）：直接表示您在本轮中获得的积分数。</p>
</li>
<li><p><code>&quot;+&quot;</code>（一轮的得分）：表示本轮获得的得分是前两轮<code>有效</code> 回合得分的总和。</p>
</li>
<li><p><code>&quot;D&quot;</code>（一轮的得分）：表示本轮获得的得分是前一轮<code>有效</code> 回合得分的两倍。</p>
</li>
<li><code>&quot;C&quot;</code>（一个操作，这不是一个回合的分数）：表示您获得的最后一个<code>有效</code>回合的分数是无效的，应该被移除。</li>
</ol>
<p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。</p>
<p>你需要返回你在所有回合中得分的总和。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 = 15分。总数是：30。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 = 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 = 14分。总数是27。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>输入列表的大小将介于1和1000之间。</li>
<li>列表中的每个整数都将介于-30000和30000之间。</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>一道很简单的用栈这种数据结构进行处理的问题.</p>
<p>在Python中一般用列表作为一个栈. 剩下的用循环和条件选择就能轻松完成.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calPoints</span><span class="params">(self, ops)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ops:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                stack.append(int(i))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'C'</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">'D'</span>:</span><br><span class="line">                    stack.append(stack[<span class="number">-1</span>] * <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(stack[<span class="number">-1</span>] + stack[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-09</li>
<li>击败比例: 20.90%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Stack</category>
      </categories>
  </entry>
  <entry>
    <title>Fibonacci Number</title>
    <url>/2019/08/08/LeetCode/Fibonacci-Number/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>Given <code>N</code>, calculate <code>F(N)</code>.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>0 ≤ <code>N</code> ≤ 30.</p>
<hr>
<p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>给定 <code>N</code>，计算 <code>F(N)</code>。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>0 ≤ <code>N</code> ≤ 30</li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>嗯, 非常轻松的一道题. 肥不拉几数列我们小时候都学过. 这里理论上一个一个挨着求就行了, 需要注意的是没有必要保存历史数列, 也就是说用两个变量记录相邻的肥不拉几数就行.</p>
<p>时间复杂度$O(n)$, 空间复杂度$O(1)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        first, second = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N - <span class="number">1</span>):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-08</li>
<li>击败比例: 90.55%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Powerful Integers</title>
    <url>/2019/08/07/LeetCode/Powerful-Integers/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given two positive integers <code>x</code> and <code>y</code>, an integer is <em>powerful</em> if it is equal to <code>x^i + y^j</code> for some integers <code>i &gt;= 0</code> and <code>j &gt;= 0</code>.</p>
<p>Return a list of all powerful integers that have value less than or equal to <code>bound</code>.</p>
<p>You may return the answer in any order.  In your answer, each value should occur at most once.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: x = 2, y = 3, bound = 10</span><br><span class="line">Output: [2,3,4,5,7,9,10]</span><br><span class="line">Explanation: </span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: x = 3, y = 5, bound = 15</span><br><span class="line">Output: [2,4,6,8,10,14]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 100</code></li>
<li><code>1 &lt;= y &lt;= 100</code></li>
<li><code>0 &lt;= bound &lt;= 10^6</code></li>
</ul>
<hr>
<p>给定两个正整数 <code>x</code> 和 <code>y</code>，如果某一整数等于 <code>x^i + y^j</code>，其中整数 <code>i &gt;= 0</code> 且 <code>j &gt;= 0</code>，那么我们认为该整数是一个<em>强整数</em>。</p>
<p>返回值小于或等于 <code>bound</code> 的所有<em>强整数</em>组成的列表。</p>
<p>你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x = 2, y = 3, bound = 10</span><br><span class="line">输出：[2,3,4,5,7,9,10]</span><br><span class="line">解释： </span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x = 3, y = 5, bound = 15</span><br><span class="line">输出：[2,4,6,8,10,14]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 100</code></li>
<li><code>1 &lt;= y &lt;= 100</code></li>
<li><code>0 &lt;= bound &lt;= 10^6</code></li>
</ul>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>没错, 又是一道非常简单的题, “为啥一直做这么简单的题?” 先找下感觉~</p>
<p>这道题首先注意下边界条件, 即<code>bound</code>可能等于<code>0</code>和<code>1</code>这样的特殊值, 此时直接返回空集.</p>
<p>然后计算<code>x</code>和<code>y</code>最大可能的幂数, 此时要注意它们可能等于<code>1</code>的特殊情况.</p>
<p>最后利用二重循环找出所有可能的值, 利用集合去重即可.</p>
<p>时间复杂度为$O(mn)$, 其中$m$和$n$分别是<code>x</code>和<code>y</code>的最大幂数.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">powerfulIntegers</span><span class="params">(self, x, y, bound)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> bound == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> bound == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res_list = []</span><br><span class="line">        max_x = int(math.log(bound) / math.log(x)) <span class="keyword">if</span> x != <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        max_y = int(math.log(bound) / math.log(y)) <span class="keyword">if</span> y != <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_x + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(max_y + <span class="number">1</span>):</span><br><span class="line">                num = x**i + y**j</span><br><span class="line">                <span class="keyword">if</span> num &lt;= bound:</span><br><span class="line">                    res_list.append(num)</span><br><span class="line">        <span class="keyword">return</span> list(set(res_list))</span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-07</li>
<li>击败比例: 78.57%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>Duplicate Zeros</title>
    <url>/2019/08/06/LeetCode/Duplicate-Zeros/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>Given a fixed length array <code>arr</code> of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.</p>
<p>Note that elements beyond the length of the original array are not written.</p>
<p>Do the above modifications to the input array <strong>in place</strong>, do not return anything from your function.</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
</ol>
<hr>
<p>给你一个长度固定的整数数组 <code>arr</code>，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p>
<p>注意：请不要在超过该数组长度的位置写入元素。</p>
<p>要求：请对输入的数组 <strong>就地</strong> 进行上述修改，不要从函数返回任何东西。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,0,2,3,0,4,5,0]</span><br><span class="line">输出：null</span><br><span class="line">解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3]</span><br><span class="line">输出：null</span><br><span class="line">解释：调用函数后，输入的数组将被修改为：[1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
</ol>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>非常简单的一道题, 利用Python数组可以切片, 每次只要将对应的子数组向后复制就行了, 时间复杂度为$O(n)$, 空间复杂度为$O(1)$.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicateZeros</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify arr in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        len_arr = len(arr)</span><br><span class="line">        <span class="keyword">if</span> len_arr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len_arr:</span><br><span class="line">            <span class="keyword">if</span> arr[i] == <span class="number">0</span>:</span><br><span class="line">                arr[i + <span class="number">1</span>:] = arr[i:<span class="number">-1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-06</li>
<li>击败比例: 12.56%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Last Stone Weight</title>
    <url>/2019/08/05/LeetCode/Last-Stone-Weight/</url>
    <content><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>We have a collection of rocks, each rock has a positive integer weight.</p>
<p>Each turn, we choose the two <strong>heaviest</strong> rocks and smash them together.  Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>.  The result of this smash is:</p>
<ul>
<li>If <code>x == y</code>, both stones are totally destroyed;</li>
<li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of weight <code>y</code> has new weight <code>y-x</code>.</li>
</ul>
<a id="more"></a>
<p>At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)</p>
<hr>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块<strong>最重的</strong>石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下就返回 <code>0</code>。</p>
<h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><p>这道题属于一道简单题, 可以直接用贪心法做, 如我这样的做法.</p>
<p>另外一种是利用堆的数据结构, 构造一个最大堆, 每次能够直接拿出最大的元素.</p>
<p>理论上利用最大堆可以有更小的时间复杂度, 我的代码的时间复杂度为$O(n^2)$.</p>
<p>但实际上当元素少的时候, 速度可以更快.</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span><span class="params">(self, stones)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> len(stones) &gt;= <span class="number">2</span>:</span><br><span class="line">            stone_0 = max(stones)</span><br><span class="line">            stones.remove(stone_0)</span><br><span class="line">            stone_1 = max(stones)</span><br><span class="line">            stones.remove(stone_1)</span><br><span class="line">            stone_2 = stone_0 - stone_1</span><br><span class="line">            <span class="keyword">if</span> stone_2 &gt; <span class="number">0</span>:</span><br><span class="line">                stones.append(stone_2)</span><br><span class="line">        <span class="keyword">if</span> stones:</span><br><span class="line">            <span class="keyword">return</span> int(stones[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="速度排名"><a href="#速度排名" class="headerlink" title="速度排名"></a>速度排名</h1><ul>
<li>时间节点: 2019-08-05</li>
<li>击败比例: 81.62%</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Greedy</category>
      </categories>
  </entry>
  <entry>
    <title>写在最前面的</title>
    <url>/2019/07/29/%E6%91%86%E9%BE%99%E9%97%A8%E9%98%B5/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2%E7%9A%84/</url>
    <content><![CDATA[<h1 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h1><p>写博客这件事情, 是我从很久以前就想要做的, 但是一直拖到现在, 我想一来是我有点拖延症, 二来是没有找到合适的网站/网站外观.</p>
<p>现在国内一般可以用来写博客的并不多, 比较好的有简书, 博客园, 剩下的一些比如CSDN, 知乎…虽然它们在其它一些方面很有用, 但是就写博客来说叭太行. 而简书和博客园的外观以及功能可以一定程度上地定制, 但是终究不是很喜欢(没错我看脸的), 还有一点是有广告…</p>
<a id="more"></a>
<p>所以, 有一个自己相对独立的博客就有必要了, 但是完全独立对我来说并不那么需要, 于是依托于github的免费服务器, 再利用Hexo的定制功能就是比较理想的选择.</p>
<p>关于怎么用上面那个方法搭建博客以后也许我会写一下, 步骤正确以后非常简单. 而对于博客的定制我也还在慢慢摸索, 现在我的博客很简洁, 以后会逐渐加入搜索, 评论等功能, 这样能更好地方便读者, 以及和读者进行互动.</p>
<p>Ok, 有了写博客的地方, 那我接下来要写一些什么样的文章呢?</p>
<p>首先我想写一写一些类似于聊天一样的文章, 我把这类文章的分类定为”摆龙门阵”, 嘿嘿, 因为我是巴渝的人.</p>
<p>然后我的工作是需要用到统计分析, 机器学习这些东西的, 所以也会写一些关于这方面的文章. 如果写我特别熟悉的部分, 算是一种对知识结构的梳理; 如果写我也刚接触的知识, 那能够让我尽可能去搞明白其前因后果, 自己大概懂了和写出来想让别人也懂是两码事, 至少…能够顺利地import, 做一个快乐的调包侠对吧~</p>
<p>还有一些东西比如图算法, 自然语言处理, 这些我暂时用不到但是以后很可能会用到的技能, 我会一边学习, 一边总结分享.</p>
<p>最后还有数据结构和算法题, 我估计我会两三天做一道. 刷题可以同时锻炼思维能力和代码能力, 无论是一个合格的程序员, 还是以后有一天不靠码代码维生了, 我认为都是很有用的. 而且, 当在LeetCode上提交代码, 得到一个大大的绿色的Accept的时候, 大脑会分泌多巴胺!</p>
<p>此外, 写博客还有一个目的, 大概是在两年以前, 我接触并逐渐开始理解”开源”这个词, 一开始我并不理解它的意思, 而作为一个一路自学过来的人, 现在可以说如果没有”开源”, 就不会有现在的我. </p>
<blockquote>
<p>我相信, 一定程度上的开源, 可以让世界变得更加美好!</p>
</blockquote>
<p>当你要主动去学习一些东西的时候, 那么就去找资料, 可以谷歌(大伙懂的…), 可以去一些社区寻求答案. ApacheCN, github, 知乎, kaggle, YouTube等等, 很多的人在分享他们的代码, 他们的经验, 无数的知识躺在那里, 等着想要学习的人去学习. 而现在, 我受益于开源, 也想要回报开源, 这也是我写博客的一大原因之一.</p>
<p>总结下就是:</p>
<ul>
<li>觉得写博客很酷!</li>
<li>写博客可以帮我更好地理解知识(自己都不懂还来教别人???)</li>
<li>可以和世界各地的人(理论上)的人交流问题.</li>
<li>回报开源.</li>
</ul>
<h1 id="我的黄金三年"><a href="#我的黄金三年" class="headerlink" title="我的黄金三年"></a>我的黄金三年</h1><p>趁我刚毕业没多久, 一些东西还没有忘记, 把一些对我人生改变很大的事情记录下来.</p>
<p>一直一来很多事情都能对一个人的人生产生影响, 有好有坏, 有大有小, 而我之所以要写下了, 如小标题所言, 我认为这些事情是有意义的. 它们也许改变了我的世界线, 也许世界线会收束, 它们的影响其实很小, 但都是我的黄金三年.</p>
<h2 id="放弃了物理"><a href="#放弃了物理" class="headerlink" title="放弃了物理."></a>放弃了物理.</h2><p>说出来可能你不信, 我当初是想成为一名物流学家的, 可以拿诺贝尔奖的那种, 爱因斯坦是我的偶像.</p>
<p>我以前物理学得应该还算好吧, 其次我对这个世界感兴趣, 但这些并不是让我学物理的全部原因, 还有一个很重要的原因, 我想要时光机, 我想要长生不老. 而我认为达成这两样, 或者就时光机来说, 正确的路径, 就是物理.</p>
<p>我想要时光机, 回到过去, 改变一些东西.</p>
<p>而后的一段时间, 我没有好好学习, 是的, 和大多数大学生一样, 翘课, 考试临时抱佛脚, 打游戏. 还好我打游戏比较厉害, 相比玩得菜的能获得更多的快乐哈哈哈. 本来没好好学习想甩锅的, 想想还是算了, 脑子长自己头上, 别人把你关起来不让你学了?</p>
<p>再到后来, 经过大概一个假期的纠结, 我决定放弃当初那个要成为物理学家的想法. </p>
<p>当时我哭了吗? 应该没有吧.</p>
<blockquote>
<p>这个世界, 所有世界线, 都不可能存在时光机!</p>
</blockquote>
<h2 id="谈了场恋爱"><a href="#谈了场恋爱" class="headerlink" title="谈了场恋爱?"></a>谈了场恋爱?</h2><p><code>自我A</code>: 痛苦吗?</p>
<p><code>自我B</code>: 很痛苦!</p>
<p><code>自我A</code>: 问心无愧吗?</p>
<p><code>自我B</code>: 问心无愧!</p>
<p><code>自我A</code>: 浪费的时间可惜吗?</p>
<p><code>自我B</code>: 可惜! 但也许是我必须经历的, 我对世界的认知还太少, 我的自控能力还太差.</p>
<p><code>自我A</code>: 熬夜, 暴饮暴食, 不锻炼, 现在你的身体素质不太好啊.</p>
<p><code>自我B</code>: 是的, 不过一切都在慢慢好转. 我现在没有暴饮暴食, 不会过度熬夜, 偶尔会进行室内运动. 等春暖花开, 我会去跑步的.</p>
<p><code>自我A</code>: 有总结过经验吗?</p>
<p><code>自我B</code>: 哈哈哈, 非要说的话, “不做舔狗”吧.</p>
<p><code>自我A</code>: 你还记得多少?</p>
<p><code>自我B</code>: 时间自然会帮我忘记.</p>
<p><code>自我A</code>: 那个小男孩还活着吗?</p>
<p><code>自我B</code>: 这你直接问<code>自我C</code>了啊…小C很好, 现在睡得很香, 还说睡醒了一起开黑呢.</p>
<h2 id="交了群朋友"><a href="#交了群朋友" class="headerlink" title="交了群朋友!"></a>交了群朋友!</h2><p>在研究生期间, 室友, 同学, 师兄师姐对我都挺好的, 不知道从哪说起, 就想到啥说啥吧.</p>
<p>先说室友A, 我的Linux大门是他帮忙打开的, 还记得当时我的小黑在win7上卡的快成PPT了, 他向我安利了Ubuntu, 并帮我用U盘进行了安装, 从此过后(直到毕业)再没用win系统做过正事(除了玩游戏).</p>
<p>再说室友B, 在我放弃物理后, 都是能混就混了, 没错我就是个混子嗷. 室友B学习比较扎实, 关键是他乐于传教, 有不懂的知识可以问, 不会的题可以抄…某种意义上, 要是没他帮我, 我可能毕不了业.</p>
<p>还有室友C, 接下来就亲切的称呼他为宝子哥好了, 宝子哥乃教育学某大师关门弟子, 造诣自不必多言. 精通心理学, 心理暗示, 传销…啊不没传销, 反正就是很厉害的一个人. 我还记得他对我的谆谆教诲:</p>
<blockquote>
<p>没人对你说过, 你很帅吗?</p>
<p>诶, 你真的觉得我帅吗?</p>
<p>当年本科的时候, 大伙来的时候就我一个有女朋友, 毕业的时候基本上都有女朋友了.</p>
<p>老哥, 你废了.</p>
<p>你有没有听说过…PXX(少儿不宜, 手动屏蔽).</p>
</blockquote>
<p>除了室友, 好几个同学人都很好, 能遇到这么好的一群人实属幸事!</p>
]]></content>
      <categories>
        <category>摆龙门阵</category>
      </categories>
  </entry>
</search>
